/*! wembli-website 2014-08-06 */
"use strict";

angular.module("wembliApp", [ "ngRoute", "ngAnimate", "mgcrea.ngStrap", "wembliApp.controllers", "wembliApp.controllers.addOns", "wembliApp.controllers.header", "wembliApp.filters", "wembliApp.services", "wembliApp.services.header", "wembliApp.services.facebook", "wembliApp.services.twitter", "wembliApp.services.pixel", "wembliApp.services.google", "wembliApp.services.addOns", "wembliApp.directives", "wembliApp.directives.header", "wembliApp.directives.addOns" ]).config([ "$routeProvider", "$locationProvider", function() {} ]).run([ "$timeout", "initRootScope", "$rootScope", "$location", "$route", "$window", "facebook", "twitter", "plan", "wembliRpc", "overlay", function($timeout, initRootScope, $scope, $location, $route, $window, facebook, twitter, plan, wembliRpc, overlay) {
    console.log("run addOns angular app"), overlay.loading(!0), overlay.show(), $timeout(function() {
        plan.fetch(function() {});
    }), $window.fbAsyncInit = function() {
        facebook.getLoginStatus(), $scope.facebook = facebook;
    }, twitter.getLoginStatus();
} ]), angular.module("wembliApp.controllers.addOns", []).controller("HotelsCtrlOff", [ "$rootScope", "$scope", "$timeout", "plan", "wembliRpc", "googleMap", "mapInfoWindowContent", "loadingModal", function($rootScope, $scope, $timeout, plan, wembliRpc, googleMap, mapInfoWindowContent, loadingModal) {
    function getHotels(p) {
        googleMap.isDrawn(!1);
        var lat = p.venue.data.geocode.geometry.location.lat, lng = p.venue.data.geocode.geometry.location.lng, marker = new google.maps.Marker({
            map: googleMap.getMap(),
            position: new google.maps.LatLng(lat, lng)
        });
        marker.setIcon("/images/icons/map-icons/sports/stadium.png"), marker.setAnimation(google.maps.Animation.DROP);
        var win = new google.maps.InfoWindow({
            content: mapInfoWindowContent.create({
                header: p.event.eventVenue,
                body: p.venue.data.Street1 + ", " + p.event.eventCity + ", " + p.event.eventState
            }),
            pixelOffset: new google.maps.Size(10, 0)
        });
        google.maps.event.addListener(marker, "click", function() {
            googleMap.isInfoWindowOpen(marker) ? googleMap.closeInfoWindow(marker) : googleMap.openInfoWindow(marker);
        }), googleMap.addMarker(marker), googleMap.addInfoWindow(win, marker), googleMap.openInfoWindow(marker);
        var request = {
            location: new google.maps.LatLng(lat, lng),
            radius: 1500,
            types: [ "lodging" ]
        }, service = new google.maps.places.PlacesService(googleMap.getMap());
        service.nearbySearch(request, function(results, status) {
            status == google.maps.places.PlacesServiceStatus.OK && $scope.$apply(function() {
                $scope.googleHotels = results;
            });
        }), wembliRpc.fetch("event.getHotels", {
            lat: lat,
            lng: lng
        }, function(err, result) {
            if (err) return void alert("error happened - contact help@wembli.com");
            $timeout(function() {
                $scope.$apply(function() {
                    $scope.hotels = result.hotels;
                });
            });
            var minHotelPrice = 0, maxHotelPrice = 600, filterHotel = function() {
                $("#price-slider").slider("option", "values");
            };
            $("#price-slider").slider({
                range: !0,
                min: minHotelPrice,
                max: maxHotelPrice,
                step: 5,
                values: [ minHotelPrice, maxHotelPrice ],
                slide: function(event, ui) {
                    $("#amount").val("$" + ui.values[0] + " - $" + ui.values[1]);
                },
                stop: function() {
                    filterHotel();
                }
            });
            var amtVal = "$" + $("#price-slider").slider("values", 0) + " - $" + $("#price-slider").slider("values", 1);
            $("#amount").val(amtVal), $("#quantity-filter").change(function() {
                filterHotel();
            }), loadingModal.hide();
        }, function(data) {
            return data;
        }, function(data) {
            return JSON.parse(data);
        });
    }
    loadingModal.show("Finding hotels...", null), $scope.determineRange = function(price) {
        var i = parseFloat(price);
        return 20 >= i ? "$" : i > 20 && 50 >= i ? "$$" : i > 50 ? "$$$" : void 0;
    }, $scope.notFound = !0, $scope.$watch("hotels", function(hotels) {
        hotels && $timeout(function() {
            angular.forEach(hotels.listing, function(v) {
                if (!googleMap.hasMarker(v.lat, v.lng)) {
                    var marker = new google.maps.Marker({
                        position: new google.maps.LatLng(v.lat, v.lng),
                        map: googleMap.getMap()
                    });
                    marker.setIcon("/images/icons/map-icons/entertainment/hotel_0star.png"), marker.setAnimation(google.maps.Animation.DROP);
                    var win = new google.maps.InfoWindow({
                        content: mapInfoWindowContent.create({
                            header: v.location_name,
                            body: v.address + ", " + v.city
                        }),
                        pixelOffset: new google.maps.Size(10, 0)
                    });
                    google.maps.event.addListener(marker, "click", function() {
                        googleMap.isInfoWindowOpen(marker) ? googleMap.closeInfoWindow(marker) : googleMap.openInfoWindow(marker);
                    }), googleMap.addMarker(marker), googleMap.addInfoWindow(win, marker);
                }
            });
        });
    });
    var deregGP = $scope.$watch("googleHotels", function(hotels) {
        hotels && $timeout(function() {
            angular.forEach(hotels, function(place) {
                var marker = new google.maps.Marker({
                    map: googleMap.getMap(),
                    position: place.geometry.location
                });
                marker.setIcon("/images/icons/map-icons/entertainment/hotel_0star.png"), marker.setAnimation(google.maps.Animation.DROP);
                var win = new google.maps.InfoWindow({
                    content: mapInfoWindowContent.create({
                        header: place.name,
                        body: place.vicinity
                    }),
                    pixelOffset: new google.maps.Size(10, 0)
                });
                google.maps.event.addListener(marker, "click", function() {
                    googleMap.isInfoWindowOpen(marker) ? googleMap.closeInfoWindow(marker) : googleMap.openInfoWindow(marker);
                }), googleMap.addMarker(marker), googleMap.addInfoWindow(win, marker);
            }), deregGP();
        });
    });
    plan.get(function(p) {
        if ($scope.context = plan.getContext() || "visitor", $scope.backToPlan = !0, 0 == plan.getFriends().length && ($scope.backToPlan = !1), 
        "friend" === $scope.context && ($scope.backToPlan = !0), googleMap.isDrawn()) getHotels(p); else var dereg = $rootScope.$on("google-map-drawn", function() {
            getHotels(p), dereg();
        });
    });
} ]).controller("HotelsCtrl", [ "$rootScope", "$scope", "$timeout", "plan", "wembliHotels", "wembliRpc", "googleMap", "googlePlaces", "mapVenue", "mapMarker", "mapInfoWindowContent", "overlay", "$location", "$window", "googleAnalytics", "header", function($rootScope, $scope, $timeout, plan, wembliHotels, wembliRpc, googleMap, googlePlaces, mapVenue, mapMarker, mapInfoWindowContent, overlay, $location, $window, googleAnalytics, header) {
    header.fixed(), googleMap.init(), $scope.currentPath = $location.path(), $scope.addonsFetched = 0, 
    $scope.filteredList = !1, $scope.notFound = !0, $scope.parseDate = function(d) {
        return new Date(d);
    }, $scope.determineDistance = function(feet) {
        return parseFloat(feet / 5280).toFixed(2);
    };
    var filterNone = function() {
        $scope.filteredList = !1, $timeout(function() {
            $scope.$apply(function() {
                for (var i = 0; i < $scope.hotels.length; i++) $scope.hotels[i].hide = !1;
            });
        });
    };
    $scope.filterNone = filterNone;
    var filterHotelsById = function(id) {
        return $scope.filteredList = !0, "undefined" == typeof id ? filterNone() : void $scope.$apply(function() {
            for (var i = 0; i < $scope.hotels.length; i++) $scope.hotels[i].hide = $scope.hotels[i].id != id;
        });
    }, updateHotels = function(hotels) {
        $scope.notFound = !1, "undefined" != typeof hotels && angular.forEach(hotels, function(d, i) {
            d.service = "yipit", d.hide = "undefined" == typeof d.hide ? !1 : d.hide, d.inPlan = !1;
            var dList = plan.getHotels();
            if ("undefined" != typeof dList && "undefined" != typeof dList[0]) for (var i = 0; i < dList.length; i++) {
                var r = dList[i];
                "yipit" === r.hotel.service && r.hotel.id == d.id && (d._id = r._id, d.purchased = r.purchased, 
                d.inPlan = !0);
            }
            googleMap.hasMarker(d.business.locations[0].lat, d.business.locations[0].lon) || mapMarker.create(googleMap, {
                icon: "/images/icons/map-icons/entertainment/hotel_0star.png",
                lat: d.business.locations[0].lat,
                lng: d.business.locations[0].lon,
                name: d.title,
                body: d.business.name,
                click: {
                    on: function() {
                        filterHotelsById(d.id);
                    },
                    off: function() {
                        filterHotelsById();
                    }
                }
            });
        });
    }, updateGoogleHotels = function(googleHotels) {
        $scope.notFound = !1, "undefined" != typeof googleHotels && (console.log(googleHotels), 
        angular.forEach(googleHotels, function(place, i) {
            place.service = "google", place.hide = "undefined" == typeof place.hide ? !1 : place.hide, 
            place.inPlan = !1;
            var hList = plan.getHotels();
            if ("undefined" != typeof hList && "undefined" != typeof hList[0]) for (var i = 0; i < hList.length; i++) {
                var h = hList[i];
                "google" === h.hotel.service && h.hotel.id == place.id && (place._id = h._id, place.inPlan = !0);
            }
            googleMap.hasMarker(place.geometry.location.lat(), place.geometry.location.lng()) || mapMarker.create(googleMap, {
                icon: "/images/icons/map-icons/entertainment/hotel_0star.png",
                position: place.geometry.location,
                name: place.name,
                body: place.vicinity
            });
        }));
    };
    $scope.$on("hotels-changed", function() {
        $timeout(function() {
            return updateHotels($scope.hotels);
        }), $timeout(function() {
            return updateGoogleHotels($scope.googleHotels);
        });
    }), $scope.$watch("hotels", function(hotels) {
        hotels && $timeout(function() {
            return updateHotels(hotels);
        });
    }), $scope.$watch("googleHotels", function(googleHotels) {
        googleHotels && $timeout(function() {
            return updateGoogleHotels(googleHotels);
        });
    }), $scope.$watch("addonsFetched", function(n) {
        n && n > 0 && ($scope.addonsFetched = 0, overlay.loading(!1), overlay.hide());
    });
    var initMap = function(p) {
        var lat = p.venue.data.geocode.geometry.location.lat, lng = p.venue.data.geocode.geometry.location.lng;
        $(".addons-list-col").css("height", $($window).height() - 111), mapVenue.create(googleMap, {
            lat: lat,
            lng: lng,
            name: p.event.eventVenue,
            street: p.venue.data.Street1,
            city: p.event.eventCity,
            state: p.event.eventState
        }), wembliHotels.fetchGoogleHotels({
            lat: lat,
            lng: lng
        }, function(err, h) {
            $scope.$apply(function() {
                $scope.googleHotels = h, $scope.addonsFetched++;
            });
        });
    }, addHotel = function(r) {
        var payment = {};
        "yipit" !== r.service && (payment.receipt = {
            "not-available": !0
        }), wembliRpc.fetch("plan.addHotel", {
            service: r.service,
            eventId: plan.get().event.eventId,
            hotel: r,
            total: 0,
            payment: JSON.stringify(payment)
        }, function(err, result) {
            if (console.log("added hotel:"), console.log(err, result), r._id = result.hotel._id, 
            r.inPlan = !0, $scope.currentHotel = r, "split-first" === $scope.plan.preferences.payment) $scope.hotelConfirm = !0, 
            overlay.show(); else {
                $timeout(function() {
                    $rootScope.$apply(function() {
                        $scope.buyHotelOffsite = !0, overlay.show();
                    });
                }, 1500);
            }
        });
    };
    $scope.addHotel = function(idx) {
        var hotel = $scope.hotels[idx];
        console.log(hotel), delete hotel.$$hashKey, addHotel(hotel);
    }, $scope.addGoogleHotel = function(idx) {
        var hotel = $scope.googleHotels[idx];
        delete hotel.$$hashKey, googlePlaces.getDetails(hotel.reference, function(place, status) {
            status == google.maps.places.PlacesServiceStatus.OK && $scope.$apply(function() {
                $scope.hotelDetails = place, addHotel(hotel);
            });
        });
    }, $scope.removeHotel = function() {
        var hotelId = $scope.currentHotel._id;
        return hotelId ? void plan.removeHotel({
            hotelId: hotelId
        }, function(err, results) {
            $scope.currentHotel && delete $scope.currentHotel, $scope.buyHotelOffsite && ($scope.buyHotelOffsite = !1, 
            overlay.hide()), $scope.hotelConfirm && ($scope.hotelConfirm = !1, overlay.hide()), 
            plan.setHotels(results.hotel), $rootScope.$broadcast("hotels-changed");
        }) : ($scope.hotelConfirm = !1, $scope.buyHotelOffsite = !1, void overlay.hide());
    }, $scope.boughtHotel = function() {
        return "undefined" == typeof $scope.currentHotel ? void ($window.location.href = $scope.nextLink) : void plan.addHotelReceipt({
            hotelId: $scope.currentHotel._id,
            service: $scope.currentHotel.service,
            receipt: {
                qty: $scope.currentHotel.selectedQty,
                amountPaid: $scope.currentHotel.amountPaid
            }
        }, function() {
            googleAnalytics.trackEvent("Plan", "boughtHotel", $scope.plan.event.eventName, "", function() {
                $window.location.href = $scope.nextLink;
            });
        });
    }, $rootScope.$on("overlay-clicked", function() {
        $scope.removeHotel($scope.currentHotel._id);
    }), plan.get(function(p) {
        if ($scope.context = plan.getContext() || "visitor", $scope.backToPlan = !1, null !== p.organizer.rsvp.decision && ($scope.backToPlan = !0), 
        $scope.nextLink = $scope.backToPlan ? "/plan" : "/event-options/" + p.event.eventId + "/" + p.event.eventName, 
        $scope.nextText = $scope.backToPlan ? "Ok, Back To Plan Dashboard" : "Continue To Plan Preferences", 
        "friend" === $scope.context && ($scope.backToPlan = !0), googleMap.isDrawn()) initMap(p); else var dereg = $rootScope.$on("google-map-drawn", function() {
            initMap(p), dereg();
        });
    });
} ]).controller("RestaurantsCtrl", [ "$rootScope", "$scope", "$timeout", "plan", "wembliRestaurants", "wembliRpc", "googleMap", "googlePlaces", "mapVenue", "mapMarker", "mapInfoWindowContent", "overlay", "$location", "$window", "googleAnalytics", "header", function($rootScope, $scope, $timeout, plan, wembliRestaurants, wembliRpc, googleMap, googlePlaces, mapVenue, mapMarker, mapInfoWindowContent, overlay, $location, $window, googleAnalytics, header) {
    header.fixed(), googleMap.init(), $scope.currentPath = $location.path(), $scope.addonsFetched = 0, 
    $scope.filteredList = !1, $scope.notFound = !0, $scope.parseDate = function(d) {
        return new Date(d);
    }, $scope.determineDistance = function(feet) {
        return parseFloat(feet / 5280).toFixed(2);
    };
    var filterNone = function() {
        $scope.filteredList = !1, $timeout(function() {
            $scope.$apply(function() {
                for (var i = 0; i < $scope.deals.length; i++) $scope.deals[i].hide = !1;
            });
        });
    };
    $scope.filterNone = filterNone;
    var filterDealsById = function(id) {
        return $scope.filteredList = !0, "undefined" == typeof id ? filterNone() : void $scope.$apply(function() {
            for (var i = 0; i < $scope.deals.length; i++) $scope.deals[i].hide = $scope.deals[i].id != id;
        });
    }, updateDeals = function(deals) {
        $scope.notFound = !1, "undefined" != typeof deals && angular.forEach(deals, function(d, i) {
            d.service = "yipit", d.hide = "undefined" == typeof d.hide ? !1 : d.hide, d.inPlan = !1;
            var dList = plan.getRestaurants();
            if ("undefined" != typeof dList && "undefined" != typeof dList[0]) for (var i = 0; i < dList.length; i++) {
                var r = dList[i];
                "yipit" === r.restaurant.service && r.restaurant.id == d.id && (d._id = r._id, d.purchased = r.purchased, 
                d.inPlan = !0);
            }
            googleMap.hasMarker(d.business.locations[0].lat, d.business.locations[0].lon) || mapMarker.create(googleMap, {
                icon: "/images/icons/map-icons/entertainment/restaurant.png",
                lat: d.business.locations[0].lat,
                lng: d.business.locations[0].lon,
                name: d.title,
                body: d.business.name,
                click: {
                    on: function() {
                        filterDealsById(d.id);
                    },
                    off: function() {
                        filterDealsById();
                    }
                }
            });
        });
    }, updateGoogleRestaurants = function(googleRestaurants) {
        $scope.notFound = !1, "undefined" != typeof googleRestaurants && angular.forEach(googleRestaurants, function(place, i) {
            place.service = "google", place.hide = "undefined" == typeof place.hide ? !1 : place.hide, 
            place.inPlan = !1;
            var dList = plan.getRestaurants();
            if ("undefined" != typeof dList && "undefined" != typeof dList[0]) for (var i = 0; i < dList.length; i++) {
                var r = dList[i];
                "google" === r.restaurant.service && r.restaurant.id == place.id && (place._id = r._id, 
                place.inPlan = !0);
            }
            googleMap.hasMarker(place.geometry.location.lat(), place.geometry.location.lng()) || mapMarker.create(googleMap, {
                icon: "/images/icons/map-icons/entertainment/restaurant.png",
                position: place.geometry.location,
                name: place.name,
                body: place.vicinity
            });
        });
    };
    $scope.$on("restaurants-changed", function() {
        $timeout(function() {
            return updateDeals($scope.deals);
        }), $timeout(function() {
            return updateGoogleRestaurants($scope.googleRestaurants);
        });
    }), $scope.$watch("deals", function(deals) {
        deals && $timeout(function() {
            return updateDeals(deals);
        });
    }), $scope.$watch("googleRestaurants", function(googleRestaurants) {
        googleRestaurants && $timeout(function() {
            return updateGoogleRestaurants(googleRestaurants);
        });
    }), $scope.$watch("addonsFetched", function(n) {
        n && n > 0 && ($scope.addonsFetched = 0, overlay.loading(!1), overlay.hide());
    });
    var initMap = function(p) {
        var lat = p.venue.data.geocode.geometry.location.lat, lng = p.venue.data.geocode.geometry.location.lng;
        $(".addons-list-col").css("height", $($window).height() - 111), mapVenue.create(googleMap, {
            lat: lat,
            lng: lng,
            name: p.event.eventVenue,
            street: p.venue.data.Street1,
            city: p.event.eventCity,
            state: p.event.eventState
        }), wembliRestaurants.fetchDeals({
            lat: lat,
            lng: lng
        }, function(err, r) {
            $timeout(function() {
                $scope.$apply(function() {
                    $scope.deals = r, $scope.addonsFetched++;
                });
            });
        });
    }, addRestaurant = function(r) {
        var payment = {};
        "yipit" !== r.service && (payment.receipt = {
            "not-available": !0
        }), wembliRpc.fetch("plan.addRestaurant", {
            service: r.service,
            eventId: plan.get().event.eventId,
            restaurant: r,
            total: 0,
            payment: JSON.stringify(payment)
        }, function(err, result) {
            if (console.log("added restaurant:"), console.log(result), r._id = result.restaurant._id, 
            r.inPlan = !0, $scope.currentDeal = r, "split-first" === $scope.plan.preferences.payment) $scope.restaurantConfirm = !0, 
            overlay.show(); else {
                $timeout(function() {
                    $rootScope.$apply(function() {
                        $scope.buyDealOffsite = !0, overlay.show();
                    });
                }, 1500);
            }
        });
    };
    $scope.addDeal = function(idx) {
        var deal = $scope.deals[idx];
        console.log(deal), delete deal.$$hashKey, addRestaurant(deal);
    }, $scope.addGoogleRestaurant = function(idx) {
        var parking = $scope.googleParking[idx];
        delete parking.$$hashKey, googlePlaces.getDetails(parking.reference, function(place, status) {
            status == google.maps.places.PlacesServiceStatus.OK && $scope.$apply(function() {
                $scope.parkingDetails = place, addParking(parking);
            });
        });
    }, $scope.removeDeal = function() {
        var dealId = $scope.currentDeal._id;
        return dealId ? void plan.removeRestaurant({
            restaurantId: dealId
        }, function(err, results) {
            $scope.currentDeal && delete $scope.currentDeal, $scope.buyDealOffsite && ($scope.buyDealOffsite = !1, 
            overlay.hide()), $scope.restaurantConfirm && ($scope.restaurantConfirm = !1, overlay.hide()), 
            plan.setRestaurants(results.restaurant), $rootScope.$broadcast("restaurants-changed");
        }) : ($scope.restaurantConfirm = !1, $scope.buyDealOffsite = !1, void overlay.hide());
    }, $scope.boughtDeal = function() {
        return "undefined" == typeof $scope.deal ? void ($window.location.href = $scope.nextLink) : void plan.addRestaurantReceipt({
            restaurantId: $scope.currentDeal._id,
            service: $scope.currentDeal.service,
            receipt: {
                qty: $scope.currentDeal.selectedQty,
                amountPaid: $scope.currentDeal.amountPaid
            }
        }, function() {
            googleAnalytics.trackEvent("Plan", "boughtDeal", $scope.plan.event.eventName, "", function() {
                $window.location.href = $scope.nextLink;
            });
        });
    }, $rootScope.$on("overlay-clicked", function() {
        $scope.removeDeal($scope.currentDeal._id);
    }), plan.get(function(p) {
        if ($scope.context = plan.getContext() || "visitor", $scope.backToPlan = !1, null !== p.organizer.rsvp.decision && ($scope.backToPlan = !0), 
        $scope.nextLink = $scope.backToPlan ? "/plan" : "/event-options/" + p.event.eventId + "/" + p.event.eventName, 
        $scope.nextText = $scope.backToPlan ? "Ok, Back To Plan Dashboard" : "Continue To Plan Preferences", 
        "friend" === $scope.context && ($scope.backToPlan = !0), googleMap.isDrawn()) initMap(p); else var dereg = $rootScope.$on("google-map-drawn", function() {
            initMap(p), dereg();
        });
    });
} ]).controller("ParkingCtrl", [ "$rootScope", "$scope", "$timeout", "plan", "wembliParking", "wembliRpc", "googleMap", "googlePlaces", "mapVenue", "mapMarker", "mapInfoWindowContent", "overlay", "$location", "$window", "googleAnalytics", "header", function($rootScope, $scope, $timeout, plan, wembliParking, wembliRpc, googleMap, googlePlaces, mapVenue, mapMarker, mapInfoWindowContent, overlay, $location, $window, googleAnalytics, header) {
    header.fixed(), googleMap.init(), $scope.currentPath = $location.path(), $scope.parkingFetched = 0, 
    $scope.notFound = !0, $scope.filteredList = !1, $scope.determineRange = function(price) {
        var i = parseFloat(price);
        return 20 >= i ? "$" : i > 20 && 50 >= i ? "$$" : i > 50 ? "$$$" : void 0;
    }, $scope.determineDistance = function(feet) {
        return parseFloat(feet / 5280).toFixed(2);
    };
    var filterNone = function() {
        $timeout(function() {
            $scope.$apply(function() {
                for (var i = 0; i < $scope.googleParking.length; i++) $scope.googleParking[i].hide = !1;
                for (var i = 0; i < $scope.parkingReservations.parking_listings.length; i++) $scope.parkingReservations.parking_listings[i].hide = !1;
                $scope.filteredList = !1;
            });
        });
    };
    $scope.filterNone = filterNone;
    var filterGoogleParkingById = function(id) {
        return "undefined" == typeof id ? filterNone() : void $scope.$apply(function() {
            for (var i = 0; i < $scope.googleParking.length; i++) $scope.googleParking[i].hide = $scope.googleParking[i].id != id;
            for (var i = 0; i < $scope.parkingReservations.parking_listings.length; i++) $scope.parkingReservations.parking_listings[i].hide = !0;
            $scope.filteredList = !0;
        });
    }, filterParkingReservationsById = function(id) {
        return "undefined" == typeof id ? filterNone() : void $scope.$apply(function() {
            for (var i = 0; i < $scope.parkingReservations.parking_listings.length; i++) $scope.parkingReservations.parking_listings[i].hide = $scope.parkingReservations.parking_listings[i].listing_id != id;
            for (var i = 0; i < $scope.googleParking.length; i++) $scope.googleParking[i].hide = !0;
            $scope.filteredList = !0;
        });
    }, updateParkingReservations = function(parkingReservations) {
        $scope.notFound = !1, "undefined" != typeof parkingReservations && angular.forEach(parkingReservations.parking_listings, function(v, i) {
            v.service = "pw", v.hide = "undefined" == typeof v.hide ? !1 : v.hide, v.parkingInPlan = !1;
            var pList = plan.getParking();
            if ("undefined" != typeof pList && "undefined" != typeof pList[0]) for (var i = 0; i < pList.length; i++) {
                var p = pList[i];
                "pw" === p.parking.service && p.parking.listing_id == v.listing_id && (v._id = p._id, 
                v.purchased = p.purchased, v.parkingInPlan = !0);
            }
            googleMap.hasMarker(v.lat, v.lng) || mapMarker.create(googleMap, {
                icon: "/images/icons/map-icons/transportation/parkinggarage.png",
                lat: v.lat,
                lng: v.lng,
                name: v.location_name,
                body: v.address + ", " + v.city,
                click: {
                    on: function() {
                        filterParkingReservationsById(v.listing_id);
                    },
                    off: function() {
                        filterParkingReservationsById();
                    }
                }
            });
        });
    }, updateGoogleParking = function(googleParking) {
        $scope.notFound = !1, "undefined" != typeof googleParking && angular.forEach(googleParking, function(place, i) {
            place.service = "google", place.hide = "undefined" == typeof place.hide ? !1 : place.hide, 
            place.parkingInPlan = !1;
            var pList = plan.getParking();
            if ("undefined" != typeof pList && "undefined" != typeof pList[0]) for (var i = 0; i < pList.length; i++) {
                var p = pList[i];
                "google" === p.parking.service && p.parking.id == place.id && (place._id = p._id, 
                place.parkingInPlan = !0);
            }
            googleMap.hasMarker(place.geometry.location.lat(), place.geometry.location.lng()) || mapMarker.create(googleMap, {
                icon: "/images/icons/map-icons/transportation/parkinggarage.png",
                position: place.geometry.location,
                name: place.name,
                body: place.vicinity,
                click: {
                    on: function() {
                        filterGoogleParkingById(place.id);
                    },
                    off: function() {
                        filterGoogleParkingById();
                    }
                }
            });
        });
    };
    $scope.$on("parking-changed", function() {
        $timeout(function() {
            return updateParkingReservations($scope.parkingReservations);
        }), $timeout(function() {
            return updateGoogleParking($scope.googleParking);
        });
    }), $scope.$watch("parkingReservations", function(parkingReservations) {
        parkingReservations && $timeout(function() {
            return updateParkingReservations(parkingReservations);
        });
    }), $scope.$watch("googleParking", function(googleParking) {
        googleParking && $timeout(function() {
            return updateGoogleParking(googleParking);
        });
    }), $scope.$watch("parkingFetched", function(n) {
        n && n > 1 && ($scope.parkingFetched = 0, overlay.loading(!1), overlay.hide());
    });
    var initMap = function(p) {
        var lat = p.venue.data.geocode.geometry.location.lat, lng = p.venue.data.geocode.geometry.location.lng;
        $("#parking-list > div").css("height", $($window).height() - 111), mapVenue.create(googleMap, {
            lat: lat,
            lng: lng,
            name: p.event.eventVenue,
            street: p.venue.data.Street1,
            city: p.event.eventCity,
            state: p.event.eventState
        }), wembliParking.fetchGoogleParking({
            lat: lat,
            lng: lng
        }, function(err, p) {
            $scope.$apply(function() {
                $scope.googleParking = p, $scope.parkingFetched++;
            });
        }), wembliParking.fetchParkingReservations({
            lat: lat,
            lng: lng
        }, function(err, p) {
            $timeout(function() {
                $scope.$apply(function() {
                    $scope.parkingReservations = p, $scope.parkingFetched++;
                });
            });
        });
    }, addParking = function(parking) {
        var payment = {};
        "pw" !== parking.service && (payment.receipt = {
            "not-available": !0
        }), wembliRpc.fetch("plan.addParking", {
            service: parking.service,
            eventId: plan.get().event.eventId,
            parking: parking,
            total: 0,
            payment: JSON.stringify(payment)
        }, function(err, result) {
            if (parking._id = result.parking._id, parking.parkingInPlan = !0, $scope.currentParking = parking, 
            console.log("parking is now current: "), console.log($scope.currentParking), "split-first" === $scope.plan.preferences.payment) $scope.parkingConfirm = !0, 
            overlay.show(); else {
                $timeout(function() {
                    $rootScope.$apply(function() {
                        $scope.buyParkingOffsite = !0, overlay.show();
                    });
                }, 1500);
            }
        });
    };
    $scope.addParkingReservations = function(idx) {
        var parking = $scope.parkingReservations.parking_listings[idx];
        console.log("add parking res: "), console.log(parking), delete parking.$$hashKey, 
        addParking(parking);
    }, $scope.addGoogleParking = function(idx) {
        var parking = $scope.googleParking[idx];
        delete parking.$$hashKey, googlePlaces.getDetails(parking.reference, function(place, status) {
            status == google.maps.places.PlacesServiceStatus.OK && $scope.$apply(function() {
                $scope.parkingDetails = place, addParking(parking);
            });
        });
    }, $scope.removeParking = function() {
        var parkingId = $scope.currentParking._id;
        return parkingId ? void plan.removeParking({
            parkingId: parkingId
        }, function(err, results) {
            $scope.currentParking && delete $scope.currentParking, $scope.parkingDetails && delete $scope.parkingDetails, 
            $scope.buyParkingOffsite && ($scope.buyParkingOffsite = !1, overlay.hide()), $scope.parkingConfirm && ($scope.parkingConfirm = !1, 
            overlay.hide()), plan.setParking(results.parking), $rootScope.$broadcast("parking-changed", {
                parking: results.parking
            });
        }) : ($scope.parkingConfirm = !1, $scope.buyParkingOffsite = !1, void overlay.hide());
    }, $scope.boughtParking = function() {
        return "undefined" == typeof $scope.currentParking ? void ($window.location.href = $scope.nextLink) : void plan.addParkingReceipt({
            parkingId: $scope.currentParking._id,
            service: $scope.currentParking.service,
            receipt: {
                qty: $scope.currentParking.selectedQty,
                amountPaid: $scope.currentParking.amountPaid
            }
        }, function() {
            googleAnalytics.trackEvent("Plan", "boughtParking", $scope.plan.event.eventName, "", function() {
                $window.location.href = $scope.nextLink;
            });
        });
    }, $rootScope.$on("overlay-clicked", function() {
        $scope.removeParking($scope.currentParking._id);
    }), plan.get(function(p) {
        if ($scope.context = plan.getContext() || "visitor", $scope.backToPlan = !1, null !== p.organizer.rsvp.decision && ($scope.backToPlan = !0), 
        $scope.nextLink = $scope.backToPlan ? "/plan" : "/event-options/" + p.event.eventId + "/" + p.event.eventName, 
        $scope.nextText = $scope.backToPlan ? "Ok, Back To Plan Dashboard" : "Continue To Plan Preferences", 
        "friend" === $scope.context && ($scope.backToPlan = !0), googleMap.isDrawn()) initMap(p); else var dereg = $rootScope.$on("google-map-drawn", function() {
            initMap(p), dereg();
        });
    });
} ]), angular.module("wembliApp.directives.addOns", []).directive("addonsMap", [ "$rootScope", "googleMap", function($rootScope, googleMap) {
    return {
        restrict: "C",
        cache: !1,
        replace: !0,
        compile: function() {
            return function(scope, element, attr) {
                var mapTypeId = attr.mapTypeId ? google.maps.MapTypeId[attr.mapTypeId] : google.maps.MapTypeId.ROADMAP, mapOpts = {
                    mapTypeId: mapTypeId
                };
                mapOpts.center = new google.maps.LatLng(attr.lat, attr.lng), attr.zoom && (mapOpts.zoom = parseInt(attr.zoom)), 
                attr.draggable && (mapOpts.draggable = attr.draggable), googleMap.draw(element, mapOpts);
            };
        }
    };
} ]), angular.module("wembliApp.services.addOns", []).factory("wembliParking", [ "wembliRpc", "googlePlaces", function(wembliRpc, googlePlaces) {
    var self = this;
    return self.googleParking = null, self.parkingReservations = null, {
        getGoogleParking: function() {
            return self.googleParking;
        },
        getParkingReservations: function() {
            return self.parkingReservations;
        },
        setGoogleParking: function(p) {
            self.googleParking = p;
        },
        setParkingReservations: function(p) {
            self.parkingReservations = p;
        },
        fetchGoogleParking: function(args, callback) {
            args.radius = args.radius || 5e3, googlePlaces.getParking(args.lat, args.lng, args.radius, function(results, status) {
                status == google.maps.places.PlacesServiceStatus.OK && (self.googleParking = results), 
                callback(null, self.googleParking);
            });
        },
        fetchParkingReservations: function(args, callback) {
            wembliRpc.fetch("event.getParking", {
                lat: args.lat,
                lng: args.lng,
                radius: args.radius
            }, function(err, result) {
                return err ? void alert("error happened - contact help@wembli.com") : ("undefined" != typeof result.parking && (self.parkingReservations = result.parking), 
                void callback(null, self.parkingReservations));
            });
        }
    };
} ]).factory("wembliRestaurants", [ "wembliRpc", "googlePlaces", function(wembliRpc, googlePlaces) {
    var self = this;
    return self.googleRestaurants = null, self.deals = null, {
        getGoogleRestaurants: function() {
            return self.googleRestaurants;
        },
        getDeals: function() {
            return self.deals;
        },
        setGoogleRestaurants: function(r) {
            self.googleRestaurants = r;
        },
        setDeals: function(r) {
            self.deals = r;
        },
        fetchGoogleRestaurants: function(args, callback) {
            args.radius = args.radius || 5e3, googlePlaces.getRestaurants(args.lat, args.lng, args.radius, function(results, status) {
                status == google.maps.places.PlacesServiceStatus.OK && (self.googleRestaurants = results), 
                callback(null, self.googleRestaurants);
            });
        },
        fetchDeals: function(args, callback) {
            wembliRpc.fetch("event.getRestaurantDeals", {
                lat: args.lat,
                lng: args.lng,
                radius: args.radius
            }, function(err, result) {
                return err ? void alert("error happened - contact help@wembli.com") : ("undefined" != typeof result.deals && (self.deals = result.deals), 
                void callback(null, self.deals));
            });
        }
    };
} ]).factory("wembliHotels", [ "wembliRpc", "googlePlaces", function(wembliRpc, googlePlaces) {
    var self = this;
    return self.googleHotels = null, self.expediaHotels = null, {
        getGoogleHotels: function() {
            return self.googleHotels;
        },
        getExpediaHotels: function() {
            return self.expediaHotels;
        },
        setGoogleHotels: function(h) {
            self.googleHotels = h;
        },
        setExpediaHotels: function(p) {
            self.expediaHotels = p;
        },
        fetchGoogleHotels: function(args, callback) {
            args.radius = args.radius || 5e3, googlePlaces.getHotels(args.lat, args.lng, args.radius, function(results, status) {
                status == google.maps.places.PlacesServiceStatus.OK && (self.googleHotels = results), 
                callback(null, self.googleHotels);
            });
        },
        fetchExpediaHotels: function(args, callback) {
            wembliRpc.fetch("event.getHotels", {
                lat: args.lat,
                lng: args.lng,
                radius: args.radius
            }, function(err, result) {
                return err ? void alert("error happened - contact help@wembli.com") : ("undefined" != typeof result.hotels && (self.expediaHotels = result.hotels), 
                void callback(null, self.expediaHotels));
            });
        }
    };
} ]), angular.module("wembliApp.services.google", []).factory("googleMap", [ "$rootScope", function($rootScope) {
    function floatEqual(f1, f2) {
        return Math.abs(f1 - f2) < 1e-6;
    }
    var self = this;
    self._markers = [], self._infoWindows = [], self._map = null, self.drawn = !1, self.dragging = !1, 
    self.zoom = 14, self.center = new google.maps.LatLng(32.722439302963, -117.1645658798);
    var mapDefaults = {
        center: self.center,
        zoom: self.zoom,
        draggable: !0,
        mapTypeId: google.maps.MapTypeId.ROADMAP
    };
    return {
        init: function() {
            self._markers = [], self._infoWindows = [], self._map = null, self.drawn = !1, self.dragging = !1, 
            self.zoom = 14, self.center = new google.maps.LatLng(32.722439302963, -117.1645658798);
        },
        draw: function(element, options, handlers) {
            var o = angular.extend(mapDefaults, options), lat = o.center.lat(), lng = o.center.lng();
            o.center = new google.maps.LatLng(lat, lng), self._map = new google.maps.Map(element[0], o), 
            google.maps.event.addListener(self._map, "dragstart", function() {
                self.dragging = !0;
            }), google.maps.event.addListener(self._map, "idle", function() {
                self.dragging = !1;
            }), google.maps.event.addListener(self._map, "drag", function() {
                self.dragging = !0;
            }), google.maps.event.addListener(self._map, "zoom_changed", function() {
                self.zoom = self._map.getZoom(), self.center = self._map.getCenter();
            }), google.maps.event.addListener(self._map, "center_changed", function() {
                self.center = self._map.getCenter();
            }), "undefined" != typeof handlers && handlers.length && angular.forEach(handlers, function(h) {
                google.maps.event.addListener(self._map, h.on, h.handler);
            }), self.drawn = !0, $rootScope.$broadcast("google-map-drawn");
        },
        isDrawn: function(val) {
            return "undefined" != typeof val && (self.drawn = val), self.drawn;
        },
        getMap: function() {
            return self._map;
        },
        addMarker: function(marker) {
            return self._markers.unshift(marker), marker;
        },
        findMarker: function(lat, lng) {
            for (var i = 0; i < self._markers.length; i++) {
                var pos = self._markers[i].getPosition();
                if (floatEqual(pos.lat(), lat) && floatEqual(pos.lng(), lng)) return self._markers[i];
            }
            return null;
        },
        hasMarker: function(lat, lng) {
            return null !== this.findMarker(lat, lng);
        },
        removeMarker: function() {},
        addInfoWindow: function(infoWindow, marker) {
            var win = {
                infoWindow: infoWindow,
                open: !1
            };
            if ("undefined" != typeof infoWindow && "undefined" != typeof marker && "undefined" != typeof infoWindow.getPosition() && "undefined" != typeof marker.getPosition()) return "undefined" != typeof marker && "undefined" != typeof marker.getPosition() ? (win.lat = marker.getPosition().lat(), 
            win.lng = marker.getPosition().lng()) : (win.lat = infoWindow.getPosition().lat(), 
            win.lng = infoWindow.getPosition().lng()), self._infoWindows.unshift(win), win;
        },
        _findInfoWindow: function(lat, lng) {
            for (var i = 0; i < self._infoWindows.length; i++) {
                var winLat = self._infoWindows[i].lat, winLng = self._infoWindows[i].lng;
                if (floatEqual(winLat, lat) && floatEqual(winLng, lng)) return self._infoWindows[i];
            }
            return null;
        },
        findInfoWindow: function(lat, lng) {
            var win = this._findInfoWindow(lat, lng);
            return win ? win.infoWindow : null;
        },
        isInfoWindowOpen: function(marker) {
            var lat = marker.getPosition().lat(), lng = marker.getPosition().lng(), win = this._findInfoWindow(lat, lng);
            return win ? win.open : !1;
        },
        closeInfoWindow: function(marker) {
            var lat = marker.getPosition().lat(), lng = marker.getPosition().lng(), win = this._findInfoWindow(lat, lng);
            win.open = !1, win.infoWindow.close();
        },
        openInfoWindow: function(marker) {
            var lat = marker.getPosition().lat(), lng = marker.getPosition().lng(), win = this._findInfoWindow(lat, lng);
            win && (win.open = !0, win.infoWindow.open(self._map, marker));
        },
        resize: function() {
            google.maps.event.trigger(self._map, "resize"), $rootScope.$broadcast("google-map-resize");
        }
    };
} ]).factory("googlePlaces", [ "googleMap", function(googleMap) {
    return {
        getParking: function(lat, lng, radius, callback) {
            var request = {
                location: new google.maps.LatLng(lat, lng),
                radius: radius,
                types: [ "parking" ]
            }, service = new google.maps.places.PlacesService(googleMap.getMap());
            service.nearbySearch(request, callback);
        },
        getRestaurants: function(lat, lng, radius, callback) {
            var request = {
                location: new google.maps.LatLng(lat, lng),
                radius: radius,
                types: [ "restaurant" ]
            }, service = new google.maps.places.PlacesService(googleMap.getMap());
            service.nearbySearch(request, callback);
        },
        getHotels: function(lat, lng, radius, callback) {
            var request = {
                location: new google.maps.LatLng(lat, lng),
                radius: radius,
                types: [ "lodging" ]
            }, service = new google.maps.places.PlacesService(googleMap.getMap());
            service.nearbySearch(request, callback);
        },
        getDetails: function(reference, callback) {
            var request = {
                reference: reference
            }, service = new google.maps.places.PlacesService(googleMap.getMap());
            service.getDetails(request, callback);
        }
    };
} ]).factory("mapMarker", [ "mapInfoWindowContent", function(mapInfoWindowContent) {
    return {
        create: function(googleMap, args) {
            var position, markerArgs = {
                map: googleMap.getMap()
            };
            "undefined" != typeof args.position && (position = args.position), "undefined" != typeof args.lat && "undefined" != typeof args.lng && (position = new google.maps.LatLng(args.lat, args.lng)), 
            markerArgs.position = position;
            var marker = new google.maps.Marker(markerArgs);
            marker.setIcon(args.icon), marker.setAnimation(google.maps.Animation.DROP);
            var win = new google.maps.InfoWindow({
                position: position,
                content: mapInfoWindowContent.create({
                    header: args.name,
                    body: args.body
                }),
                pixelOffset: new google.maps.Size(10, 0)
            });
            google.maps.event.addListener(marker, "click", function() {
                googleMap.isInfoWindowOpen(marker) ? googleMap.closeInfoWindow(marker) : googleMap.openInfoWindow(marker);
            }), "undefined" != typeof args.click && google.maps.event.addListener(marker, "click", function() {
                googleMap.isInfoWindowOpen(marker) ? args.click.on() : args.click.off();
            }), googleMap.addMarker(marker), googleMap.addInfoWindow(win, marker);
        }
    };
} ]).factory("mapVenue", [ "mapInfoWindowContent", function(mapInfoWindowContent) {
    return {
        create: function(googleMap, args) {
            var position;
            "undefined" != typeof args.position && (position = args.position), "undefined" != typeof args.lat && "undefined" != typeof args.lng && (position = new google.maps.LatLng(args.lat, args.lng));
            var marker = new google.maps.Marker({
                map: googleMap.getMap(),
                position: position
            });
            marker.setIcon("/images/icons/map-icons/sports/stadium.png"), marker.setAnimation(google.maps.Animation.DROP);
            var win = new google.maps.InfoWindow({
                position: position,
                content: mapInfoWindowContent.create({
                    header: args.name,
                    body: args.street + ", " + args.city + ", " + args.state
                }),
                pixelOffset: new google.maps.Size(10, 0)
            });
            google.maps.event.addListener(marker, "click", function() {
                googleMap.isInfoWindowOpen(marker) ? googleMap.closeInfoWindow(marker) : googleMap.openInfoWindow(marker);
            }), googleMap.addMarker(marker), googleMap.addInfoWindow(win, marker), googleMap.openInfoWindow(marker);
        }
    };
} ]).factory("mapInfoWindowContent", [ function() {
    return {
        create: function(args) {
            var html = '<div class="info-window">';
            return html += '<h3 class="info-window-header">' + args.header + "</h3>", html += '<div class="info-window-body">' + args.body + "</div>", 
            html += "</div>";
        }
    };
} ]);