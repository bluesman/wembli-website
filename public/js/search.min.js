/*! wembli-website 2014-06-21 */
"use strict";

!function($) {
    var VERSION = "0.9.3", utils = {
        isMsie: function() {
            var match = /(msie) ([\w.]+)/i.exec(navigator.userAgent);
            return match ? parseInt(match[2], 10) : !1;
        },
        isBlankString: function(str) {
            return !str || /^\s*$/.test(str);
        },
        escapeRegExChars: function(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        },
        isString: function(obj) {
            return "string" == typeof obj;
        },
        isNumber: function(obj) {
            return "number" == typeof obj;
        },
        isArray: $.isArray,
        isFunction: $.isFunction,
        isObject: $.isPlainObject,
        isUndefined: function(obj) {
            return "undefined" == typeof obj;
        },
        bind: $.proxy,
        bindAll: function(obj) {
            var val;
            for (var key in obj) $.isFunction(val = obj[key]) && (obj[key] = $.proxy(val, obj));
        },
        indexOf: function(haystack, needle) {
            for (var i = 0; i < haystack.length; i++) if (haystack[i] === needle) return i;
            return -1;
        },
        each: $.each,
        map: $.map,
        filter: $.grep,
        every: function(obj, test) {
            var result = !0;
            return obj ? ($.each(obj, function(key, val) {
                return (result = test.call(null, val, key, obj)) ? void 0 : !1;
            }), !!result) : result;
        },
        some: function(obj, test) {
            var result = !1;
            return obj ? ($.each(obj, function(key, val) {
                return (result = test.call(null, val, key, obj)) ? !1 : void 0;
            }), !!result) : result;
        },
        mixin: $.extend,
        getUniqueId: function() {
            var counter = 0;
            return function() {
                return counter++;
            };
        }(),
        defer: function(fn) {
            setTimeout(fn, 0);
        },
        debounce: function(func, wait, immediate) {
            var timeout, result;
            return function() {
                var later, callNow, context = this, args = arguments;
                return later = function() {
                    timeout = null, immediate || (result = func.apply(context, args));
                }, callNow = immediate && !timeout, clearTimeout(timeout), timeout = setTimeout(later, wait), 
                callNow && (result = func.apply(context, args)), result;
            };
        },
        throttle: function(func, wait) {
            var context, args, timeout, result, previous, later;
            return previous = 0, later = function() {
                previous = new Date(), timeout = null, result = func.apply(context, args);
            }, function() {
                var now = new Date(), remaining = wait - (now - previous);
                return context = this, args = arguments, 0 >= remaining ? (clearTimeout(timeout), 
                timeout = null, previous = now, result = func.apply(context, args)) : timeout || (timeout = setTimeout(later, remaining)), 
                result;
            };
        },
        tokenizeQuery: function(str) {
            return $.trim(str).toLowerCase().split(/[\s]+/);
        },
        tokenizeText: function(str) {
            return $.trim(str).toLowerCase().split(/[\s\-_]+/);
        },
        getProtocol: function() {
            return location.protocol;
        },
        noop: function() {}
    }, EventTarget = function() {
        var eventSplitter = /\s+/;
        return {
            on: function(events, callback) {
                var event;
                if (!callback) return this;
                for (this._callbacks = this._callbacks || {}, events = events.split(eventSplitter); event = events.shift(); ) this._callbacks[event] = this._callbacks[event] || [], 
                this._callbacks[event].push(callback);
                return this;
            },
            trigger: function(events, data) {
                var event, callbacks;
                if (!this._callbacks) return this;
                for (events = events.split(eventSplitter); event = events.shift(); ) if (callbacks = this._callbacks[event]) for (var i = 0; i < callbacks.length; i += 1) callbacks[i].call(this, {
                    type: event,
                    data: data
                });
                return this;
            }
        };
    }(), EventBus = function() {
        function EventBus(o) {
            o && o.el || $.error("EventBus initialized without el"), this.$el = $(o.el);
        }
        var namespace = "typeahead:";
        return utils.mixin(EventBus.prototype, {
            trigger: function(type) {
                var args = [].slice.call(arguments, 1);
                this.$el.trigger(namespace + type, args);
            }
        }), EventBus;
    }(), PersistentStorage = function() {
        function PersistentStorage(namespace) {
            this.prefix = [ "__", namespace, "__" ].join(""), this.ttlKey = "__ttl__", this.keyMatcher = new RegExp("^" + this.prefix);
        }
        function now() {
            return new Date().getTime();
        }
        function encode(val) {
            return JSON.stringify(utils.isUndefined(val) ? null : val);
        }
        function decode(val) {
            return JSON.parse(val);
        }
        var ls, methods;
        try {
            ls = window.localStorage, ls.setItem("~~~", "!"), ls.removeItem("~~~");
        } catch (err) {
            ls = null;
        }
        return methods = ls && window.JSON ? {
            _prefix: function(key) {
                return this.prefix + key;
            },
            _ttlKey: function(key) {
                return this._prefix(key) + this.ttlKey;
            },
            get: function(key) {
                return this.isExpired(key) && this.remove(key), decode(ls.getItem(this._prefix(key)));
            },
            set: function(key, val, ttl) {
                return utils.isNumber(ttl) ? ls.setItem(this._ttlKey(key), encode(now() + ttl)) : ls.removeItem(this._ttlKey(key)), 
                ls.setItem(this._prefix(key), encode(val));
            },
            remove: function(key) {
                return ls.removeItem(this._ttlKey(key)), ls.removeItem(this._prefix(key)), this;
            },
            clear: function() {
                var i, key, keys = [], len = ls.length;
                for (i = 0; len > i; i++) (key = ls.key(i)).match(this.keyMatcher) && keys.push(key.replace(this.keyMatcher, ""));
                for (i = keys.length; i--; ) this.remove(keys[i]);
                return this;
            },
            isExpired: function(key) {
                var ttl = decode(ls.getItem(this._ttlKey(key)));
                return utils.isNumber(ttl) && now() > ttl ? !0 : !1;
            }
        } : {
            get: utils.noop,
            set: utils.noop,
            remove: utils.noop,
            clear: utils.noop,
            isExpired: utils.noop
        }, utils.mixin(PersistentStorage.prototype, methods), PersistentStorage;
    }(), RequestCache = function() {
        function RequestCache(o) {
            utils.bindAll(this), o = o || {}, this.sizeLimit = o.sizeLimit || 10, this.cache = {}, 
            this.cachedKeysByAge = [];
        }
        return utils.mixin(RequestCache.prototype, {
            get: function(url) {
                return this.cache[url];
            },
            set: function(url, resp) {
                var requestToEvict;
                this.cachedKeysByAge.length === this.sizeLimit && (requestToEvict = this.cachedKeysByAge.shift(), 
                delete this.cache[requestToEvict]), this.cache[url] = resp, this.cachedKeysByAge.push(url);
            }
        }), RequestCache;
    }(), Transport = function() {
        function Transport(o) {
            utils.bindAll(this), o = utils.isString(o) ? {
                url: o
            } : o, requestCache = requestCache || new RequestCache(), maxPendingRequests = utils.isNumber(o.maxParallelRequests) ? o.maxParallelRequests : maxPendingRequests || 6, 
            this.url = o.url, this.wildcard = o.wildcard || "%QUERY", this.filter = o.filter, 
            this.replace = o.replace, this.ajaxSettings = {
                type: "get",
                cache: o.cache,
                timeout: o.timeout,
                dataType: o.dataType || "json",
                beforeSend: o.beforeSend
            }, this._get = (/^throttle$/i.test(o.rateLimitFn) ? utils.throttle : utils.debounce)(this._get, o.rateLimitWait || 300);
        }
        function incrementPendingRequests() {
            pendingRequestsCount++;
        }
        function decrementPendingRequests() {
            pendingRequestsCount--;
        }
        function belowPendingRequestsThreshold() {
            return maxPendingRequests > pendingRequestsCount;
        }
        var maxPendingRequests, requestCache, pendingRequestsCount = 0, pendingRequests = {};
        return utils.mixin(Transport.prototype, {
            _get: function(url, cb) {
                function done(resp) {
                    var data = that.filter ? that.filter(resp) : resp;
                    cb && cb(data), requestCache.set(url, resp);
                }
                var that = this;
                belowPendingRequestsThreshold() ? this._sendRequest(url).done(done) : this.onDeckRequestArgs = [].slice.call(arguments, 0);
            },
            _sendRequest: function(url) {
                function always() {
                    decrementPendingRequests(), pendingRequests[url] = null, that.onDeckRequestArgs && (that._get.apply(that, that.onDeckRequestArgs), 
                    that.onDeckRequestArgs = null);
                }
                var that = this, jqXhr = pendingRequests[url];
                return jqXhr || (incrementPendingRequests(), jqXhr = pendingRequests[url] = $.ajax(url, this.ajaxSettings).always(always)), 
                jqXhr;
            },
            get: function(query, cb) {
                var url, resp, that = this, encodedQuery = encodeURIComponent(query || "");
                return cb = cb || utils.noop, url = this.replace ? this.replace(this.url, encodedQuery) : this.url.replace(this.wildcard, encodedQuery), 
                (resp = requestCache.get(url)) ? utils.defer(function() {
                    cb(that.filter ? that.filter(resp) : resp);
                }) : this._get(url, cb), !!resp;
            }
        }), Transport;
    }(), Dataset = function() {
        function Dataset(o) {
            utils.bindAll(this), utils.isString(o.template) && !o.engine && $.error("no template engine specified"), 
            o.local || o.prefetch || o.remote || $.error("one of local, prefetch, or remote is required"), 
            this.name = o.name || utils.getUniqueId(), this.limit = o.limit || 5, this.minLength = o.minLength || 1, 
            this.header = o.header, this.footer = o.footer, this.valueKey = o.valueKey || "value", 
            this.template = compileTemplate(o.template, o.engine, this.valueKey), this.local = o.local, 
            this.prefetch = o.prefetch, this.remote = o.remote, this.itemHash = {}, this.adjacencyList = {}, 
            this.storage = o.name ? new PersistentStorage(o.name) : null;
        }
        function compileTemplate(template, engine, valueKey) {
            var renderFn, compiledTemplate;
            return utils.isFunction(template) ? renderFn = template : utils.isString(template) ? (compiledTemplate = engine.compile(template), 
            renderFn = utils.bind(compiledTemplate.render, compiledTemplate)) : renderFn = function(context) {
                return "<p>" + context[valueKey] + "</p>";
            }, renderFn;
        }
        var keys = {
            thumbprint: "thumbprint",
            protocol: "protocol",
            itemHash: "itemHash",
            adjacencyList: "adjacencyList"
        };
        return utils.mixin(Dataset.prototype, {
            _processLocalData: function(data) {
                this._mergeProcessedData(this._processData(data));
            },
            _loadPrefetchData: function(o) {
                function processPrefetchData(data) {
                    var filteredData = o.filter ? o.filter(data) : data, processedData = that._processData(filteredData), itemHash = processedData.itemHash, adjacencyList = processedData.adjacencyList;
                    that.storage && (that.storage.set(keys.itemHash, itemHash, o.ttl), that.storage.set(keys.adjacencyList, adjacencyList, o.ttl), 
                    that.storage.set(keys.thumbprint, thumbprint, o.ttl), that.storage.set(keys.protocol, utils.getProtocol(), o.ttl)), 
                    that._mergeProcessedData(processedData);
                }
                var storedThumbprint, storedProtocol, storedItemHash, storedAdjacencyList, isExpired, deferred, that = this, thumbprint = VERSION + (o.thumbprint || "");
                return this.storage && (storedThumbprint = this.storage.get(keys.thumbprint), storedProtocol = this.storage.get(keys.protocol), 
                storedItemHash = this.storage.get(keys.itemHash), storedAdjacencyList = this.storage.get(keys.adjacencyList)), 
                isExpired = storedThumbprint !== thumbprint || storedProtocol !== utils.getProtocol(), 
                o = utils.isString(o) ? {
                    url: o
                } : o, o.ttl = utils.isNumber(o.ttl) ? o.ttl : 864e5, storedItemHash && storedAdjacencyList && !isExpired ? (this._mergeProcessedData({
                    itemHash: storedItemHash,
                    adjacencyList: storedAdjacencyList
                }), deferred = $.Deferred().resolve()) : deferred = $.getJSON(o.url).done(processPrefetchData), 
                deferred;
            },
            _transformDatum: function(datum) {
                var value = utils.isString(datum) ? datum : datum[this.valueKey], tokens = datum.tokens || utils.tokenizeText(value), item = {
                    value: value,
                    tokens: tokens
                };
                return utils.isString(datum) ? (item.datum = {}, item.datum[this.valueKey] = datum) : item.datum = datum, 
                item.tokens = utils.filter(item.tokens, function(token) {
                    return !utils.isBlankString(token);
                }), item.tokens = utils.map(item.tokens, function(token) {
                    return token.toLowerCase();
                }), item;
            },
            _processData: function(data) {
                var that = this, itemHash = {}, adjacencyList = {};
                return utils.each(data, function(i, datum) {
                    var item = that._transformDatum(datum), id = utils.getUniqueId(item.value);
                    itemHash[id] = item, utils.each(item.tokens, function(i, token) {
                        var character = token.charAt(0), adjacency = adjacencyList[character] || (adjacencyList[character] = [ id ]);
                        !~utils.indexOf(adjacency, id) && adjacency.push(id);
                    });
                }), {
                    itemHash: itemHash,
                    adjacencyList: adjacencyList
                };
            },
            _mergeProcessedData: function(processedData) {
                var that = this;
                utils.mixin(this.itemHash, processedData.itemHash), utils.each(processedData.adjacencyList, function(character, adjacency) {
                    var masterAdjacency = that.adjacencyList[character];
                    that.adjacencyList[character] = masterAdjacency ? masterAdjacency.concat(adjacency) : adjacency;
                });
            },
            _getLocalSuggestions: function(terms) {
                var shortestList, that = this, firstChars = [], lists = [], suggestions = [];
                return utils.each(terms, function(i, term) {
                    var firstChar = term.charAt(0);
                    !~utils.indexOf(firstChars, firstChar) && firstChars.push(firstChar);
                }), utils.each(firstChars, function(i, firstChar) {
                    var list = that.adjacencyList[firstChar];
                    return list ? (lists.push(list), void ((!shortestList || list.length < shortestList.length) && (shortestList = list))) : !1;
                }), lists.length < firstChars.length ? [] : (utils.each(shortestList, function(i, id) {
                    var isCandidate, isMatch, item = that.itemHash[id];
                    isCandidate = utils.every(lists, function(list) {
                        return ~utils.indexOf(list, id);
                    }), isMatch = isCandidate && utils.every(terms, function(term) {
                        return utils.some(item.tokens, function(token) {
                            return 0 === token.indexOf(term);
                        });
                    }), isMatch && suggestions.push(item);
                }), suggestions);
            },
            initialize: function() {
                var deferred;
                return this.local && this._processLocalData(this.local), this.transport = this.remote ? new Transport(this.remote) : null, 
                deferred = this.prefetch ? this._loadPrefetchData(this.prefetch) : $.Deferred().resolve(), 
                this.local = this.prefetch = this.remote = null, this.initialize = function() {
                    return deferred;
                }, deferred;
            },
            getSuggestions: function(query, cb) {
                function processRemoteData(data) {
                    suggestions = suggestions.slice(0), utils.each(data, function(i, datum) {
                        var isDuplicate, item = that._transformDatum(datum);
                        return isDuplicate = utils.some(suggestions, function(suggestion) {
                            return item.value === suggestion.value;
                        }), !isDuplicate && suggestions.push(item), suggestions.length < that.limit;
                    }), cb && cb(suggestions);
                }
                var terms, suggestions, that = this, cacheHit = !1;
                query.length < this.minLength || (terms = utils.tokenizeQuery(query), suggestions = this._getLocalSuggestions(terms).slice(0, this.limit), 
                suggestions.length < this.limit && this.transport && (cacheHit = this.transport.get(query, processRemoteData)), 
                !cacheHit && cb && cb(suggestions));
            }
        }), Dataset;
    }(), InputView = function() {
        function InputView(o) {
            var that = this;
            utils.bindAll(this), this.specialKeyCodeMap = {
                9: "tab",
                27: "esc",
                37: "left",
                39: "right",
                13: "enter",
                38: "up",
                40: "down"
            }, this.$hint = $(o.hint), this.$input = $(o.input).on("blur.tt", this._handleBlur).on("focus.tt", this._handleFocus).on("keydown.tt", this._handleSpecialKeyEvent), 
            utils.isMsie() ? this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function($e) {
                that.specialKeyCodeMap[$e.which || $e.keyCode] || utils.defer(that._compareQueryToInputValue);
            }) : this.$input.on("input.tt", this._compareQueryToInputValue), this.query = this.$input.val(), 
            this.$overflowHelper = buildOverflowHelper(this.$input);
        }
        function buildOverflowHelper($input) {
            return $("<span></span>").css({
                position: "absolute",
                left: "-9999px",
                visibility: "hidden",
                whiteSpace: "nowrap",
                fontFamily: $input.css("font-family"),
                fontSize: $input.css("font-size"),
                fontStyle: $input.css("font-style"),
                fontVariant: $input.css("font-variant"),
                fontWeight: $input.css("font-weight"),
                wordSpacing: $input.css("word-spacing"),
                letterSpacing: $input.css("letter-spacing"),
                textIndent: $input.css("text-indent"),
                textRendering: $input.css("text-rendering"),
                textTransform: $input.css("text-transform")
            }).insertAfter($input);
        }
        function compareQueries(a, b) {
            return a = (a || "").replace(/^\s*/g, "").replace(/\s{2,}/g, " "), b = (b || "").replace(/^\s*/g, "").replace(/\s{2,}/g, " "), 
            a === b;
        }
        return utils.mixin(InputView.prototype, EventTarget, {
            _handleFocus: function() {
                this.trigger("focused");
            },
            _handleBlur: function() {
                this.trigger("blured");
            },
            _handleSpecialKeyEvent: function($e) {
                var keyName = this.specialKeyCodeMap[$e.which || $e.keyCode];
                keyName && this.trigger(keyName + "Keyed", $e);
            },
            _compareQueryToInputValue: function() {
                var inputValue = this.getInputValue(), isSameQuery = compareQueries(this.query, inputValue), isSameQueryExceptWhitespace = isSameQuery ? this.query.length !== inputValue.length : !1;
                isSameQueryExceptWhitespace ? this.trigger("whitespaceChanged", {
                    value: this.query
                }) : isSameQuery || this.trigger("queryChanged", {
                    value: this.query = inputValue
                });
            },
            destroy: function() {
                this.$hint.off(".tt"), this.$input.off(".tt"), this.$hint = this.$input = this.$overflowHelper = null;
            },
            focus: function() {
                this.$input.focus();
            },
            blur: function() {
                this.$input.blur();
            },
            getQuery: function() {
                return this.query;
            },
            setQuery: function(query) {
                this.query = query;
            },
            getInputValue: function() {
                return this.$input.val();
            },
            setInputValue: function(value, silent) {
                this.$input.val(value), !silent && this._compareQueryToInputValue();
            },
            getHintValue: function() {
                return this.$hint.val();
            },
            setHintValue: function(value) {
                this.$hint.val(value);
            },
            getLanguageDirection: function() {
                return (this.$input.css("direction") || "ltr").toLowerCase();
            },
            isOverflow: function() {
                return this.$overflowHelper.text(this.getInputValue()), this.$overflowHelper.width() > this.$input.width();
            },
            isCursorAtEnd: function() {
                var range, valueLength = this.$input.val().length, selectionStart = this.$input[0].selectionStart;
                return utils.isNumber(selectionStart) ? selectionStart === valueLength : document.selection ? (range = document.selection.createRange(), 
                range.moveStart("character", -valueLength), valueLength === range.text.length) : !0;
            }
        }), InputView;
    }(), DropdownView = function() {
        function DropdownView(o) {
            utils.bindAll(this), this.isOpen = !1, this.isEmpty = !0, this.isMouseOverDropdown = !1, 
            this.$menu = $(o.menu).on("mouseenter.tt", this._handleMouseenter).on("mouseleave.tt", this._handleMouseleave).on("click.tt", ".tt-suggestion", this._handleSelection).on("mouseover.tt", ".tt-suggestion", this._handleMouseover);
        }
        function extractSuggestion($el) {
            return $el.data("suggestion");
        }
        var html = {
            suggestionsList: '<span class="tt-suggestions"></span>'
        }, css = {
            suggestionsList: {
                display: "block"
            },
            suggestion: {
                whiteSpace: "nowrap",
                cursor: "pointer"
            },
            suggestionChild: {
                whiteSpace: "normal"
            }
        };
        return utils.mixin(DropdownView.prototype, EventTarget, {
            _handleMouseenter: function() {
                this.isMouseOverDropdown = !0;
            },
            _handleMouseleave: function() {
                this.isMouseOverDropdown = !1;
            },
            _handleMouseover: function($e) {
                var $suggestion = $($e.currentTarget);
                this._getSuggestions().removeClass("tt-is-under-cursor"), $suggestion.addClass("tt-is-under-cursor");
            },
            _handleSelection: function($e) {
                var $suggestion = $($e.currentTarget);
                this.trigger("suggestionSelected", extractSuggestion($suggestion));
            },
            _show: function() {
                this.$menu.css("display", "block");
            },
            _hide: function() {
                this.$menu.hide();
            },
            _moveCursor: function(increment) {
                var $suggestions, $cur, nextIndex, $underCursor;
                if (this.isVisible()) {
                    if ($suggestions = this._getSuggestions(), $cur = $suggestions.filter(".tt-is-under-cursor"), 
                    $cur.removeClass("tt-is-under-cursor"), nextIndex = $suggestions.index($cur) + increment, 
                    nextIndex = (nextIndex + 1) % ($suggestions.length + 1) - 1, -1 === nextIndex) return void this.trigger("cursorRemoved");
                    -1 > nextIndex && (nextIndex = $suggestions.length - 1), $underCursor = $suggestions.eq(nextIndex).addClass("tt-is-under-cursor"), 
                    this._ensureVisibility($underCursor), this.trigger("cursorMoved", extractSuggestion($underCursor));
                }
            },
            _getSuggestions: function() {
                return this.$menu.find(".tt-suggestions > .tt-suggestion");
            },
            _ensureVisibility: function($el) {
                var menuHeight = this.$menu.height() + parseInt(this.$menu.css("paddingTop"), 10) + parseInt(this.$menu.css("paddingBottom"), 10), menuScrollTop = this.$menu.scrollTop(), elTop = $el.position().top, elBottom = elTop + $el.outerHeight(!0);
                0 > elTop ? this.$menu.scrollTop(menuScrollTop + elTop) : elBottom > menuHeight && this.$menu.scrollTop(menuScrollTop + (elBottom - menuHeight));
            },
            destroy: function() {
                this.$menu.off(".tt"), this.$menu = null;
            },
            isVisible: function() {
                return this.isOpen && !this.isEmpty;
            },
            closeUnlessMouseIsOverDropdown: function() {
                this.isMouseOverDropdown || this.close();
            },
            close: function() {
                this.isOpen && (this.isOpen = !1, this.isMouseOverDropdown = !1, this._hide(), this.$menu.find(".tt-suggestions > .tt-suggestion").removeClass("tt-is-under-cursor"), 
                this.trigger("closed"));
            },
            open: function() {
                this.isOpen || (this.isOpen = !0, !this.isEmpty && this._show(), this.trigger("opened"));
            },
            setLanguageDirection: function(dir) {
                var ltrCss = {
                    left: "0",
                    right: "auto"
                }, rtlCss = {
                    left: "auto",
                    right: " 0"
                };
                this.$menu.css("ltr" === dir ? ltrCss : rtlCss);
            },
            moveCursorUp: function() {
                this._moveCursor(-1);
            },
            moveCursorDown: function() {
                this._moveCursor(1);
            },
            getSuggestionUnderCursor: function() {
                var $suggestion = this._getSuggestions().filter(".tt-is-under-cursor").first();
                return $suggestion.length > 0 ? extractSuggestion($suggestion) : null;
            },
            getFirstSuggestion: function() {
                var $suggestion = this._getSuggestions().first();
                return $suggestion.length > 0 ? extractSuggestion($suggestion) : null;
            },
            renderSuggestions: function(dataset, suggestions) {
                var compiledHtml, $suggestionsList, elBuilder, fragment, $el, datasetClassName = "tt-dataset-" + dataset.name, wrapper = '<div class="tt-suggestion">%body</div>', $dataset = this.$menu.find("." + datasetClassName);
                0 === $dataset.length && ($suggestionsList = $(html.suggestionsList).css(css.suggestionsList), 
                $dataset = $("<div></div>").addClass(datasetClassName).append(dataset.header).append($suggestionsList).append(dataset.footer).appendTo(this.$menu)), 
                suggestions.length > 0 ? (this.isEmpty = !1, this.isOpen && this._show(), elBuilder = document.createElement("div"), 
                fragment = document.createDocumentFragment(), utils.each(suggestions, function(i, suggestion) {
                    suggestion.dataset = dataset.name, compiledHtml = dataset.template(suggestion.datum), 
                    elBuilder.innerHTML = wrapper.replace("%body", compiledHtml), $el = $(elBuilder.firstChild).css(css.suggestion).data("suggestion", suggestion), 
                    $el.children().each(function() {
                        $(this).css(css.suggestionChild);
                    }), fragment.appendChild($el[0]);
                }), $dataset.show().find(".tt-suggestions").html(fragment)) : this.clearSuggestions(dataset.name), 
                this.trigger("suggestionsRendered");
            },
            clearSuggestions: function(datasetName) {
                var $datasets = this.$menu.find(datasetName ? ".tt-dataset-" + datasetName : '[class^="tt-dataset-"]'), $suggestions = $datasets.find(".tt-suggestions");
                $datasets.hide(), $suggestions.empty(), 0 === this._getSuggestions().length && (this.isEmpty = !0, 
                this._hide());
            }
        }), DropdownView;
    }(), TypeaheadView = function() {
        function TypeaheadView(o) {
            var $menu, $input, $hint;
            utils.bindAll(this), this.$node = buildDomStructure(o.input), this.datasets = o.datasets, 
            this.dir = null, this.eventBus = o.eventBus, $menu = this.$node.find(".tt-dropdown-menu"), 
            $input = this.$node.find(".tt-query"), $hint = this.$node.find(".tt-hint"), this.dropdownView = new DropdownView({
                menu: $menu
            }).on("suggestionSelected", this._handleSelection).on("cursorMoved", this._clearHint).on("cursorMoved", this._setInputValueToSuggestionUnderCursor).on("cursorRemoved", this._setInputValueToQuery).on("cursorRemoved", this._updateHint).on("suggestionsRendered", this._updateHint).on("opened", this._updateHint).on("closed", this._clearHint).on("opened closed", this._propagateEvent), 
            this.inputView = new InputView({
                input: $input,
                hint: $hint
            }).on("focused", this._openDropdown).on("blured", this._closeDropdown).on("blured", this._setInputValueToQuery).on("enterKeyed tabKeyed", this._handleSelection).on("queryChanged", this._clearHint).on("queryChanged", this._clearSuggestions).on("queryChanged", this._getSuggestions).on("whitespaceChanged", this._updateHint).on("queryChanged whitespaceChanged", this._openDropdown).on("queryChanged whitespaceChanged", this._setLanguageDirection).on("escKeyed", this._closeDropdown).on("escKeyed", this._setInputValueToQuery).on("tabKeyed upKeyed downKeyed", this._managePreventDefault).on("upKeyed downKeyed", this._moveDropdownCursor).on("upKeyed downKeyed", this._openDropdown).on("tabKeyed leftKeyed rightKeyed", this._autocomplete);
        }
        function buildDomStructure(input) {
            var $wrapper = $(html.wrapper), $dropdown = $(html.dropdown), $input = $(input), $hint = $(html.hint);
            $wrapper = $wrapper.css(css.wrapper), $dropdown = $dropdown.css(css.dropdown), $hint.css(css.hint).css({
                backgroundAttachment: $input.css("background-attachment"),
                backgroundClip: $input.css("background-clip"),
                backgroundColor: $input.css("background-color"),
                backgroundImage: $input.css("background-image"),
                backgroundOrigin: $input.css("background-origin"),
                backgroundPosition: $input.css("background-position"),
                backgroundRepeat: $input.css("background-repeat"),
                backgroundSize: $input.css("background-size")
            }), $input.data("ttAttrs", {
                dir: $input.attr("dir"),
                autocomplete: $input.attr("autocomplete"),
                spellcheck: $input.attr("spellcheck"),
                style: $input.attr("style")
            }), $input.addClass("tt-query").attr({
                autocomplete: "off",
                spellcheck: !1
            }).css(css.query);
            try {
                !$input.attr("dir") && $input.attr("dir", "auto");
            } catch (e) {}
            return $input.wrap($wrapper).parent().prepend($hint).append($dropdown);
        }
        function destroyDomStructure($node) {
            var $input = $node.find(".tt-query");
            utils.each($input.data("ttAttrs"), function(key, val) {
                utils.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
            }), $input.detach().removeData("ttAttrs").removeClass("tt-query").insertAfter($node), 
            $node.remove();
        }
        var html = {
            wrapper: '<span class="twitter-typeahead"></span>',
            hint: '<input class="tt-hint" type="text" autocomplete="off" spellcheck="off" disabled>',
            dropdown: '<span class="tt-dropdown-menu"></span>'
        }, css = {
            wrapper: {
                position: "relative",
                display: "inline-block"
            },
            hint: {
                position: "absolute",
                top: "0",
                left: "0",
                borderColor: "transparent",
                boxShadow: "none"
            },
            query: {
                position: "relative",
                verticalAlign: "top",
                backgroundColor: "transparent"
            },
            dropdown: {
                position: "absolute",
                top: "100%",
                left: "0",
                zIndex: "100",
                display: "none"
            }
        };
        return utils.isMsie() && utils.mixin(css.query, {
            backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
        }), utils.isMsie() && utils.isMsie() <= 7 && (utils.mixin(css.wrapper, {
            display: "inline",
            zoom: "1"
        }), utils.mixin(css.query, {
            marginTop: "-1px"
        })), utils.mixin(TypeaheadView.prototype, EventTarget, {
            _managePreventDefault: function(e) {
                var hint, inputValue, $e = e.data, preventDefault = !1;
                switch (e.type) {
                  case "tabKeyed":
                    hint = this.inputView.getHintValue(), inputValue = this.inputView.getInputValue(), 
                    preventDefault = hint && hint !== inputValue;
                    break;

                  case "upKeyed":
                  case "downKeyed":
                    preventDefault = !$e.shiftKey && !$e.ctrlKey && !$e.metaKey;
                }
                preventDefault && $e.preventDefault();
            },
            _setLanguageDirection: function() {
                var dir = this.inputView.getLanguageDirection();
                dir !== this.dir && (this.dir = dir, this.$node.css("direction", dir), this.dropdownView.setLanguageDirection(dir));
            },
            _updateHint: function() {
                var inputValue, query, escapedQuery, beginsWithQuery, match, suggestion = this.dropdownView.getFirstSuggestion(), hint = suggestion ? suggestion.value : null, dropdownIsVisible = this.dropdownView.isVisible(), inputHasOverflow = this.inputView.isOverflow();
                hint && dropdownIsVisible && !inputHasOverflow && (inputValue = this.inputView.getInputValue(), 
                query = inputValue.replace(/\s{2,}/g, " ").replace(/^\s+/g, ""), escapedQuery = utils.escapeRegExChars(query), 
                beginsWithQuery = new RegExp("^(?:" + escapedQuery + ")(.*$)", "i"), match = beginsWithQuery.exec(hint), 
                this.inputView.setHintValue(inputValue + (match ? match[1] : "")));
            },
            _clearHint: function() {
                this.inputView.setHintValue("");
            },
            _clearSuggestions: function() {
                this.dropdownView.clearSuggestions();
            },
            _setInputValueToQuery: function() {
                this.inputView.setInputValue(this.inputView.getQuery());
            },
            _setInputValueToSuggestionUnderCursor: function(e) {
                var suggestion = e.data;
                this.inputView.setInputValue(suggestion.value, !0);
            },
            _openDropdown: function() {
                this.dropdownView.open();
            },
            _closeDropdown: function(e) {
                this.dropdownView["blured" === e.type ? "closeUnlessMouseIsOverDropdown" : "close"]();
            },
            _moveDropdownCursor: function(e) {
                var $e = e.data;
                $e.shiftKey || $e.ctrlKey || $e.metaKey || this.dropdownView["upKeyed" === e.type ? "moveCursorUp" : "moveCursorDown"]();
            },
            _handleSelection: function(e) {
                var byClick = "suggestionSelected" === e.type, suggestion = byClick ? e.data : this.dropdownView.getSuggestionUnderCursor();
                suggestion && (this.inputView.setInputValue(suggestion.value), byClick ? this.inputView.focus() : e.data.preventDefault(), 
                byClick && utils.isMsie() ? utils.defer(this.dropdownView.close) : this.dropdownView.close(), 
                this.eventBus.trigger("selected", suggestion.datum, suggestion.dataset));
            },
            _getSuggestions: function() {
                var that = this, query = this.inputView.getQuery();
                utils.isBlankString(query) || utils.each(this.datasets, function(i, dataset) {
                    dataset.getSuggestions(query, function(suggestions) {
                        query === that.inputView.getQuery() && that.dropdownView.renderSuggestions(dataset, suggestions);
                    });
                });
            },
            _autocomplete: function(e) {
                var isCursorAtEnd, ignoreEvent, query, hint, suggestion;
                ("rightKeyed" !== e.type && "leftKeyed" !== e.type || (isCursorAtEnd = this.inputView.isCursorAtEnd(), 
                ignoreEvent = "ltr" === this.inputView.getLanguageDirection() ? "leftKeyed" === e.type : "rightKeyed" === e.type, 
                isCursorAtEnd && !ignoreEvent)) && (query = this.inputView.getQuery(), hint = this.inputView.getHintValue(), 
                "" !== hint && query !== hint && (suggestion = this.dropdownView.getFirstSuggestion(), 
                this.inputView.setInputValue(suggestion.value), this.eventBus.trigger("autocompleted", suggestion.datum, suggestion.dataset)));
            },
            _propagateEvent: function(e) {
                this.eventBus.trigger(e.type);
            },
            destroy: function() {
                this.inputView.destroy(), this.dropdownView.destroy(), destroyDomStructure(this.$node), 
                this.$node = null;
            },
            setQuery: function(query) {
                this.inputView.setQuery(query), this.inputView.setInputValue(query), this._clearHint(), 
                this._clearSuggestions(), this._getSuggestions();
            }
        }), TypeaheadView;
    }();
    !function() {
        var methods, cache = {}, viewKey = "ttView";
        methods = {
            initialize: function(datasetDefs) {
                function initialize() {
                    var deferreds, $input = $(this), eventBus = new EventBus({
                        el: $input
                    });
                    deferreds = utils.map(datasets, function(dataset) {
                        return dataset.initialize();
                    }), $input.data(viewKey, new TypeaheadView({
                        input: $input,
                        eventBus: eventBus = new EventBus({
                            el: $input
                        }),
                        datasets: datasets
                    })), $.when.apply($, deferreds).always(function() {
                        utils.defer(function() {
                            eventBus.trigger("initialized");
                        });
                    });
                }
                var datasets;
                return datasetDefs = utils.isArray(datasetDefs) ? datasetDefs : [ datasetDefs ], 
                0 === datasetDefs.length && $.error("no datasets provided"), datasets = utils.map(datasetDefs, function(o) {
                    var dataset = cache[o.name] ? cache[o.name] : new Dataset(o);
                    return o.name && (cache[o.name] = dataset), dataset;
                }), this.each(initialize);
            },
            destroy: function() {
                function destroy() {
                    var $this = $(this), view = $this.data(viewKey);
                    view && (view.destroy(), $this.removeData(viewKey));
                }
                return this.each(destroy);
            },
            setQuery: function(query) {
                function setQuery() {
                    var view = $(this).data(viewKey);
                    view && view.setQuery(query);
                }
                return this.each(setQuery);
            }
        }, jQuery.fn.typeahead = function(method) {
            return methods[method] ? methods[method].apply(this, [].slice.call(arguments, 1)) : methods.initialize.apply(this, arguments);
        };
    }();
}(window.jQuery), function() {
    var __indexOf = [].indexOf || function(item) {
        for (var i = 0, l = this.length; l > i; i++) if (i in this && this[i] === item) return i;
        return -1;
    }, __slice = [].slice;
    !function(root, factory) {
        return "function" == typeof define && define.amd ? define("waypoints", [ "jquery" ], function($) {
            return factory($, root);
        }) : factory(root.jQuery, root);
    }(this, function($, window) {
        var $w, Context, Waypoint, allWaypoints, contextCounter, contextKey, contexts, isTouch, jQMethods, methods, resizeEvent, scrollEvent, waypointCounter, waypointKey, wp, wps;
        return $w = $(window), isTouch = __indexOf.call(window, "ontouchstart") >= 0, allWaypoints = {
            horizontal: {},
            vertical: {}
        }, contextCounter = 1, contexts = {}, contextKey = "waypoints-context-id", resizeEvent = "resize.waypoints", 
        scrollEvent = "scroll.waypoints", waypointCounter = 1, waypointKey = "waypoints-waypoint-ids", 
        wp = "waypoint", wps = "waypoints", Context = function() {
            function Context($element) {
                var _this = this;
                this.$element = $element, this.element = $element[0], this.didResize = !1, this.didScroll = !1, 
                this.id = "context" + contextCounter++, this.oldScroll = {
                    x: $element.scrollLeft(),
                    y: $element.scrollTop()
                }, this.waypoints = {
                    horizontal: {},
                    vertical: {}
                }, $element.data(contextKey, this.id), contexts[this.id] = this, $element.bind(scrollEvent, function() {
                    var scrollHandler;
                    return _this.didScroll || isTouch ? void 0 : (_this.didScroll = !0, scrollHandler = function() {
                        return _this.doScroll(), _this.didScroll = !1;
                    }, window.setTimeout(scrollHandler, $[wps].settings.scrollThrottle));
                }), $element.bind(resizeEvent, function() {
                    var resizeHandler;
                    return _this.didResize ? void 0 : (_this.didResize = !0, resizeHandler = function() {
                        return $[wps]("refresh"), _this.didResize = !1;
                    }, window.setTimeout(resizeHandler, $[wps].settings.resizeThrottle));
                });
            }
            return Context.prototype.doScroll = function() {
                var axes, _this = this;
                return axes = {
                    horizontal: {
                        newScroll: this.$element.scrollLeft(),
                        oldScroll: this.oldScroll.x,
                        forward: "right",
                        backward: "left"
                    },
                    vertical: {
                        newScroll: this.$element.scrollTop(),
                        oldScroll: this.oldScroll.y,
                        forward: "down",
                        backward: "up"
                    }
                }, !isTouch || axes.vertical.oldScroll && axes.vertical.newScroll || $[wps]("refresh"), 
                $.each(axes, function(aKey, axis) {
                    var direction, isForward, triggered;
                    return triggered = [], isForward = axis.newScroll > axis.oldScroll, direction = isForward ? axis.forward : axis.backward, 
                    $.each(_this.waypoints[aKey], function(wKey, waypoint) {
                        var _ref, _ref1;
                        return axis.oldScroll < (_ref = waypoint.offset) && _ref <= axis.newScroll ? triggered.push(waypoint) : axis.newScroll < (_ref1 = waypoint.offset) && _ref1 <= axis.oldScroll ? triggered.push(waypoint) : void 0;
                    }), triggered.sort(function(a, b) {
                        return a.offset - b.offset;
                    }), isForward || triggered.reverse(), $.each(triggered, function(i, waypoint) {
                        return waypoint.options.continuous || i === triggered.length - 1 ? waypoint.trigger([ direction ]) : void 0;
                    });
                }), this.oldScroll = {
                    x: axes.horizontal.newScroll,
                    y: axes.vertical.newScroll
                };
            }, Context.prototype.refresh = function() {
                var axes, cOffset, isWin, _this = this;
                return isWin = $.isWindow(this.element), cOffset = this.$element.offset(), this.doScroll(), 
                axes = {
                    horizontal: {
                        contextOffset: isWin ? 0 : cOffset.left,
                        contextScroll: isWin ? 0 : this.oldScroll.x,
                        contextDimension: this.$element.width(),
                        oldScroll: this.oldScroll.x,
                        forward: "right",
                        backward: "left",
                        offsetProp: "left"
                    },
                    vertical: {
                        contextOffset: isWin ? 0 : cOffset.top,
                        contextScroll: isWin ? 0 : this.oldScroll.y,
                        contextDimension: isWin ? $[wps]("viewportHeight") : this.$element.height(),
                        oldScroll: this.oldScroll.y,
                        forward: "down",
                        backward: "up",
                        offsetProp: "top"
                    }
                }, $.each(axes, function(aKey, axis) {
                    return $.each(_this.waypoints[aKey], function(i, waypoint) {
                        var adjustment, elementOffset, oldOffset, _ref, _ref1;
                        return adjustment = waypoint.options.offset, oldOffset = waypoint.offset, elementOffset = $.isWindow(waypoint.element) ? 0 : waypoint.$element.offset()[axis.offsetProp], 
                        $.isFunction(adjustment) ? adjustment = adjustment.apply(waypoint.element) : "string" == typeof adjustment && (adjustment = parseFloat(adjustment), 
                        waypoint.options.offset.indexOf("%") > -1 && (adjustment = Math.ceil(axis.contextDimension * adjustment / 100))), 
                        waypoint.offset = elementOffset - axis.contextOffset + axis.contextScroll - adjustment, 
                        waypoint.options.onlyOnScroll && null != oldOffset || !waypoint.enabled ? void 0 : null !== oldOffset && oldOffset < (_ref = axis.oldScroll) && _ref <= waypoint.offset ? waypoint.trigger([ axis.backward ]) : null !== oldOffset && oldOffset > (_ref1 = axis.oldScroll) && _ref1 >= waypoint.offset ? waypoint.trigger([ axis.forward ]) : null === oldOffset && axis.oldScroll >= waypoint.offset ? waypoint.trigger([ axis.forward ]) : void 0;
                    });
                });
            }, Context.prototype.checkEmpty = function() {
                return $.isEmptyObject(this.waypoints.horizontal) && $.isEmptyObject(this.waypoints.vertical) ? (this.$element.unbind([ resizeEvent, scrollEvent ].join(" ")), 
                delete contexts[this.id]) : void 0;
            }, Context;
        }(), Waypoint = function() {
            function Waypoint($element, context, options) {
                var idList, _ref;
                options = $.extend({}, $.fn[wp].defaults, options), "bottom-in-view" === options.offset && (options.offset = function() {
                    var contextHeight;
                    return contextHeight = $[wps]("viewportHeight"), $.isWindow(context.element) || (contextHeight = context.$element.height()), 
                    contextHeight - $(this).outerHeight();
                }), this.$element = $element, this.element = $element[0], this.axis = options.horizontal ? "horizontal" : "vertical", 
                this.callback = options.handler, this.context = context, this.enabled = options.enabled, 
                this.id = "waypoints" + waypointCounter++, this.offset = null, this.options = options, 
                context.waypoints[this.axis][this.id] = this, allWaypoints[this.axis][this.id] = this, 
                idList = null != (_ref = $element.data(waypointKey)) ? _ref : [], idList.push(this.id), 
                $element.data(waypointKey, idList);
            }
            return Waypoint.prototype.trigger = function(args) {
                return this.enabled ? (null != this.callback && this.callback.apply(this.element, args), 
                this.options.triggerOnce ? this.destroy() : void 0) : void 0;
            }, Waypoint.prototype.disable = function() {
                return this.enabled = !1;
            }, Waypoint.prototype.enable = function() {
                return this.context.refresh(), this.enabled = !0;
            }, Waypoint.prototype.destroy = function() {
                return delete allWaypoints[this.axis][this.id], delete this.context.waypoints[this.axis][this.id], 
                this.context.checkEmpty();
            }, Waypoint.getWaypointsByElement = function(element) {
                var all, ids;
                return (ids = $(element).data(waypointKey)) ? (all = $.extend({}, allWaypoints.horizontal, allWaypoints.vertical), 
                $.map(ids, function(id) {
                    return all[id];
                })) : [];
            }, Waypoint;
        }(), methods = {
            init: function(f, options) {
                var _ref;
                return null == options && (options = {}), null == (_ref = options.handler) && (options.handler = f), 
                this.each(function() {
                    var $this, context, contextElement, _ref1;
                    return $this = $(this), contextElement = null != (_ref1 = options.context) ? _ref1 : $.fn[wp].defaults.context, 
                    $.isWindow(contextElement) || (contextElement = $this.closest(contextElement)), 
                    contextElement = $(contextElement), context = contexts[contextElement.data(contextKey)], 
                    context || (context = new Context(contextElement)), new Waypoint($this, context, options);
                }), $[wps]("refresh"), this;
            },
            disable: function() {
                return methods._invoke(this, "disable");
            },
            enable: function() {
                return methods._invoke(this, "enable");
            },
            destroy: function() {
                return methods._invoke(this, "destroy");
            },
            prev: function(axis, selector) {
                return methods._traverse.call(this, axis, selector, function(stack, index, waypoints) {
                    return index > 0 ? stack.push(waypoints[index - 1]) : void 0;
                });
            },
            next: function(axis, selector) {
                return methods._traverse.call(this, axis, selector, function(stack, index, waypoints) {
                    return index < waypoints.length - 1 ? stack.push(waypoints[index + 1]) : void 0;
                });
            },
            _traverse: function(axis, selector, push) {
                var stack, waypoints;
                return null == axis && (axis = "vertical"), null == selector && (selector = window), 
                waypoints = jQMethods.aggregate(selector), stack = [], this.each(function() {
                    var index;
                    return index = $.inArray(this, waypoints[axis]), push(stack, index, waypoints[axis]);
                }), this.pushStack(stack);
            },
            _invoke: function($elements, method) {
                return $elements.each(function() {
                    var waypoints;
                    return waypoints = Waypoint.getWaypointsByElement(this), $.each(waypoints, function(i, waypoint) {
                        return waypoint[method](), !0;
                    });
                }), this;
            }
        }, $.fn[wp] = function() {
            var args, method;
            return method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [], 
            methods[method] ? methods[method].apply(this, args) : $.isFunction(method) ? methods.init.apply(this, arguments) : $.isPlainObject(method) ? methods.init.apply(this, [ null, method ]) : $.error(method ? "The " + method + " method does not exist in jQuery Waypoints." : "jQuery Waypoints needs a callback function or handler option.");
        }, $.fn[wp].defaults = {
            context: window,
            continuous: !0,
            enabled: !0,
            horizontal: !1,
            offset: 0,
            triggerOnce: !1
        }, jQMethods = {
            refresh: function() {
                return $.each(contexts, function(i, context) {
                    return context.refresh();
                });
            },
            viewportHeight: function() {
                var _ref;
                return null != (_ref = window.innerHeight) ? _ref : $w.height();
            },
            aggregate: function(contextSelector) {
                var collection, waypoints, _ref;
                return collection = allWaypoints, contextSelector && (collection = null != (_ref = contexts[$(contextSelector).data(contextKey)]) ? _ref.waypoints : void 0), 
                collection ? (waypoints = {
                    horizontal: [],
                    vertical: []
                }, $.each(waypoints, function(axis, arr) {
                    return $.each(collection[axis], function(key, waypoint) {
                        return arr.push(waypoint);
                    }), arr.sort(function(a, b) {
                        return a.offset - b.offset;
                    }), waypoints[axis] = $.map(arr, function(waypoint) {
                        return waypoint.element;
                    }), waypoints[axis] = $.unique(waypoints[axis]);
                }), waypoints) : [];
            },
            above: function(contextSelector) {
                return null == contextSelector && (contextSelector = window), jQMethods._filter(contextSelector, "vertical", function(context, waypoint) {
                    return waypoint.offset <= context.oldScroll.y;
                });
            },
            below: function(contextSelector) {
                return null == contextSelector && (contextSelector = window), jQMethods._filter(contextSelector, "vertical", function(context, waypoint) {
                    return waypoint.offset > context.oldScroll.y;
                });
            },
            left: function(contextSelector) {
                return null == contextSelector && (contextSelector = window), jQMethods._filter(contextSelector, "horizontal", function(context, waypoint) {
                    return waypoint.offset <= context.oldScroll.x;
                });
            },
            right: function(contextSelector) {
                return null == contextSelector && (contextSelector = window), jQMethods._filter(contextSelector, "horizontal", function(context, waypoint) {
                    return waypoint.offset > context.oldScroll.x;
                });
            },
            enable: function() {
                return jQMethods._invoke("enable");
            },
            disable: function() {
                return jQMethods._invoke("disable");
            },
            destroy: function() {
                return jQMethods._invoke("destroy");
            },
            extendFn: function(methodName, f) {
                return methods[methodName] = f;
            },
            _invoke: function(method) {
                var waypoints;
                return waypoints = $.extend({}, allWaypoints.vertical, allWaypoints.horizontal), 
                $.each(waypoints, function(key, waypoint) {
                    return waypoint[method](), !0;
                });
            },
            _filter: function(selector, axis, test) {
                var context, waypoints;
                return (context = contexts[$(selector).data(contextKey)]) ? (waypoints = [], $.each(context.waypoints[axis], function(i, waypoint) {
                    return test(context, waypoint) ? waypoints.push(waypoint) : void 0;
                }), waypoints.sort(function(a, b) {
                    return a.offset - b.offset;
                }), $.map(waypoints, function(waypoint) {
                    return waypoint.element;
                })) : [];
            }
        }, $[wps] = function() {
            var args, method;
            return method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [], 
            jQMethods[method] ? jQMethods[method].apply(null, args) : jQMethods.aggregate.call(null, method);
        }, $[wps].settings = {
            resizeThrottle: 100,
            scrollThrottle: 30
        }, $w.load(function() {
            return $[wps]("refresh");
        });
    });
}.call(this), angular.module("wembliApp", [ "ngRoute", "mgcrea.ngStrap", "wembliApp.controllers", "wembliApp.controllers.search", "wembliApp.controllers.header", "wembliApp.filters", "wembliApp.services", "wembliApp.services.header", "wembliApp.services.facebook", "wembliApp.services.twitter", "wembliApp.services.pixel", "wembliApp.directives", "wembliApp.directives.header", "wembliApp.directives.search", "wembliApp.directives.typeahead" ]).config([ "$routeProvider", "$locationProvider", function() {} ]).run([ "$timeout", "initRootScope", "$rootScope", "$location", "$route", "$window", "facebook", "twitter", "plan", "wembliRpc", function($timeout, initRootScope, $scope, $location, $route, $window, facebook, twitter, plan) {
    console.log("run search angular app"), $timeout(function() {
        plan.fetch(function() {});
    }), $window.fbAsyncInit = function() {
        facebook.getLoginStatus(), $scope.facebook = facebook;
    }, twitter.getLoginStatus();
} ]), angular.module("wembliApp.controllers.search", []).controller("EventListCtrl", [ "$scope", "$location", "wembliRpc", "$filter", "$rootScope", "plan", "fetchModals", "loadingModal", "$timeout", function() {} ]).controller("SearchCtrl", [ "$scope", "$rootScope", "$window", "wembliRpc", "googleAnalytics", "overlay", function($scope, $rootScope, $window, wembliRpc, googleAnalytics, overlay) {
    $rootScope.$broadcast("search-page-loaded", {}), $scope.submitInProgress = !1, $scope.searchInProgress = !1, 
    $scope.showPaymentType = !1, $scope.$on("search-page-loaded", function() {
        $scope.searchInProgress = !1;
    }), $scope.submitSearch = function() {
        $scope.searchInProgress = !0;
    }, $scope.openPaymentModal = function(eventData) {
        $scope.eventData = eventData, $scope.showPaymentType = !0, overlay.show(), console.log($scope.showPaymentType);
    }, $scope.closePaymentModal = function() {
        $scope.showPaymentType = !1, overlay.hide();
    }, $rootScope.$on("overlay-clicked", function() {
        console.log("overlay clicked"), $rootScope.$apply(function() {
            $scope.closePaymentModal();
        });
    }), $scope.splitAfter = function() {
        $scope.paymentType = "split-after", $scope.startPlan();
    }, $scope.splitFirst = function() {
        $scope.paymentType = "split-first", $scope.startPlan();
    }, $scope.startPlan = function() {
        $scope.showPaymentType = !1, overlay.loading(!0), console.log("clicked startPlan"), 
        console.log($scope.eventData), $scope.submitInProgress = !0, "split-first" === $scope.paymentType && ($scope.nextLink = "/event-options/" + $scope.eventData.ID + "/" + $scope.eventData.Name), 
        "undefined" == typeof $scope.nextLink && ($scope.nextLink = "/tickets/" + $scope.eventData.ID + "/" + $scope.eventData.Name), 
        wembliRpc.fetch("plan.startPlan", {
            payment: $scope.paymentType,
            eventId: $scope.eventData.ID,
            eventName: $scope.eventData.Name
        }, function(err, result) {
            return console.log(result), result.success ? void googleAnalytics.trackEvent("Plan", "start", $scope.eventName, "", function() {
                $scope.submitInProgress = !1, $window.location.href = $scope.nextLink;
            }) : ($("#no-event-modal").modal("show"), void $scope.closePaymentModal());
        });
    };
} ]), angular.module("wembliApp.directives.search", []).directive("eventListWaypoint", [ "wembliRpc", "$filter", "$timeout", function(wembliRpc, $filter, $timeout) {
    return {
        restrict: "C",
        compile: function() {
            return function(scope) {
                scope.events = [], scope.loadingMoreEvents = !1;
                var opts = {
                    offset: "bottom-in-view"
                }, handler = function(direction) {
                    var $this = $(this);
                    if ("down" === direction) {
                        $this.waypoint("disable"), scope.loadingMoreEvents = !0;
                        var args = {
                            beginDate: scope.lastEventDate,
                            orderByClause: "Date",
                            lastEventId: scope.lastEventId
                        };
                        if (scope.search) {
                            args.searchTerms = scope.search;
                            var method = "event.search";
                        } else {
                            args.nearZip = scope.postalCode;
                            var method = "event.get";
                        }
                        wembliRpc.fetch(method, args, function(err, result) {
                            return scope.loadingMoreEvents = !1, err ? (scope.noMoreEvents = !0, void $this.waypoint("destroy")) : void $timeout(function() {
                                if (console.log(result), result.event.length < 1) scope.noMoreEvents = !0, $this.waypoint("destroy"); else {
                                    scope.noMoreEvents = !1, scope.events = scope.events.concat(result.event);
                                    var d = new Date(scope.events[scope.events.length - 1].Date);
                                    scope.lastEventDate = $filter("date")(d, "MM-dd-yy"), scope.lastEventId = scope.events[scope.events.length - 1].ID, 
                                    scope.$digest();
                                }
                                $this.waypoint("enable");
                            });
                        });
                    }
                };
                $(".event-list-waypoint").waypoint(handler, opts);
            };
        }
    };
} ]).directive("showTicketRange", [ "wembliRpc", "$window", function(wembliRpc) {
    return {
        restrict: "C",
        controller: [ "$scope", "$element", "$attrs", "$transclude", function() {} ],
        compile: function() {
            return function(scope, element, attr) {
                element.mouseover(function() {
                    if ("undefined" == typeof scope.ticketSummaryData && (scope.ticketSummaryData = {}), 
                    "undefined" != typeof scope.ticketSummaryData[attr.eventId]) return void console.log("already fetched");
                    if (scope.ticketSummaryData[attr.eventId] = {}, scope.ticketSummaryData[attr.eventId].locked) return void console.log("locked");
                    scope.ticketSummaryData[attr.eventId].locked = !0;
                    var args = {
                        eventID: attr.eventId
                    };
                    console.log("getpricing info"), console.log(args), wembliRpc.fetch("event.getPricingInfo", args, function(err, result) {
                        var summaryContent = "Start plan for ticket pricing";
                        return err ? void $("#" + attr.id + " .ticket-range").html(summaryContent).fadeIn() : (scope.ticketSummaryData[attr.eventId].locked = !1, 
                        "undefined" != typeof result.ticketPricingInfo.ticketsAvailable && "0" !== result.ticketPricingInfo.ticketsAvailable && (summaryContent = "1" === result.ticketPricingInfo.ticketsAvailable ? result.ticketPricingInfo.ticketsAvailable + " ticket" : result.ticketPricingInfo.ticketsAvailable + " tickets", 
                        summaryContent += parseFloat(result.ticketPricingInfo.lowPrice) === parseFloat(result.ticketPricingInfo.highPrice) ? ": $" + parseFloat(result.ticketPricingInfo.lowPrice).toFixed(0) : ": $" + parseFloat(result.ticketPricingInfo.lowPrice).toFixed(0) + " - $" + parseFloat(result.ticketPricingInfo.highPrice).toFixed(0)), 
                        scope.ticketSummaryData[attr.eventId] = summaryContent, void (summaryContent && $("#" + attr.id + " .ticket-range").html(summaryContent).fadeIn()));
                    });
                });
            };
        }
    };
} ]), angular.module("wembliApp.directives.typeahead", []).directive("typeahead", [ function() {
    var config = {
        index: [ {
            name: "events",
            remote: "/typeahead/events/%QUERY",
            header: '<h3 class="typeahead-header">Events</h3>'
        }, {
            name: "performers",
            remote: "/typeahead/performers/%QUERY",
            header: '<h3 class="typeahead-header">Performers</h3>'
        }, {
            name: "venues",
            remote: "/typeahead/venues/%QUERY",
            header: '<h3 class="typeahead-header">Venues</h3>'
        } ]
    };
    return {
        restrict: "C",
        replace: !1,
        compile: function() {
            return function(scope, element, attr) {
                console.log(config[attr.config]), element.typeahead(config[attr.config]);
            };
        }
    };
} ]);