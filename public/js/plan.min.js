/*! wembli-website 2014-08-05 */
"use strict";

!function($, undefined) {
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img, nodeName = element.nodeName.toLowerCase();
        return "area" === nodeName ? (map = element.parentNode, mapName = map.name, element.href && mapName && "map" === map.nodeName.toLowerCase() ? (img = $("img[usemap=#" + mapName + "]")[0], 
        !!img && visible(img)) : !1) : (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
    }
    function visible(element) {
        return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
            return "hidden" === $.css(this, "visibility");
        }).length;
    }
    var uuid = 0, runiqueId = /^ui-id-\d+$/;
    $.ui = $.ui || {}, $.extend($.ui, {
        version: "1.10.4",
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            NUMPAD_ADD: 107,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            NUMPAD_ENTER: 108,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_SUBTRACT: 109,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    }), $.fn.extend({
        focus: function(orig) {
            return function(delay, fn) {
                return "number" == typeof delay ? this.each(function() {
                    var elem = this;
                    setTimeout(function() {
                        $(elem).focus(), fn && fn.call(elem);
                    }, delay);
                }) : orig.apply(this, arguments);
            };
        }($.fn.focus),
        scrollParent: function() {
            var scrollParent;
            return scrollParent = $.ui.ie && /(static|relative)/.test(this.css("position")) || /absolute/.test(this.css("position")) ? this.parents().filter(function() {
                return /(relative|absolute|fixed)/.test($.css(this, "position")) && /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
            }).eq(0) : this.parents().filter(function() {
                return /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
            }).eq(0), /fixed/.test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
        },
        zIndex: function(zIndex) {
            if (zIndex !== undefined) return this.css("zIndex", zIndex);
            if (this.length) for (var position, value, elem = $(this[0]); elem.length && elem[0] !== document; ) {
                if (position = elem.css("position"), ("absolute" === position || "relative" === position || "fixed" === position) && (value = parseInt(elem.css("zIndex"), 10), 
                !isNaN(value) && 0 !== value)) return value;
                elem = elem.parent();
            }
            return 0;
        },
        uniqueId: function() {
            return this.each(function() {
                this.id || (this.id = "ui-id-" + ++uuid);
            });
        },
        removeUniqueId: function() {
            return this.each(function() {
                runiqueId.test(this.id) && $(this).removeAttr("id");
            });
        }
    }), $.extend($.expr[":"], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
            return function(elem) {
                return !!$.data(elem, dataName);
            };
        }) : function(elem, i, match) {
            return !!$.data(elem, match[3]);
        },
        focusable: function(element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"), isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    }), $("<a>").outerWidth(1).jquery || $.each([ "Width", "Height" ], function(i, name) {
        function reduce(elem, size, border, margin) {
            return $.each(side, function() {
                size -= parseFloat($.css(elem, "padding" + this)) || 0, border && (size -= parseFloat($.css(elem, "border" + this + "Width")) || 0), 
                margin && (size -= parseFloat($.css(elem, "margin" + this)) || 0);
            }), size;
        }
        var side = "Width" === name ? [ "Left", "Right" ] : [ "Top", "Bottom" ], type = name.toLowerCase(), orig = {
            innerWidth: $.fn.innerWidth,
            innerHeight: $.fn.innerHeight,
            outerWidth: $.fn.outerWidth,
            outerHeight: $.fn.outerHeight
        };
        $.fn["inner" + name] = function(size) {
            return size === undefined ? orig["inner" + name].call(this) : this.each(function() {
                $(this).css(type, reduce(this, size) + "px");
            });
        }, $.fn["outer" + name] = function(size, margin) {
            return "number" != typeof size ? orig["outer" + name].call(this, size) : this.each(function() {
                $(this).css(type, reduce(this, size, !0, margin) + "px");
            });
        };
    }), $.fn.addBack || ($.fn.addBack = function(selector) {
        return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector));
    }), $("<a>").data("a-b", "a").removeData("a-b").data("a-b") && ($.fn.removeData = function(removeData) {
        return function(key) {
            return arguments.length ? removeData.call(this, $.camelCase(key)) : removeData.call(this);
        };
    }($.fn.removeData)), $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()), 
    $.support.selectstart = "onselectstart" in document.createElement("div"), $.fn.extend({
        disableSelection: function() {
            return this.bind(($.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection", function(event) {
                event.preventDefault();
            });
        },
        enableSelection: function() {
            return this.unbind(".ui-disableSelection");
        }
    }), $.extend($.ui, {
        plugin: {
            add: function(module, option, set) {
                var i, proto = $.ui[module].prototype;
                for (i in set) proto.plugins[i] = proto.plugins[i] || [], proto.plugins[i].push([ option, set[i] ]);
            },
            call: function(instance, name, args) {
                var i, set = instance.plugins[name];
                if (set && instance.element[0].parentNode && 11 !== instance.element[0].parentNode.nodeType) for (i = 0; i < set.length; i++) instance.options[set[i][0]] && set[i][1].apply(instance.element, args);
            }
        },
        hasScroll: function(el, a) {
            if ("hidden" === $(el).css("overflow")) return !1;
            var scroll = a && "left" === a ? "scrollLeft" : "scrollTop", has = !1;
            return el[scroll] > 0 ? !0 : (el[scroll] = 1, has = el[scroll] > 0, el[scroll] = 0, 
            has);
        }
    });
}(jQuery), function($, undefined) {
    var uuid = 0, slice = Array.prototype.slice, _cleanData = $.cleanData;
    $.cleanData = function(elems) {
        for (var elem, i = 0; null != (elem = elems[i]); i++) try {
            $(elem).triggerHandler("remove");
        } catch (e) {}
        _cleanData(elems);
    }, $.widget = function(name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype, proxiedPrototype = {}, namespace = name.split(".")[0];
        name = name.split(".")[1], fullName = namespace + "-" + name, prototype || (prototype = base, 
        base = $.Widget), $.expr[":"][fullName.toLowerCase()] = function(elem) {
            return !!$.data(elem, fullName);
        }, $[namespace] = $[namespace] || {}, existingConstructor = $[namespace][name], 
        constructor = $[namespace][name] = function(options, element) {
            return this._createWidget ? void (arguments.length && this._createWidget(options, element)) : new constructor(options, element);
        }, $.extend(constructor, existingConstructor, {
            version: prototype.version,
            _proto: $.extend({}, prototype),
            _childConstructors: []
        }), basePrototype = new base(), basePrototype.options = $.widget.extend({}, basePrototype.options), 
        $.each(prototype, function(prop, value) {
            return $.isFunction(value) ? void (proxiedPrototype[prop] = function() {
                var _super = function() {
                    return base.prototype[prop].apply(this, arguments);
                }, _superApply = function(args) {
                    return base.prototype[prop].apply(this, args);
                };
                return function() {
                    var returnValue, __super = this._super, __superApply = this._superApply;
                    return this._super = _super, this._superApply = _superApply, returnValue = value.apply(this, arguments), 
                    this._super = __super, this._superApply = __superApply, returnValue;
                };
            }()) : void (proxiedPrototype[prop] = value);
        }), constructor.prototype = $.widget.extend(basePrototype, {
            widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        }), existingConstructor ? ($.each(existingConstructor._childConstructors, function(i, child) {
            var childPrototype = child.prototype;
            $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
        }), delete existingConstructor._childConstructors) : base._childConstructors.push(constructor), 
        $.widget.bridge(name, constructor);
    }, $.widget.extend = function(target) {
        for (var key, value, input = slice.call(arguments, 1), inputIndex = 0, inputLength = input.length; inputLength > inputIndex; inputIndex++) for (key in input[inputIndex]) value = input[inputIndex][key], 
        input[inputIndex].hasOwnProperty(key) && value !== undefined && (target[key] = $.isPlainObject(value) ? $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value) : value);
        return target;
    }, $.widget.bridge = function(name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function(options) {
            var isMethodCall = "string" == typeof options, args = slice.call(arguments, 1), returnValue = this;
            return options = !isMethodCall && args.length ? $.widget.extend.apply(null, [ options ].concat(args)) : options, 
            this.each(isMethodCall ? function() {
                var methodValue, instance = $.data(this, fullName);
                return instance ? $.isFunction(instance[options]) && "_" !== options.charAt(0) ? (methodValue = instance[options].apply(instance, args), 
                methodValue !== instance && methodValue !== undefined ? (returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue, 
                !1) : void 0) : $.error("no such method '" + options + "' for " + name + " widget instance") : $.error("cannot call methods on " + name + " prior to initialization; attempted to call method '" + options + "'");
            } : function() {
                var instance = $.data(this, fullName);
                instance ? instance.option(options || {})._init() : $.data(this, fullName, new object(options, this));
            }), returnValue;
        };
    }, $.Widget = function() {}, $.Widget._childConstructors = [], $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: !1,
            create: null
        },
        _createWidget: function(options, element) {
            element = $(element || this.defaultElement || this)[0], this.element = $(element), 
            this.uuid = uuid++, this.eventNamespace = "." + this.widgetName + this.uuid, this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options), 
            this.bindings = $(), this.hoverable = $(), this.focusable = $(), element !== this && ($.data(element, this.widgetFullName, this), 
            this._on(!0, this.element, {
                remove: function(event) {
                    event.target === element && this.destroy();
                }
            }), this.document = $(element.style ? element.ownerDocument : element.document || element), 
            this.window = $(this.document[0].defaultView || this.document[0].parentWindow)), 
            this._create(), this._trigger("create", null, this._getCreateEventData()), this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,
        destroy: function() {
            this._destroy(), this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName)), 
            this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled ui-state-disabled"), 
            this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass("ui-state-hover"), 
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,
        widget: function() {
            return this.element;
        },
        option: function(key, value) {
            var parts, curOption, i, options = key;
            if (0 === arguments.length) return $.widget.extend({}, this.options);
            if ("string" == typeof key) if (options = {}, parts = key.split("."), key = parts.shift(), 
            parts.length) {
                for (curOption = options[key] = $.widget.extend({}, this.options[key]), i = 0; i < parts.length - 1; i++) curOption[parts[i]] = curOption[parts[i]] || {}, 
                curOption = curOption[parts[i]];
                if (key = parts.pop(), 1 === arguments.length) return curOption[key] === undefined ? null : curOption[key];
                curOption[key] = value;
            } else {
                if (1 === arguments.length) return this.options[key] === undefined ? null : this.options[key];
                options[key] = value;
            }
            return this._setOptions(options), this;
        },
        _setOptions: function(options) {
            var key;
            for (key in options) this._setOption(key, options[key]);
            return this;
        },
        _setOption: function(key, value) {
            return this.options[key] = value, "disabled" === key && (this.widget().toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value).attr("aria-disabled", value), 
            this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus")), 
            this;
        },
        enable: function() {
            return this._setOption("disabled", !1);
        },
        disable: function() {
            return this._setOption("disabled", !0);
        },
        _on: function(suppressDisabledCheck, element, handlers) {
            var delegateElement, instance = this;
            "boolean" != typeof suppressDisabledCheck && (handlers = element, element = suppressDisabledCheck, 
            suppressDisabledCheck = !1), handlers ? (element = delegateElement = $(element), 
            this.bindings = this.bindings.add(element)) : (handlers = element, element = this.element, 
            delegateElement = this.widget()), $.each(handlers, function(event, handler) {
                function handlerProxy() {
                    return suppressDisabledCheck || instance.options.disabled !== !0 && !$(this).hasClass("ui-state-disabled") ? ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments) : void 0;
                }
                "string" != typeof handler && (handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++);
                var match = event.match(/^(\w+)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
                selector ? delegateElement.delegate(selector, eventName, handlerProxy) : element.bind(eventName, handlerProxy);
            });
        },
        _off: function(element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, 
            element.unbind(eventName).undelegate(eventName);
        },
        _delay: function(handler, delay) {
            function handlerProxy() {
                return ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },
        _hoverable: function(element) {
            this.hoverable = this.hoverable.add(element), this._on(element, {
                mouseenter: function(event) {
                    $(event.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function(event) {
                    $(event.currentTarget).removeClass("ui-state-hover");
                }
            });
        },
        _focusable: function(element) {
            this.focusable = this.focusable.add(element), this._on(element, {
                focusin: function(event) {
                    $(event.currentTarget).addClass("ui-state-focus");
                },
                focusout: function(event) {
                    $(event.currentTarget).removeClass("ui-state-focus");
                }
            });
        },
        _trigger: function(type, event, data) {
            var prop, orig, callback = this.options[type];
            if (data = data || {}, event = $.Event(event), event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(), 
            event.target = this.element[0], orig = event.originalEvent) for (prop in orig) prop in event || (event[prop] = orig[prop]);
            return this.element.trigger(event, data), !($.isFunction(callback) && callback.apply(this.element[0], [ event ].concat(data)) === !1 || event.isDefaultPrevented());
        }
    }, $.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(method, defaultEffect) {
        $.Widget.prototype["_" + method] = function(element, options, callback) {
            "string" == typeof options && (options = {
                effect: options
            });
            var hasOptions, effectName = options ? options === !0 || "number" == typeof options ? defaultEffect : options.effect || defaultEffect : method;
            options = options || {}, "number" == typeof options && (options = {
                duration: options
            }), hasOptions = !$.isEmptyObject(options), options.complete = callback, options.delay && element.delay(options.delay), 
            hasOptions && $.effects && $.effects.effect[effectName] ? element[method](options) : effectName !== method && element[effectName] ? element[effectName](options.duration, options.easing, callback) : element.queue(function(next) {
                $(this)[method](), callback && callback.call(element[0]), next();
            });
        };
    });
}(jQuery), function($) {
    var mouseHandled = !1;
    $(document).mouseup(function() {
        mouseHandled = !1;
    }), $.widget("ui.mouse", {
        version: "1.10.4",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var that = this;
            this.element.bind("mousedown." + this.widgetName, function(event) {
                return that._mouseDown(event);
            }).bind("click." + this.widgetName, function(event) {
                return !0 === $.data(event.target, that.widgetName + ".preventClickEvent") ? ($.removeData(event.target, that.widgetName + ".preventClickEvent"), 
                event.stopImmediatePropagation(), !1) : void 0;
            }), this.started = !1;
        },
        _mouseDestroy: function() {
            this.element.unbind("." + this.widgetName), this._mouseMoveDelegate && $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
        },
        _mouseDown: function(event) {
            if (!mouseHandled) {
                this._mouseStarted && this._mouseUp(event), this._mouseDownEvent = event;
                var that = this, btnIsLeft = 1 === event.which, elIsCancel = "string" == typeof this.options.cancel && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : !1;
                return btnIsLeft && !elIsCancel && this._mouseCapture(event) ? (this.mouseDelayMet = !this.options.delay, 
                this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function() {
                    that.mouseDelayMet = !0;
                }, this.options.delay)), this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(event) !== !1, 
                !this._mouseStarted) ? (event.preventDefault(), !0) : (!0 === $.data(event.target, this.widgetName + ".preventClickEvent") && $.removeData(event.target, this.widgetName + ".preventClickEvent"), 
                this._mouseMoveDelegate = function(event) {
                    return that._mouseMove(event);
                }, this._mouseUpDelegate = function(event) {
                    return that._mouseUp(event);
                }, $(document).bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate), 
                event.preventDefault(), mouseHandled = !0, !0)) : !0;
            }
        },
        _mouseMove: function(event) {
            return $.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button ? this._mouseUp(event) : this._mouseStarted ? (this._mouseDrag(event), 
            event.preventDefault()) : (this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== !1, 
            this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event)), !this._mouseStarted);
        },
        _mouseUp: function(event) {
            return $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate), 
            this._mouseStarted && (this._mouseStarted = !1, event.target === this._mouseDownEvent.target && $.data(event.target, this.widgetName + ".preventClickEvent", !0), 
            this._mouseStop(event)), !1;
        },
        _mouseDistanceMet: function(event) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
        },
        _mouseDelayMet: function() {
            return this.mouseDelayMet;
        },
        _mouseStart: function() {},
        _mouseDrag: function() {},
        _mouseStop: function() {},
        _mouseCapture: function() {
            return !0;
        }
    });
}(jQuery), function($) {
    var numPages = 5;
    $.widget("ui.slider", $.ui.mouse, {
        version: "1.10.4",
        widgetEventPrefix: "slide",
        options: {
            animate: !1,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: !1,
            step: 1,
            value: 0,
            values: null,
            change: null,
            slide: null,
            start: null,
            stop: null
        },
        _create: function() {
            this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, 
            this._detectOrientation(), this._mouseInit(), this.element.addClass("ui-slider ui-slider-" + this.orientation + " ui-widget ui-widget-content ui-corner-all"), 
            this._refresh(), this._setOption("disabled", this.options.disabled), this._animateOff = !1;
        },
        _refresh: function() {
            this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue();
        },
        _createHandles: function() {
            var i, handleCount, options = this.options, existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"), handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>", handles = [];
            for (handleCount = options.values && options.values.length || 1, existingHandles.length > handleCount && (existingHandles.slice(handleCount).remove(), 
            existingHandles = existingHandles.slice(0, handleCount)), i = existingHandles.length; handleCount > i; i++) handles.push(handle);
            this.handles = existingHandles.add($(handles.join("")).appendTo(this.element)), 
            this.handle = this.handles.eq(0), this.handles.each(function(i) {
                $(this).data("ui-slider-handle-index", i);
            });
        },
        _createRange: function() {
            var options = this.options, classes = "";
            options.range ? (options.range === !0 && (options.values ? options.values.length && 2 !== options.values.length ? options.values = [ options.values[0], options.values[0] ] : $.isArray(options.values) && (options.values = options.values.slice(0)) : options.values = [ this._valueMin(), this._valueMin() ]), 
            this.range && this.range.length ? this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({
                left: "",
                bottom: ""
            }) : (this.range = $("<div></div>").appendTo(this.element), classes = "ui-slider-range ui-widget-header ui-corner-all"), 
            this.range.addClass(classes + ("min" === options.range || "max" === options.range ? " ui-slider-range-" + options.range : ""))) : (this.range && this.range.remove(), 
            this.range = null);
        },
        _setupEvents: function() {
            var elements = this.handles.add(this.range).filter("a");
            this._off(elements), this._on(elements, this._handleEvents), this._hoverable(elements), 
            this._focusable(elements);
        },
        _destroy: function() {
            this.handles.remove(), this.range && this.range.remove(), this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-widget ui-widget-content ui-corner-all"), 
            this._mouseDestroy();
        },
        _mouseCapture: function(event) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle, that = this, o = this.options;
            return o.disabled ? !1 : (this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            }, this.elementOffset = this.element.offset(), position = {
                x: event.pageX,
                y: event.pageY
            }, normValue = this._normValueFromMouse(position), distance = this._valueMax() - this._valueMin() + 1, 
            this.handles.each(function(i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) && (distance = thisDistance, 
                closestHandle = $(this), index = i);
            }), allowed = this._start(event, index), allowed === !1 ? !1 : (this._mouseSliding = !0, 
            this._handleIndex = index, closestHandle.addClass("ui-state-active").focus(), offset = closestHandle.offset(), 
            mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle"), 
            this._clickOffset = mouseOverHandle ? {
                left: 0,
                top: 0
            } : {
                left: event.pageX - offset.left - closestHandle.width() / 2,
                top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
            }, this.handles.hasClass("ui-state-hover") || this._slide(event, index, normValue), 
            this._animateOff = !0, !0));
        },
        _mouseStart: function() {
            return !0;
        },
        _mouseDrag: function(event) {
            var position = {
                x: event.pageX,
                y: event.pageY
            }, normValue = this._normValueFromMouse(position);
            return this._slide(event, this._handleIndex, normValue), !1;
        },
        _mouseStop: function(event) {
            return this.handles.removeClass("ui-state-active"), this._mouseSliding = !1, this._stop(event, this._handleIndex), 
            this._change(event, this._handleIndex), this._handleIndex = null, this._clickOffset = null, 
            this._animateOff = !1, !1;
        },
        _detectOrientation: function() {
            this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal";
        },
        _normValueFromMouse: function(position) {
            var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;
            return "horizontal" === this.orientation ? (pixelTotal = this.elementSize.width, 
            pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (pixelTotal = this.elementSize.height, 
            pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)), 
            percentMouse = pixelMouse / pixelTotal, percentMouse > 1 && (percentMouse = 1), 
            0 > percentMouse && (percentMouse = 0), "vertical" === this.orientation && (percentMouse = 1 - percentMouse), 
            valueTotal = this._valueMax() - this._valueMin(), valueMouse = this._valueMin() + percentMouse * valueTotal, 
            this._trimAlignValue(valueMouse);
        },
        _start: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            return this.options.values && this.options.values.length && (uiHash.value = this.values(index), 
            uiHash.values = this.values()), this._trigger("start", event, uiHash);
        },
        _slide: function(event, index, newVal) {
            var otherVal, newValues, allowed;
            this.options.values && this.options.values.length ? (otherVal = this.values(index ? 0 : 1), 
            2 === this.options.values.length && this.options.range === !0 && (0 === index && newVal > otherVal || 1 === index && otherVal > newVal) && (newVal = otherVal), 
            newVal !== this.values(index) && (newValues = this.values(), newValues[index] = newVal, 
            allowed = this._trigger("slide", event, {
                handle: this.handles[index],
                value: newVal,
                values: newValues
            }), otherVal = this.values(index ? 0 : 1), allowed !== !1 && this.values(index, newVal))) : newVal !== this.value() && (allowed = this._trigger("slide", event, {
                handle: this.handles[index],
                value: newVal
            }), allowed !== !1 && this.value(newVal));
        },
        _stop: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            this.options.values && this.options.values.length && (uiHash.value = this.values(index), 
            uiHash.values = this.values()), this._trigger("stop", event, uiHash);
        },
        _change: function(event, index) {
            if (!this._keySliding && !this._mouseSliding) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                this.options.values && this.options.values.length && (uiHash.value = this.values(index), 
                uiHash.values = this.values()), this._lastChangedValue = index, this._trigger("change", event, uiHash);
            }
        },
        value: function(newValue) {
            return arguments.length ? (this.options.value = this._trimAlignValue(newValue), 
            this._refreshValue(), void this._change(null, 0)) : this._value();
        },
        values: function(index, newValue) {
            var vals, newValues, i;
            if (arguments.length > 1) return this.options.values[index] = this._trimAlignValue(newValue), 
            this._refreshValue(), void this._change(null, index);
            if (!arguments.length) return this._values();
            if (!$.isArray(arguments[0])) return this.options.values && this.options.values.length ? this._values(index) : this.value();
            for (vals = this.options.values, newValues = arguments[0], i = 0; i < vals.length; i += 1) vals[i] = this._trimAlignValue(newValues[i]), 
            this._change(null, i);
            this._refreshValue();
        },
        _setOption: function(key, value) {
            var i, valsLength = 0;
            switch ("range" === key && this.options.range === !0 && ("min" === value ? (this.options.value = this._values(0), 
            this.options.values = null) : "max" === value && (this.options.value = this._values(this.options.values.length - 1), 
            this.options.values = null)), $.isArray(this.options.values) && (valsLength = this.options.values.length), 
            $.Widget.prototype._setOption.apply(this, arguments), key) {
              case "orientation":
                this._detectOrientation(), this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation), 
                this._refreshValue();
                break;

              case "value":
                this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
                break;

              case "values":
                for (this._animateOff = !0, this._refreshValue(), i = 0; valsLength > i; i += 1) this._change(null, i);
                this._animateOff = !1;
                break;

              case "min":
              case "max":
                this._animateOff = !0, this._refreshValue(), this._animateOff = !1;
                break;

              case "range":
                this._animateOff = !0, this._refresh(), this._animateOff = !1;
            }
        },
        _value: function() {
            var val = this.options.value;
            return val = this._trimAlignValue(val);
        },
        _values: function(index) {
            var val, vals, i;
            if (arguments.length) return val = this.options.values[index], val = this._trimAlignValue(val);
            if (this.options.values && this.options.values.length) {
                for (vals = this.options.values.slice(), i = 0; i < vals.length; i += 1) vals[i] = this._trimAlignValue(vals[i]);
                return vals;
            }
            return [];
        },
        _trimAlignValue: function(val) {
            if (val <= this._valueMin()) return this._valueMin();
            if (val >= this._valueMax()) return this._valueMax();
            var step = this.options.step > 0 ? this.options.step : 1, valModStep = (val - this._valueMin()) % step, alignValue = val - valModStep;
            return 2 * Math.abs(valModStep) >= step && (alignValue += valModStep > 0 ? step : -step), 
            parseFloat(alignValue.toFixed(5));
        },
        _valueMin: function() {
            return this.options.min;
        },
        _valueMax: function() {
            return this.options.max;
        },
        _refreshValue: function() {
            var lastValPercent, valPercent, value, valueMin, valueMax, oRange = this.options.range, o = this.options, that = this, animate = this._animateOff ? !1 : o.animate, _set = {};
            this.options.values && this.options.values.length ? this.handles.each(function(i) {
                valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100, 
                _set["horizontal" === that.orientation ? "left" : "bottom"] = valPercent + "%", 
                $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate), that.options.range === !0 && ("horizontal" === that.orientation ? (0 === i && that.range.stop(1, 1)[animate ? "animate" : "css"]({
                    left: valPercent + "%"
                }, o.animate), 1 === i && that.range[animate ? "animate" : "css"]({
                    width: valPercent - lastValPercent + "%"
                }, {
                    queue: !1,
                    duration: o.animate
                })) : (0 === i && that.range.stop(1, 1)[animate ? "animate" : "css"]({
                    bottom: valPercent + "%"
                }, o.animate), 1 === i && that.range[animate ? "animate" : "css"]({
                    height: valPercent - lastValPercent + "%"
                }, {
                    queue: !1,
                    duration: o.animate
                }))), lastValPercent = valPercent;
            }) : (value = this.value(), valueMin = this._valueMin(), valueMax = this._valueMax(), 
            valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0, 
            _set["horizontal" === this.orientation ? "left" : "bottom"] = valPercent + "%", 
            this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate), "min" === oRange && "horizontal" === this.orientation && this.range.stop(1, 1)[animate ? "animate" : "css"]({
                width: valPercent + "%"
            }, o.animate), "max" === oRange && "horizontal" === this.orientation && this.range[animate ? "animate" : "css"]({
                width: 100 - valPercent + "%"
            }, {
                queue: !1,
                duration: o.animate
            }), "min" === oRange && "vertical" === this.orientation && this.range.stop(1, 1)[animate ? "animate" : "css"]({
                height: valPercent + "%"
            }, o.animate), "max" === oRange && "vertical" === this.orientation && this.range[animate ? "animate" : "css"]({
                height: 100 - valPercent + "%"
            }, {
                queue: !1,
                duration: o.animate
            }));
        },
        _handleEvents: {
            keydown: function(event) {
                var allowed, curVal, newVal, step, index = $(event.target).data("ui-slider-handle-index");
                switch (event.keyCode) {
                  case $.ui.keyCode.HOME:
                  case $.ui.keyCode.END:
                  case $.ui.keyCode.PAGE_UP:
                  case $.ui.keyCode.PAGE_DOWN:
                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.RIGHT:
                  case $.ui.keyCode.DOWN:
                  case $.ui.keyCode.LEFT:
                    if (event.preventDefault(), !this._keySliding && (this._keySliding = !0, $(event.target).addClass("ui-state-active"), 
                    allowed = this._start(event, index), allowed === !1)) return;
                }
                switch (step = this.options.step, curVal = newVal = this.options.values && this.options.values.length ? this.values(index) : this.value(), 
                event.keyCode) {
                  case $.ui.keyCode.HOME:
                    newVal = this._valueMin();
                    break;

                  case $.ui.keyCode.END:
                    newVal = this._valueMax();
                    break;

                  case $.ui.keyCode.PAGE_UP:
                    newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / numPages);
                    break;

                  case $.ui.keyCode.PAGE_DOWN:
                    newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / numPages);
                    break;

                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.RIGHT:
                    if (curVal === this._valueMax()) return;
                    newVal = this._trimAlignValue(curVal + step);
                    break;

                  case $.ui.keyCode.DOWN:
                  case $.ui.keyCode.LEFT:
                    if (curVal === this._valueMin()) return;
                    newVal = this._trimAlignValue(curVal - step);
                }
                this._slide(event, index, newVal);
            },
            click: function(event) {
                event.preventDefault();
            },
            keyup: function(event) {
                var index = $(event.target).data("ui-slider-handle-index");
                this._keySliding && (this._keySliding = !1, this._stop(event, index), this._change(event, index), 
                $(event.target).removeClass("ui-state-active"));
            }
        }
    });
}(jQuery), function($) {
    var multiselectID = 0, $doc = $(document);
    $.widget("ech.multiselect", {
        options: {
            header: !0,
            height: 175,
            minWidth: 225,
            classes: "",
            checkAllText: "Check all",
            uncheckAllText: "Uncheck all",
            noneSelectedText: "Select options",
            selectedText: "# selected",
            selectedList: 0,
            show: null,
            hide: null,
            autoOpen: !1,
            multiple: !0,
            position: {},
            appendTo: "body"
        },
        _create: function() {
            var el = this.element.hide(), o = this.options;
            this.speed = $.fx.speeds._default, this._isOpen = !1, this._namespaceID = this.eventNamespace || "multiselect" + multiselectID;
            {
                var button = (this.button = $('<button type="button"><span class="ui-icon ui-icon-triangle-1-s"></span></button>')).addClass("ui-multiselect ui-widget ui-state-default ui-corner-all").addClass(o.classes).attr({
                    title: el.attr("title"),
                    "aria-haspopup": !0,
                    tabIndex: el.attr("tabIndex")
                }).insertAfter(el), menu = ((this.buttonlabel = $("<span />")).html(o.noneSelectedText).appendTo(button), 
                (this.menu = $("<div />")).addClass("ui-multiselect-menu ui-widget ui-widget-content ui-corner-all").addClass(o.classes).appendTo($(o.appendTo))), header = (this.header = $("<div />")).addClass("ui-widget-header ui-corner-all ui-multiselect-header ui-helper-clearfix").appendTo(menu);
                (this.headerLinkContainer = $("<ul />")).addClass("ui-helper-reset").html(function() {
                    return o.header === !0 ? '<li><a class="ui-multiselect-all" href="#"><span class="ui-icon ui-icon-check"></span><span>' + o.checkAllText + '</span></a></li><li><a class="ui-multiselect-none" href="#"><span class="ui-icon ui-icon-closethick"></span><span>' + o.uncheckAllText + "</span></a></li>" : "string" == typeof o.header ? "<li>" + o.header + "</li>" : "";
                }).append('<li class="ui-multiselect-close"><a href="#" class="ui-multiselect-close"><span class="ui-icon ui-icon-circle-close"></span></a></li>').appendTo(header), 
                (this.checkboxContainer = $("<ul />")).addClass("ui-multiselect-checkboxes ui-helper-reset").appendTo(menu);
            }
            this._bindEvents(), this.refresh(!0), o.multiple || menu.addClass("ui-multiselect-single"), 
            multiselectID++;
        },
        _init: function() {
            this.options.header === !1 && this.header.hide(), this.options.multiple || this.headerLinkContainer.find(".ui-multiselect-all, .ui-multiselect-none").hide(), 
            this.options.autoOpen && this.open(), this.element.is(":disabled") && this.disable();
        },
        refresh: function(init) {
            var el = this.element, o = this.options, menu = this.menu, checkboxContainer = this.checkboxContainer, optgroups = [], html = "", id = el.attr("id") || multiselectID++;
            el.find("option").each(function(i) {
                var optLabel, parent = ($(this), this.parentNode), description = this.innerHTML, title = this.title, value = this.value, inputID = "ui-multiselect-" + (this.id || id + "-option-" + i), isDisabled = this.disabled, isSelected = this.selected, labelClasses = [ "ui-corner-all" ], liClasses = (isDisabled ? "ui-multiselect-disabled " : " ") + this.className;
                "OPTGROUP" === parent.tagName && (optLabel = parent.getAttribute("label"), -1 === $.inArray(optLabel, optgroups) && (html += '<li class="ui-multiselect-optgroup-label ' + parent.className + '"><a href="#">' + optLabel + "</a></li>", 
                optgroups.push(optLabel))), isDisabled && labelClasses.push("ui-state-disabled"), 
                isSelected && !o.multiple && labelClasses.push("ui-state-active"), html += '<li class="' + liClasses + '">', 
                html += '<label for="' + inputID + '" title="' + title + '" class="' + labelClasses.join(" ") + '">', 
                html += '<input id="' + inputID + '" name="multiselect_' + id + '" type="' + (o.multiple ? "checkbox" : "radio") + '" value="' + value + '" title="' + title + '"', 
                isSelected && (html += ' checked="checked"', html += ' aria-selected="true"'), isDisabled && (html += ' disabled="disabled"', 
                html += ' aria-disabled="true"'), html += " /><span>" + description + "</span></label></li>";
            }), checkboxContainer.html(html), this.labels = menu.find("label"), this.inputs = this.labels.children("input"), 
            this._setButtonWidth(), this._setMenuWidth(), this.button[0].defaultValue = this.update(), 
            init || this._trigger("refresh");
        },
        update: function() {
            var value, o = this.options, $inputs = this.inputs, $checked = $inputs.filter(":checked"), numChecked = $checked.length;
            return value = 0 === numChecked ? o.noneSelectedText : $.isFunction(o.selectedText) ? o.selectedText.call(this, numChecked, $inputs.length, $checked.get()) : /\d/.test(o.selectedList) && o.selectedList > 0 && numChecked <= o.selectedList ? $checked.map(function() {
                return $(this).next().html();
            }).get().join(", ") : o.selectedText.replace("#", numChecked).replace("#", $inputs.length), 
            this._setButtonValue(value), value;
        },
        _setButtonValue: function(value) {
            this.buttonlabel.text(value);
        },
        _bindEvents: function() {
            function clickHandler() {
                return self[self._isOpen ? "close" : "open"](), !1;
            }
            var self = this, button = this.button;
            button.find("span").bind("click.multiselect", clickHandler), button.bind({
                click: clickHandler,
                keypress: function(e) {
                    switch (e.which) {
                      case 27:
                      case 38:
                      case 37:
                        self.close();
                        break;

                      case 39:
                      case 40:
                        self.open();
                    }
                },
                mouseenter: function() {
                    button.hasClass("ui-state-disabled") || $(this).addClass("ui-state-hover");
                },
                mouseleave: function() {
                    $(this).removeClass("ui-state-hover");
                },
                focus: function() {
                    button.hasClass("ui-state-disabled") || $(this).addClass("ui-state-focus");
                },
                blur: function() {
                    $(this).removeClass("ui-state-focus");
                }
            }), this.header.delegate("a", "click.multiselect", function(e) {
                $(this).hasClass("ui-multiselect-close") ? self.close() : self[$(this).hasClass("ui-multiselect-all") ? "checkAll" : "uncheckAll"](), 
                e.preventDefault();
            }), this.menu.delegate("li.ui-multiselect-optgroup-label a", "click.multiselect", function(e) {
                e.preventDefault();
                var $this = $(this), $inputs = $this.parent().nextUntil("li.ui-multiselect-optgroup-label").find("input:visible:not(:disabled)"), nodes = $inputs.get(), label = $this.parent().text();
                self._trigger("beforeoptgrouptoggle", e, {
                    inputs: nodes,
                    label: label
                }) !== !1 && (self._toggleChecked($inputs.filter(":checked").length !== $inputs.length, $inputs), 
                self._trigger("optgrouptoggle", e, {
                    inputs: nodes,
                    label: label,
                    checked: nodes[0].checked
                }));
            }).delegate("label", "mouseenter.multiselect", function() {
                $(this).hasClass("ui-state-disabled") || (self.labels.removeClass("ui-state-hover"), 
                $(this).addClass("ui-state-hover").find("input").focus());
            }).delegate("label", "keydown.multiselect", function(e) {
                switch (e.preventDefault(), e.which) {
                  case 9:
                  case 27:
                    self.close();
                    break;

                  case 38:
                  case 40:
                  case 37:
                  case 39:
                    self._traverse(e.which, this);
                    break;

                  case 13:
                    $(this).find("input")[0].click();
                }
            }).delegate('input[type="checkbox"], input[type="radio"]', "click.multiselect", function(e) {
                var $this = $(this), val = this.value, checked = this.checked, tags = self.element.find("option");
                return this.disabled || self._trigger("click", e, {
                    value: val,
                    text: this.title,
                    checked: checked
                }) === !1 ? void e.preventDefault() : ($this.focus(), $this.attr("aria-selected", checked), 
                tags.each(function() {
                    this.value === val ? this.selected = checked : self.options.multiple || (this.selected = !1);
                }), self.options.multiple || (self.labels.removeClass("ui-state-active"), $this.closest("label").toggleClass("ui-state-active", checked), 
                self.close()), self.element.trigger("change"), void setTimeout($.proxy(self.update, self), 10));
            }), $doc.bind("mousedown." + this._namespaceID, function(event) {
                var target = event.target;
                !self._isOpen || target === self.button[0] || target === self.menu[0] || $.contains(self.menu[0], target) || $.contains(self.button[0], target) || self.close();
            }), $(this.element[0].form).bind("reset.multiselect", function() {
                setTimeout($.proxy(self.refresh, self), 10);
            });
        },
        _setButtonWidth: function() {
            var width = this.element.outerWidth(), o = this.options;
            /\d/.test(o.minWidth) && width < o.minWidth && (width = o.minWidth), this.button.outerWidth(width);
        },
        _setMenuWidth: function() {
            var m = this.menu;
            m.outerWidth(this.button.outerWidth());
        },
        _traverse: function(which, start) {
            var $start = $(start), moveToLast = 38 === which || 37 === which, $next = $start.parent()[moveToLast ? "prevAll" : "nextAll"]("li:not(.ui-multiselect-disabled, .ui-multiselect-optgroup-label)").first();
            if ($next.length) $next.find("label").trigger("mouseover"); else {
                var $container = this.menu.find("ul").last();
                this.menu.find("label")[moveToLast ? "last" : "first"]().trigger("mouseover"), $container.scrollTop(moveToLast ? $container.height() : 0);
            }
        },
        _toggleState: function(prop, flag) {
            return function() {
                this.disabled || (this[prop] = flag), flag ? this.setAttribute("aria-selected", !0) : this.removeAttribute("aria-selected");
            };
        },
        _toggleChecked: function(flag, group) {
            var $inputs = group && group.length ? group : this.inputs, self = this;
            $inputs.each(this._toggleState("checked", flag)), $inputs.eq(0).focus(), this.update();
            var values = $inputs.map(function() {
                return this.value;
            }).get();
            this.element.find("option").each(function() {
                !this.disabled && $.inArray(this.value, values) > -1 && self._toggleState("selected", flag).call(this);
            }), $inputs.length && this.element.trigger("change");
        },
        _toggleDisabled: function(flag) {
            this.button.attr({
                disabled: flag,
                "aria-disabled": flag
            })[flag ? "addClass" : "removeClass"]("ui-state-disabled");
            var inputs = this.menu.find("input"), key = "ech-multiselect-disabled";
            inputs = flag ? inputs.filter(":enabled").data(key, !0) : inputs.filter(function() {
                return $.data(this, key) === !0;
            }).removeData(key), inputs.attr({
                disabled: flag,
                "arial-disabled": flag
            }).parent()[flag ? "addClass" : "removeClass"]("ui-state-disabled"), this.element.attr({
                disabled: flag,
                "aria-disabled": flag
            });
        },
        open: function() {
            var self = this, button = this.button, menu = this.menu, speed = this.speed, o = this.options, args = [];
            if (this._trigger("beforeopen") !== !1 && !button.hasClass("ui-state-disabled") && !this._isOpen) {
                var $container = menu.find("ul").last(), effect = o.show;
                $.isArray(o.show) && (effect = o.show[0], speed = o.show[1] || self.speed), effect && (args = [ effect, speed ]), 
                $container.scrollTop(0).height(o.height), this.position(), $.fn.show.apply(menu, args), 
                this.labels.filter(":not(.ui-state-disabled)").eq(0).trigger("mouseover").trigger("mouseenter").find("input").trigger("focus"), 
                button.addClass("ui-state-active"), this._isOpen = !0, this._trigger("open");
            }
        },
        close: function() {
            if (this._trigger("beforeclose") !== !1) {
                var o = this.options, effect = o.hide, speed = this.speed, args = [];
                $.isArray(o.hide) && (effect = o.hide[0], speed = o.hide[1] || this.speed), effect && (args = [ effect, speed ]), 
                $.fn.hide.apply(this.menu, args), this.button.removeClass("ui-state-active").trigger("blur").trigger("mouseleave"), 
                this._isOpen = !1, this._trigger("close");
            }
        },
        enable: function() {
            this._toggleDisabled(!1);
        },
        disable: function() {
            this._toggleDisabled(!0);
        },
        checkAll: function() {
            this._toggleChecked(!0), this._trigger("checkAll");
        },
        uncheckAll: function() {
            this._toggleChecked(!1), this._trigger("uncheckAll");
        },
        getChecked: function() {
            return this.menu.find("input").filter(":checked");
        },
        destroy: function() {
            return $.Widget.prototype.destroy.call(this), $doc.unbind(this._namespaceID), this.button.remove(), 
            this.menu.remove(), this.element.show(), this;
        },
        isOpen: function() {
            return this._isOpen;
        },
        widget: function() {
            return this.menu;
        },
        getButton: function() {
            return this.button;
        },
        position: function() {
            var o = this.options;
            if ($.ui.position && !$.isEmptyObject(o.position)) o.position.of = o.position.of || this.button, 
            this.menu.show().position(o.position).hide(); else {
                var pos = this.button.offset();
                this.menu.css({
                    top: pos.top + this.button.outerHeight(),
                    left: pos.left
                });
            }
        },
        _setOption: function(key, value) {
            var menu = this.menu;
            switch (key) {
              case "header":
                menu.find("div.ui-multiselect-header")[value ? "show" : "hide"]();
                break;

              case "checkAllText":
                menu.find("a.ui-multiselect-all span").eq(-1).text(value);
                break;

              case "uncheckAllText":
                menu.find("a.ui-multiselect-none span").eq(-1).text(value);
                break;

              case "height":
                menu.find("ul").last().height(parseInt(value, 10));
                break;

              case "minWidth":
                this.options[key] = parseInt(value, 10), this._setButtonWidth(), this._setMenuWidth();
                break;

              case "selectedText":
              case "selectedList":
              case "noneSelectedText":
                this.options[key] = value, this.update();
                break;

              case "classes":
                menu.add(this.button).removeClass(this.options.classes).addClass(value);
                break;

              case "multiple":
                menu.toggleClass("ui-multiselect-single", !value), this.options.multiple = value, 
                this.element[0].multiple = value, this.refresh();
                break;

              case "position":
                this.position();
            }
            $.Widget.prototype._setOption.apply(this, arguments);
        }
    });
}(jQuery), angular.module("wembliApp", [ "ngRoute", "ngAnimate", "mgcrea.ngStrap", "wembliApp.controllers", "wembliApp.controllers.plan", "wembliApp.controllers.header", "wembliApp.filters", "wembliApp.filters.plan", "wembliApp.services", "wembliApp.services.header", "wembliApp.services.facebook", "wembliApp.services.twitter", "wembliApp.services.pixel", "wembliApp.services.plan", "wembliApp.services.google", "wembliApp.directives", "wembliApp.directives.header", "wembliApp.directives.plan" ]).config([ "$routeProvider", "$locationProvider", function() {} ]).run([ "$timeout", "$rootScope", "initRootScope", "$window", "facebook", "twitter", "plan", "overlay", "planNav", function($timeout, $scope, initRootScope, $window, facebook, twitter, plan, overlay, planNav) {
    overlay.loading(!0), overlay.show(), planNav.onActivate(function() {
        overlay.loading(!1), overlay.hide();
    }), $timeout(function() {
        plan.fetch(function() {});
    }), $window.fbAsyncInit = function() {
        facebook.getLoginStatus(), $scope.facebook = facebook;
    }, twitter.getLoginStatus();
} ]), angular.module("wembliApp.controllers.plan", []).controller("PlanCtrl", [ "$scope", "plan", "planNav", "customer", "overlay", "cart", "notifications", "googlePlaces", "$timeout", "googleAnalytics", function($scope, plan, planNav, customer, overlay, cart, notifications, googlePlaces, $timeout, googleAnalytics) {
    $scope.getPlacePhotoUrl = function(type, idx) {
        var lookup = {
            hotels: "hotel",
            restaurants: "restaurant",
            parking: "parking"
        }, obj = $scope[type][idx], url = "";
        if ("undefined" != typeof obj[lookup[type]].details) {
            if (obj[lookup[type]].details.photos[0].url) return obj[lookup[type]].details.photos[0].url;
            url = obj[lookup[type]].details.photos[0].getUrl({
                maxWidth: 300,
                maxHeight: 300
            }), obj[lookup[type]].details.photos[0].url = url;
        }
        return url;
    }, $scope.buyTickets = function(idx) {
        overlay.show(), $scope.currentTicket = $scope.tickets[idx].ticketGroup, $scope.currentTicketIdx = idx, 
        $scope.buyTicketsOffsite = !0;
    }, $scope.buyParking = function(idx) {
        overlay.show(), $scope.currentParking = $scope.parking[idx].parking, $scope.currentParkingIdx = idx, 
        $scope.buyParkingOffsite = !0;
    }, $scope.buyDeal = function(idx) {
        overlay.show(), $scope.currentDeal = $scope.restaurants[idx].restaurant, $scope.currentDealIdx = idx, 
        $scope.buyDealOffsite = !0;
    }, $scope.buyHotel = function(idx) {
        overlay.show(), $scope.currentHotel = $scope.hotels[idx].hotel, $scope.currentHotelIdx = idx, 
        $scope.buyHotelOffsite = !0;
    }, $scope.removeTicketGroup = function() {
        $timeout(function() {
            $scope.$apply(function() {
                delete $scope.currentTicket, delete $scope.currentTicketIdx, $scope.buyTicketsOffsite = !1, 
                overlay.hide();
            });
        });
    }, $scope.removeParking = function() {
        $timeout(function() {
            $scope.$apply(function() {
                delete $scope.currentParking, delete $scope.currentParkingIdx, $scope.buyParkingOffsite = !1, 
                overlay.hide();
            });
        });
    }, $scope.removeDeal = function() {
        $timeout(function() {
            $scope.$apply(function() {
                delete $scope.currentDeal, delete $scope.currentDealIdx, $scope.buyDealOffsite = !1, 
                overlay.hide();
            });
        });
    }, $scope.removeHotel = function() {
        $timeout(function() {
            $scope.$apply(function() {
                delete $scope.currentHotel, delete $scope.currentHotelIdx, $scope.buyHotelOffsite = !1, 
                overlay.hide();
            });
        });
    }, $scope.boughtTickets = function() {
        if (console.log("set receipt for tix with idx: "), $scope.confirmErr = !1, "undefined" == typeof $scope.currentTicket) return console.log("no currenttixid"), 
        void $scope.removeTicketGroup();
        if (!$scope.confirmPriceQty) return void ($scope.confirmErr = !0);
        if (!$scope.currentTicket.selectedQty) return void ($scope.confirmErr = !0);
        if (!$scope.currentTicket.amountPaid) return void ($scope.confirmErr = !0);
        var ticket = $scope.tickets[$scope.currentTicketIdx], id = ticket._id ? ticket._id : ticket.ID;
        plan.addTicketGroupReceipt({
            ticketId: id,
            service: "tn",
            receipt: {
                transactionToken: ticket.sessionId,
                amountPaid: $scope.currentTicket.amountPaid,
                qty: $scope.currentTicket.selectedQty
            }
        }, function(err, result) {
            console.log("receipt added"), console.log(err, result);
            var t = result.ticket;
            googleAnalytics.trackEvent("Plan", "boughtTickets", $scope.plan.event.eventName, "", function() {
                $timeout(function() {
                    $scope.$apply(function() {
                        $scope.tickets[$scope.currentTicketIdx] = t, $scope.removeTicketGroup();
                    });
                });
            });
        });
    }, $scope.boughtParking = function() {
        if (console.log("set receipt for tix with idx: "), $scope.confirmErr = !1, "undefined" == typeof $scope.currentParking) return console.log("no currenttixid"), 
        void $scope.removeParking();
        if (!$scope.confirmPriceQty) return void ($scope.confirmErr = !0);
        if (!$scope.currentParking.selectedQty) return void ($scope.confirmErr = !0);
        if (!$scope.currentParking.amountPaid) return void ($scope.confirmErr = !0);
        var parking = $scope.parking[$scope.currentParkingIdx], id = parking._id;
        plan.addParkingReceipt({
            parkingId: id,
            service: "pw",
            receipt: {
                amountPaid: $scope.currentParking.amountPaid,
                qty: $scope.currentParking.selectedQty
            }
        }, function(err, result) {
            console.log("receipt added"), console.log(err, result);
            var p = result.parking;
            googleAnalytics.trackEvent("Plan", "boughtParking", $scope.plan.event.eventName, "", function() {
                $timeout(function() {
                    $scope.$apply(function() {
                        $scope.parking[$scope.currentParkingIdx] = p, $scope.removeParking();
                    });
                });
            });
        });
    }, $scope.boughtDeal = function() {
        if (console.log("set receipt for deal with idx: "), $scope.confirmErr = !1, "undefined" == typeof $scope.currentDeal) return console.log("no currenttixid"), 
        void $scope.removeDeal();
        if (!$scope.confirmPriceQty) return void ($scope.confirmErr = !0);
        if (!$scope.currentDeal.selectedQty) return void ($scope.confirmErr = !0);
        if (!$scope.currentDeal.amountPaid) return void ($scope.confirmErr = !0);
        var deal = $scope.restaurants[$scope.currentDealIdx], id = deal._id;
        plan.addRestaurantReceipt({
            restaurantId: id,
            service: "yipit",
            receipt: {
                amountPaid: $scope.currentDeal.amountPaid,
                qty: $scope.currentDeal.selectedQty
            }
        }, function(err, result) {
            console.log("receipt added"), console.log(err, result);
            var d = result.restaurant;
            googleAnalytics.trackEvent("Plan", "boughtDeal", $scope.plan.event.eventName, "", function() {
                $timeout(function() {
                    $scope.$apply(function() {
                        $scope.restaurants[$scope.currentDealIdx] = d, $scope.removeDeal();
                    });
                });
            });
        });
    }, $scope.boughtHotel = function() {
        $scope.removeHotel();
    }, $scope.$on("overlay-clicked", function() {
        $scope.removeTicketGroup(), $scope.removeParking(), $scope.removeDeal(), $scope.removeHotel(), 
        console.log("overlay clicked");
    }), $scope.activateSection = function(sectionName) {
        console.log("activateSection " + sectionName);
        var sectionName = sectionName.split("-")[2];
        planNav.activate(sectionName), googleMap.resize();
    }, $scope.friendsPonyUp = function(friends) {
        for (var tickets = plan.getTickets(), parking = plan.getParking(), restaurants = plan.getRestaurants(), i = 0; i < friends.length; i++) {
            if (friends[i].suggestedPonyUpAmount = 0, "undefined" != typeof tickets[0] && "undefined" != typeof tickets[0].costBreakdown) {
                "undefined" == typeof friends[i].tickets && (friends[i].tickets = {}), friends[i].tickets = tickets[0];
                var suggested = friends[i].tickets.costBreakdown.totalEach * (friends[i].rsvp.guestCount + 1) + friends[i].tickets.costBreakdown.deliveryFeeEach;
                friends[i].tickets.suggestedPonyUpAmount = suggested.toFixed(2), friends[i].suggestedPonyUpAmount += parseFloat(suggested);
            } else friends[i].tickets = [];
            if ("undefined" != typeof parking[0] && "undefined" != typeof parking[0].costBreakdown) {
                friends[i].parking = parking[0];
                var suggested = friends[i].parking.costBreakdown.totalEach * (friends[i].rsvp.guestCount + 1);
                friends[i].parking.suggestedPonyUpAmount = suggested.toFixed(2), friends[i].suggestedPonyUpAmount += parseFloat(suggested);
            } else friends[i].parking = [];
            if ("undefined" != typeof restaurants[0] && "undefined" != typeof restaurants[0].costBreakdown) {
                friends[i].restaurants = restaurants[0];
                var suggested = friends[i].restaurants.costBreakdown.totalEach * (friends[i].rsvp.guestCount + 1);
                friends[i].restaurants.suggestedPonyUpAmount = suggested.toFixed(2), friends[i].suggestedPonyUpAmount += parseFloat(suggested);
            } else friends[i].restaurants = [];
            friends[i].suggestedPonyUpAmount = parseFloat(friends[i].suggestedPonyUpAmount).toFixed(2);
        }
        return friends;
    }, $scope.calcTotalComing = function() {
        if ($scope.totalComing = 0, $scope.totalInvited = 0, $scope.friendsComing = [], 
        $scope.totalPoniedUp = 0, $scope.friends) {
            for (var i = 0; i < $scope.friends.length; i++) if ($scope.friends[i].customerId !== customer.get().id) {
                if ($scope.friends[i].inviteStatus && ($scope.totalInvited = parseInt($scope.totalInvited) + 1, 
                $scope.friends[i].rsvp.decision)) {
                    $scope.totalComing = parseInt($scope.totalComing) + parseInt($scope.friends[i].rsvp.guestCount) + 1, 
                    $scope.friendsComing.push($scope.friends[i]), $scope.friends[i].totalPoniedUp = 0;
                    for (var j = 0; j < $scope.friends[i].payment.length; j++) {
                        var p = $scope.friends[i].payment[j];
                        "request" !== p.type && ($scope.friends[i].totalPoniedUp += p.amount);
                    }
                    $scope.totalPoniedUp += parseInt($scope.friends[i].totalPoniedUp);
                }
            } else $scope.me.rsvp.decision && ($scope.totalComing = parseInt($scope.totalComing) + parseInt($scope.me.rsvp.guestCount) + 1, 
            $scope.friendsComing.push($scope.me), $scope.friends[i] = $scope.me), $scope.totalInvited = parseInt($scope.totalInvited) + 1;
            $scope.plan.organizer.rsvp.decision && ($scope.totalInvited = parseInt($scope.totalInvited) + 1, 
            $scope.totalComing = parseInt($scope.totalComing) + parseInt($scope.plan.organizer.rsvp.guestCount) + 1), 
            console.log("total coming: " + $scope.totalComing);
        }
    }, $scope.setSelectedQty = function() {
        angular.forEach($scope.tickets, function(t) {
            "undefined" == typeof t.ticketGroup.selectedQty && (angular.forEach(t.ticketGroup.ValidSplits.int, function(split) {
                split == $scope.totalComing && (t.ticketGroup.selectedQty = parseInt(split));
            }), "undefined" == typeof t.ticketGroup.selectedQty && (console.log("using last split"), 
            t.ticketGroup.selectedQty = parseInt(t.ticketGroup.ValidSplits.int[t.ticketGroup.ValidSplits.int.length - 1])), 
            console.log("selected qty: " + t.ticketGroup.selectedQty)), t.ticketGroup.selectedQty > $scope.totalComing && (t.ticketGroup.selectedQty = $scope.totalComing);
        });
    }, $scope.reconcileTicketQty = function() {
        if ("undefined" != typeof $scope.tickets) {
            for (var sum = 0, i = 0; i < $scope.tickets.length; i++) {
                var t = $scope.tickets[i];
                sum += parseInt(t.ticketGroup.selectedQty);
            }
            sum > 0 && ($scope.ticketCountMismatch = !0, console.log("there are " + sum + " tickets selected"), 
            console.log("there are " + $scope.totalComing + " people coming"), sum >= $scope.totalComing && (console.log("ticketcount mismatch is false"), 
            $scope.ticketCountMismatch = !1));
        }
    }, $scope.acknowledgeNotification = function(key) {
        plan.acknowledgeNotification(key);
    }, $scope.serviceFee = function(price) {
        return .15 * price;
    }, $scope.showEllipses = function(ary, len) {
        return "undefined" != typeof ary ? ary.join(", ").length > len : void 0;
    }, $scope.$watch("restaurants", function(newVal, oldVal) {
        "undefined" != typeof newVal && oldVal !== newVal && (cart.totals("restaurants"), 
        $scope.friendsPonyUp($scope.friends));
    }), $scope.$watch("hotels", function(newVal, oldVal) {
        "undefined" != typeof newVal && oldVal !== newVal && (angular.forEach(newVal, function(h) {
            "google" === h.service && googlePlaces.getDetails(h.hotel.reference, function(place) {
                h.hotel.details = place;
            });
        }), cart.totals("hotels"), $scope.friendsPonyUp($scope.friends));
    }), $scope.$watch("parking", function(newVal, oldVal) {
        "undefined" != typeof newVal && oldVal !== newVal && (angular.forEach(newVal, function(p) {
            "google" === p.service && googlePlaces.getDetails(p.parking.reference, function(place) {
                p.parking.details = place;
            });
        }), $scope.friendsPonyUp($scope.friends), cart.totals("parking"));
    }), $scope.$watch("tickets", function(newVal, oldVal) {
        "undefined" != typeof newVal && oldVal !== newVal && (cart.totals("tickets"), $scope.friendsPonyUp($scope.friends), 
        $scope.setSelectedQty());
    }), $scope.$watch("rsvpCompleteNotification", function(n) {
        "undefined" != typeof n && notifications.update();
    }), $scope.$watch("plan", function(p) {
        "undefined" != typeof p && (plan.rsvpComplete(function(complete) {
            !p.rsvpComplete && complete && plan.submitRsvpComplete(!0, function(err, result) {
                $scope.plan.rsvpComplete = result.plan.rsvpComplete, $scope.plan.rsvpCompleteDate = result.plan.rsvpCompleteDate, 
                $scope.rsvpCompleteNotification = !0;
            });
        }), angular.forEach(p.notifications, function(n) {
            "rsvpComplete" === n.key && ($scope.rsvpCompleteNotification = !0);
        }));
    }), plan.get(function(p) {
        $scope.plan = p, $scope.organizer = plan.getOrganizer(), $scope.tickets = plan.getTickets(), 
        $scope.parking = plan.getParking(), $scope.hotels = plan.getHotels(), $scope.restaurants = plan.getRestaurants(), 
        $scope.friends = plan.getFriends(), $scope.context = plan.getContext(), console.log("GETTING PLAN INFO:"), 
        console.log("plan:"), console.log($scope.plan), console.log("organizer"), console.log($scope.organizer), 
        console.log("tickets"), console.log($scope.tickets), console.log("friends"), console.log($scope.friends), 
        console.log("parking"), console.log($scope.parking), console.log("restaurants"), 
        console.log($scope.restaurants), console.log("hotels"), console.log($scope.hotels), 
        console.log("context"), console.log($scope.context), console.log("customer"), console.log($scope.customer);
        for (var i = 0; i < $scope.friends.length; i++) $scope.friends[i].customerId === customer.get().id && ($scope.me = $scope.friends[i]);
        $scope.calcTotalComing(), $scope.setSelectedQty(), $scope.reconcileTicketQty(), 
        $scope.friendsPonyUp($scope.friends), $scope.canRequestPonyUp = $scope.friendsComing && $scope.friendsComing.length > 0;
    });
} ]).controller("OrganizerPlanCtrl", [ "$scope", "cart", "plan", "$location", "wembliRpc", "overlay", "ticketPurchaseUrls", function($scope, cart, plan, $location, wembliRpc, overlay, ticketPurchaseUrls) {
    $scope.tnUrl = ticketPurchaseUrls.tn, $scope.$watch("plan.tickets[0].ticketGroup.selectedQty", function() {
        "undefined" != typeof newVal && oldVal !== newVal && (cart.totals("tickets"), $scope.friendsPonyUp($scope.friends), 
        $scope.reconcileTicketQty());
    }), $scope.setPayment = function(addOn, value) {
        $scope.plan.preferences[addOn].payment = value, $scope.savePrefs(function() {
            var path = "/" + addOn + "/" + $scope.plan.event.eventId + "/" + $scope.plan.event.eventName;
            $location.path(path);
        });
    }, $scope.removeTicketGroup = function(ticketId) {
        wembliRpc.fetch("plan.removeTicketGroup", {
            ticketId: ticketId
        }, function(err, result) {
            $scope.tickets = plan.setTickets(result.tickets), $scope.plan = result.plan;
        });
    };
    var savePrefs = function(n, o) {
        "undefined" != typeof n && "undefined" != typeof o && n !== o && (console.log("saving prefs"), 
        plan.savePreferences({
            preferences: $scope.plan.preferences
        }, function(err, result) {
            console.log(result), $scope.calcTotalComing();
        }));
    };
    $scope.$watch("plan.preferences.inviteOptions.guestFriends", savePrefs), $scope.$watch("plan.preferences.inviteOptions.over21", savePrefs), 
    $scope.$watch("plan.preferences.guestList", savePrefs), $scope.$watch("plan.preferences.addOns.parking", savePrefs), 
    $scope.$watch("plan.preferences.addOns.hotels", savePrefs), $scope.$watch("plan.preferences.addOns.restaurants", savePrefs);
} ]).controller("OrganizerRsvpCtrl", [ "$rootScope", "$scope", "plan", "planNav", "wembliRpc", function($rootScope, $scope, plan, planNav, wembliRpc) {
    var makeRsvpDays = function() {
        var rsvpTime = new Date($scope.plan.rsvpDate).getTime(), now = new Date().getTime(), difference = rsvpTime - now, hour = 36e5, day = 24 * hour;
        if (difference > 0) if (day > difference) $scope.rsvpDays = "That's today!"; else {
            var days = difference / day;
            if (14 > days) {
                var d = 1 == parseInt(days) ? "day" : "days";
                $scope.rsvpDays = "That's in " + parseInt(days) + " " + d + "!";
            }
        } else $scope.plan.rsvpComplete && ($scope.rsvpDays = "RSVP Date has passed.");
    };
    $scope.guestCountKeyUp = function() {
        "" !== $scope.plan.organizer.rsvp.guestCount && ($scope.calcTotalComing(), wembliRpc.fetch("plan.submitOrganizerRsvp", {
            decision: $scope.plan.organizer.rsvp.decision,
            guestCount: $scope.plan.organizer.rsvp.guestCount
        }, function() {}));
    }, $scope.guestCountKeyDown = function($scope, elm, attr, e) {
        38 == e.keyCode && $scope.plan.organizer.rsvp.guestCount++, 40 == e.keyCode && ($scope.plan.organizer.rsvp.guestCount--, 
        $scope.plan.organizer.rsvp.guestCount < 0 && ($scope.plan.organizer.rsvp.guestCount = 0));
    }, $scope.setRsvp = function(rsvp) {
        $scope.plan.organizer.rsvp.decision = rsvp, $scope.plan.organizer.rsvp.decision === !1 && ($scope.plan.organizer.rsvp.guestCount = 0), 
        $scope.plan.organizer.rsvp.decision === !0 && 0 == $scope.plan.organizer.rsvp.guestCount && ($scope.plan.organizer.rsvp.guestCount = 1), 
        $scope.calcTotalComing(), wembliRpc.fetch("plan.submitOrganizerRsvp", {
            decision: $scope.plan.organizer.rsvp.decision,
            guestCount: $scope.plan.organizer.rsvp.guestCount
        }, function() {});
    }, $scope.$watch("plan", function(p) {
        "undefined" != typeof p && (makeRsvpDays(), null === $scope.plan.organizer.rsvp.decision && $scope.setRsvp(!0));
    }), planNav.activate("rsvp");
} ]).controller("OrganizerCartCtrl", [ "$scope", "plan", "planNav", function($scope, plan, planNav) {
    $scope.parkingSpotsNeeded = 1, $scope.totalComing > 3 && ($scope.parkingSpotsNeeded = Math.ceil($scope.totalComing / 3)), 
    planNav.activate("cart"), $scope.$watch("buyTicketsOffsite", function(n) {
        console.log("buyTicketsOffsite: " + n);
    }), $scope.showChangeTicketsLink = function() {
        plan.get(function(p) {
            return p.tickets && p.tickets.length > 0;
        });
    }, $scope.showTicketPriceDetails = {}, $scope.toggleTicketPriceDetails = function(ticketId) {
        "undefined" == typeof $scope.showTicketPriceDetails[ticketId] ? $scope.showTicketPriceDetails[ticketId] = !0 : delete $scope.showTicketPriceDetails[ticketId];
    };
} ]).controller("OrganizerPonyUpCtrl", [ "$rootScope", "$scope", "plan", "planNav", "wembliRpc", "customer", function($rootScope, $scope, plan, planNav, wembliRpc, customer) {
    $scope.needBalancedAccount = !1, $scope.showSuggestedAmount = {}, $scope.toggleSuggestedAmounts = function(friendId) {
        "undefined" == typeof $scope.showSuggestedAmount[friendId] ? $scope.showSuggestedAmount[friendId] = !0 : delete $scope.showSuggestedAmount[friendId];
    }, $scope.showHistory = {}, $scope.toggleHistory = function(friendId) {
        "undefined" == typeof $scope.showHistory[friendId] ? $scope.showHistory[friendId] = !0 : delete $scope.showHistory[friendId];
    }, $scope.submitOutsidePayment = function(friendId) {
        angular.forEach($scope.friends, function(f) {
            if (f._id == friendId) {
                if (!f.ponyUp.outsideSourceAmount || 0 == parseFloat(f.ponyUp.outsideSourceAmount)) return;
                f.ponyUp.submitInProgress = !0, wembliRpc.fetch("plan.submitOutsidePayment", {
                    friendId: friendId,
                    amount: parseInt(100 * parseFloat(f.ponyUp.outsideSourceAmount)),
                    method: f.ponyUp.outsideSourcePaymentMethod,
                    status: "logged"
                }, function(err, result) {
                    if (!err) {
                        if (!result.success) return void (f.error = !0);
                        f.ponyUp.submitInProgress = !1, f.payment = result.friend.payment, $rootScope.$broadcast("plan-friends-changed", plan.getFriends()), 
                        $scope.paymentTotals();
                    }
                });
            }
        });
    }, $scope.removeOutsidePayment = function(friendId, paymentId) {
        for (var i = 0; i < $scope.friends.length; i++) {
            var f = $scope.friends[i];
            if (f._id === friendId) for (var l = f.payment.length, j = 0; l > j; j++) {
                var p = f.payment.shift();
                p._id === paymentId ? (p.removeOutsidePaymentInProgress = !0, wembliRpc.fetch("plan.removeOutsidePayment", {
                    friendId: f._id,
                    paymentId: p._id
                }, function(err, result) {
                    return err ? (p.error = !0, void f.payment.push(p)) : result.success ? (p.removeOutsidePaymentInProgress = !1, 
                    void $scope.paymentTotals()) : (p.error = !0, void f.payment.push(p));
                })) : f.payment.push(p);
            }
        }
    }, $scope.cancelPonyUpRequest = function(friendId, paymentId) {
        for (var i = 0; i < $scope.friends.length; i++) {
            var f = $scope.friends[i];
            if (f._id === friendId) for (var l = f.payment.length, j = 0; l > j; j++) {
                var p = f.payment.shift();
                p._id === paymentId ? (p.cancelPonyUpRequestInProgress = !0, wembliRpc.fetch("plan.cancelPonyUpRequest", {
                    friendId: f._id,
                    paymentId: p._id
                }, function(err, result) {
                    return err ? (p.error = !0, void f.payment.push(p)) : result.success ? (f.payment.push(result.payment), 
                    p.cancelPonyUpRequestInProgress = !1, void $scope.paymentTotals()) : (p.error = !0, 
                    void f.payment.push(p));
                })) : f.payment.push(p);
            }
        }
    }, $scope.resendPonyUp = function(friendId, paymentId) {
        for (var i = 0; i < $scope.friends.length; i++) {
            var f = $scope.friends[i];
            f._id === friendId && angular.forEach(f.payment, function(p) {
                p._id === paymentId && (p.resendPonyUpInProgress = !0, wembliRpc.fetch("plan.resendPonyUpEmail", {
                    friendId: f._id,
                    paymentId: p._id,
                    amount: parseInt(100 * p.amount)
                }, function(err, result) {
                    return err ? void (p.error = !0) : result.success ? (p.status = result.payment.status, 
                    p.date = result.payment.date, p.resendPonyUpInProgress = !1, void (p.resent = !0)) : void (p.error = !0);
                }));
            });
        }
    }, $scope.sendPonyUpEmail = function() {
        if ("undefined" == typeof customer.get().balancedAPI || "undefined" == typeof customer.get().balancedAPI.bankAccounts || "undefined" == typeof customer.get().balancedAPI.bankAccounts.items[0]) return console.log("create balanced account"), 
        void ($scope.needBalancedAccount = !0);
        if (!$scope.sendPonyUpInProgress) {
            $scope.sendPonyUpInProgress = !0, $scope.error = $scope.formError = $scope.success = !1;
            for (var ponyUpRequests = [], i = 0; i < $scope.friends.length; i++) {
                var f = $scope.friends[i];
                if ("undefined" != typeof f.ponyUp.amount && f.ponyUp.request) {
                    if (!(parseFloat(f.ponyUp.amount) > 0)) return $scope.error = !1, $scope.success = !1, 
                    $scope.formError = !0, void ($scope.sendPonyUpInProgress = !1);
                    var d = {
                        friendId: f._id,
                        amount: parseInt(100 * parseFloat(f.ponyUp.amount))
                    };
                    ponyUpRequests.push(d);
                }
            }
            if (!ponyUpRequests[0]) return $scope.error = !1, $scope.success = !1, $scope.formError = !0, 
            void ($scope.sendPonyUpInProgress = !1);
            console.log("sending pony up requests"), console.log(ponyUpRequests), wembliRpc.fetch("plan.sendPonyUpEmail", {
                ponyUpRequests: ponyUpRequests
            }, function(err, result) {
                if ($scope.sendPonyUpInProgress = !1, err) return void ($scope.error = !0);
                if (!result.success) return void ($scope.error = !0);
                $scope.success = !0;
                for (var i = 0; i < $scope.friends.length; i++) for (var f = $scope.friends[i], j = 0; j < result.friends.length; j++) {
                    var f2 = result.friends[j];
                    f2._id === f._id && (f.payment = f2.payment);
                }
                $rootScope.$broadcast("plan-friends-changed", plan.getFriends()), $scope.paymentTotals();
            });
        }
    };
    var dereg = $scope.$on("bank-account-created", function() {
        $scope.needBalancedAccount = !1, $scope.sendPonyUpEmail(), dereg();
    });
    $scope.paymentTotals = function() {
        for (var i = 0; i < $scope.friends.length; i++) {
            var requested = 0, received = 0, f = $scope.friends[i];
            f.ponyUp = "undefined" == typeof f.ponyUp ? {} : f.ponyUp, f.ponyUp.open = !1, f.ponyUp.request = !0;
            for (var j = 0; j < f.payment.length; j++) {
                var p = f.payment[j];
                console.log(f.payment), "request" == p.type ? (p.open && (f.ponyUp.open = !0, f.ponyUp.request = !1), 
                "canceled" !== p.status && (requested += parseInt(p.amount), p.amount = parseInt(p.amount))) : received += parseInt(p.amount);
            }
            f.payment.requested = requested, f.payment.received = received, f.payment.balance = requested - received;
        }
    }, $scope.$watch("friends", function(newVal) {
        newVal && $scope.paymentTotals();
    }), planNav.activate("pony-up");
} ]).controller("OrganizerItineraryCtrl", [ "$scope", "plan", "planNav", "wembliRpc", function($scope, plan, planNav, wembliRpc) {
    var timer;
    $scope.submitNotes = function() {
        clearTimeout(timer), timer = setTimeout(function() {
            wembliRpc.fetch("plan.submitNotes", {
                notes: $scope.plan.notes
            }, function() {});
        }, 2e3);
    }, planNav.activate("itinerary");
} ]).controller("OrganizerChatterCtrl", [ "$scope", "plan", "planNav", function($scope, plan, planNav) {
    planNav.activate("chatter");
} ]).controller("FriendPlanCtrl", [ "$scope", "plan", "$location", "wembliRpc", function() {
    console.log("friend plan ctrl");
} ]).controller("FriendRsvpCtrl", [ "$scope", "plan", "planNav", "wembliRpc", function($scope, plan, planNav, wembliRpc) {
    console.log("friend rsvp ctrl"), $scope.setRsvp = function(rsvp) {
        $scope.me.rsvp.decision = rsvp, $scope.me.rsvp.decision === !1 && ($scope.me.rsvp.guestCount = 0), 
        $scope.me.rsvp.decision === !0 && 0 == $scope.me.rsvp.guestCount && ($scope.me.rsvp.guestCount = 1), 
        wembliRpc.fetch("friend.submitRsvp", {
            decision: $scope.me.rsvp.decision,
            guestCount: $scope.me.rsvp.guestCount
        }, function(err, result) {
            $scope.me = result.friend;
        });
    }, $scope.guestCountKeyUp = function() {
        "" !== $scope.me.rsvp.guestCount && ($scope.calcTotalComing(), wembliRpc.fetch("friend.submitRsvp", {
            decision: $scope.me.rsvp.decision,
            guestCount: $scope.me.rsvp.guestCount
        }, function(err, result) {
            $scope.me = result.friend;
        }));
    }, $scope.guestCountKeyDown = function($scope, elm, attr, e) {
        38 == e.keyCode && $scope.me.rsvp.guestCount++, 40 == e.keyCode && ($scope.me.rsvp.guestCount--, 
        $scope.me.rsvp.guestCount < 0 && ($scope.me.rsvp.guestCount = 0));
    }, planNav.activate("rsvp");
} ]).controller("FriendVoteCtrl", [ "$scope", "plan", "planNav", "wembliRpc", function($scope, plan, planNav, wembliRpc) {
    var submitVote = function() {
        wembliRpc.fetch("friend.submitVote", {
            tickets: {
                number: $scope.me.rsvp.guestCount,
                decision: $scope.me.rsvp.decision,
                price: $scope.me.rsvp.tickets.price,
                priceGroup: $scope.me.rsvp.tickets.priceGroup
            },
            parking: {
                number: $scope.me.rsvp.guestCount,
                decision: $scope.me.rsvp.parking.decision,
                price: $scope.me.rsvp.parking.price,
                priceGroup: $scope.me.rsvp.parking.priceGroup
            },
            restaurant: {
                number: $scope.me.rsvp.guestCount,
                decision: $scope.me.rsvp.restaurant.decision,
                price: $scope.me.rsvp.restaurant.price,
                priceGroup: $scope.me.rsvp.restaurant.priceGroup,
                preference: $scope.me.rsvp.restaurant.preference
            },
            hotel: {
                number: $scope.me.rsvp.guestCount,
                decision: $scope.me.rsvp.hotel.decision,
                price: $scope.me.rsvp.hotel.price,
                priceGroup: $scope.me.rsvp.hotel.priceGroup,
                preference: $scope.me.rsvp.hotel.preference
            }
        }, function(err, result) {
            $scope.me = result.friend;
        });
    }, calcVotePriceTotal = function() {
        var total = 0;
        parseInt($scope.me.rsvp.tickets.price) > 0 && (total += parseInt($scope.me.rsvp.tickets.price)), 
        $scope.plan.preferences.addOns.parking && parseInt($scope.me.rsvp.parking.price) > 0 && (total += parseInt($scope.me.rsvp.parking.price)), 
        $scope.plan.preferences.addOns.restaurants && parseInt($scope.me.rsvp.restaurant.price) > 0 && (total += parseInt($scope.me.rsvp.restaurant.price)), 
        $scope.plan.preferences.addOns.hotels && parseInt($scope.me.rsvp.hotel.price) > 0 && (total += parseInt($scope.me.rsvp.hotel.price)), 
        $scope.votePriceTotalPerPerson = total, $scope.votePriceTotal = total * $scope.me.rsvp.tickets.number;
    };
    $scope.$watch("me.rsvp.parking.decision", function(val) {
        "undefined" != typeof val && submitVote();
    }), $scope.$watch("me.rsvp.restaurant.decision", function(val) {
        "undefined" != typeof val && submitVote();
    }), $scope.$watch("me.rsvp.hotel.decision", function(val) {
        "undefined" != typeof val && submitVote();
    }), $scope.$watch("me.rsvp.tickets.price", function(val) {
        "undefined" != typeof val && calcVotePriceTotal();
    }), $scope.$watch("me.rsvp.parking.price", function(val) {
        "undefined" != typeof val && calcVotePriceTotal();
    }), $scope.$watch("me.rsvp.restaurant.price", function(val) {
        "undefined" != typeof val && calcVotePriceTotal();
    }), $scope.$watch("me.rsvp.hotel.price", function(val) {
        "undefined" != typeof val && calcVotePriceTotal();
    });
    var toggleSlider = function(id, val) {
        $(id).slider(val ? "enable" : "disable");
    }, toggleMultiselect = function(id, val) {
        $(id).multiselect(val ? "enable" : "disable");
    };
    $scope.toggleInputs = function(category, val) {
        var categories = {
            restaurant: function(val) {
                toggleSlider("#restaurant-price-slider", val), toggleMultiselect("#food-preference", val);
            },
            parking: function(val) {
                toggleSlider("#parking-price-slider", val);
            },
            hotel: function(val) {
                toggleSlider("#hotel-price-slider", val), toggleMultiselect("#hotel-preference", val);
            }
        };
        categories[category](val);
    }, $scope.foodPreferenceClick = function(event, ui) {
        if ("undefined" == typeof $scope.me.rsvp.restaurant.preference && ($scope.me.rsvp.restaurant.preference = []), 
        ui.checked) $scope.me.rsvp.restaurant.preference.push(ui.value); else {
            for (var n = [], i = 0; i < $scope.me.rsvp.restaurant.preference.length; i++) {
                var p = $scope.me.rsvp.restaurant.preference[i];
                p !== ui.value && n.push(p);
            }
            $scope.me.rsvp.restaurant.preference = n;
        }
        submitVote();
    }, $scope.hotelPreferenceClick = function(event, ui) {
        if ("undefined" == typeof $scope.me.rsvp.hotel.preference && ($scope.me.rsvp.hotel.preference = []), 
        ui.checked) $scope.me.rsvp.hotel.preference.push(ui.value); else {
            for (var n = [], i = 0; i < $scope.me.rsvp.hotel.preference.length; i++) {
                var p = $scope.me.rsvp.hotel.preference[i];
                p !== ui.value && n.push(p);
            }
            $scope.me.rsvp.hotel.preference = n;
        }
        submitVote();
    }, $scope.ticketsPriceSlide = function(event, ui) {
        $scope.me.rsvp.tickets.price = ui.value, ui.value > 0 && ($scope.me.rsvp.tickets.priceGroup.low = !0), 
        ui.value > 100 && ($scope.me.rsvp.tickets.priceGroup.med = !0), ui.value > 300 && ($scope.me.rsvp.tickets.priceGroup.high = !0), 
        ui.value <= 100 && ($scope.me.rsvp.tickets.priceGroup.med = !1), ui.value <= 300 && ($scope.me.rsvp.tickets.priceGroup.high = !1);
    }, $scope.ticketsPriceStop = function() {
        submitVote();
    }, $scope.parkingPriceSlide = function(event, ui) {
        $scope.me.rsvp.parking.price = ui.value, ui.value > 0 && ($scope.me.rsvp.parking.priceGroup.low = !0), 
        ui.value > 25 && ($scope.me.rsvp.parking.priceGroup.med = !0), ui.value > 50 && ($scope.me.rsvp.parking.priceGroup.high = !0), 
        ui.value <= 25 && ($scope.me.rsvp.parking.priceGroup.med = !1), ui.value <= 50 && ($scope.me.rsvp.parking.priceGroup.high = !1);
    }, $scope.parkingPriceStop = function() {
        submitVote();
    }, $scope.restaurantPriceSlide = function(event, ui) {
        $scope.me.rsvp.restaurant.price = ui.value, ui.value > 0 && ($scope.me.rsvp.restaurant.priceGroup.low = !0), 
        ui.value > 25 && ($scope.me.rsvp.restaurant.priceGroup.med = !0), ui.value > 50 && ($scope.me.rsvp.restaurant.priceGroup.high = !0), 
        ui.value <= 25 && ($scope.me.rsvp.restaurant.priceGroup.med = !1), ui.value <= 50 && ($scope.me.rsvp.restaurant.priceGroup.high = !1);
    }, $scope.restaurantPriceStop = function() {
        submitVote();
    }, $scope.hotelPriceSlide = function(event, ui) {
        $scope.me.rsvp.hotel.price = ui.value, ui.value > 0 && ($scope.me.rsvp.hotel.priceGroup.low = !0), 
        ui.value > 100 && ($scope.me.rsvp.hotel.priceGroup.med = !0), ui.value > 300 && ($scope.me.rsvp.hotel.priceGroup.high = !0), 
        ui.value <= 100 && ($scope.me.rsvp.hotel.priceGroup.med = !1), ui.value <= 300 && ($scope.me.rsvp.hotel.priceGroup.high = !1);
    }, $scope.hotelPriceStop = function() {
        submitVote();
    };
    var watchMe = function() {
        $scope.toggleInputs("parking", $scope.me.rsvp.parking.decision), $scope.toggleInputs("restaurant", $scope.me.rsvp.restaurant.decision), 
        $scope.toggleInputs("hotel", $scope.me.rsvp.hotel.decision);
    };
    if ($scope.me) watchMe(); else var d = $scope.$watch("me", function(newVal) {
        "undefined" != typeof newVal && (watchMe(), d());
    });
    planNav.activate("vote");
} ]).controller("FriendPonyUpCtrl", [ "$rootScope", "$scope", "plan", "planNav", "wembliRpc", "$timeout", function($rootScope, $scope, plan, planNav, wembliRpc) {
    function handlePonyUp(newValue) {
        if ("undefined" != typeof newValue) {
            for (var requested = 0, received = 0, i = 0; i < newValue.payment.length; i++) {
                var p = newValue.payment[i];
                $scope.ponyUp = {
                    expirationDateMonth: "01",
                    expirationDateYear: "2014",
                    amount: 0,
                    amountFormatted: 0,
                    transactionFee: 0,
                    total: 0
                }, "request" === p.type && p.open && (console.log("pony up request is open"), console.log(p), 
                $scope.ponyUpRequest = p, $scope.ponyUp && $scope.ponyUp.amount || ($scope.ponyUp.amount = parseInt(p.amount) || 0, 
                $scope.ponyUp.amountFormatted = parseFloat($scope.ponyUp.amount / 100).toFixed(2), 
                $scope.ponyUp.transactionFee = .029 * $scope.ponyUp.amount + 250, $scope.ponyUp.total = $scope.ponyUp.transactionFee + $scope.ponyUp.amount, 
                $scope.ponyUp.cardHolderName = $scope.customer.firstName + " " + $scope.customer.lastName, 
                $scope.ponyUp.organizerFirstName = $scope.organizer.firstName), console.log($scope.ponyUp)), 
                "request" == p.type ? "canceled" !== p.status && (requested += parseInt(p.amount), 
                p.amount = parseInt(p.amount)) : received += parseInt(p.amount);
            }
            newValue.payment.requested = parseFloat(requested), newValue.payment.received = parseFloat(received), 
            newValue.payment.balance = parseFloat(requested - received);
        }
    }
    $scope.showFees = !1, $scope.showHistory = !1, $scope.$watch("ponyUp.amountFormatted", function(newVal) {
        if ("undefined" != typeof newVal) {
            var amount = parseInt(100 * parseFloat(newVal));
            $scope.ponyUp.transactionFee = .029 * parseFloat(amount) + 250, $scope.ponyUp.total = $scope.ponyUp.transactionFee + amount;
        }
    }), handlePonyUp($scope.me), $rootScope.$on("pony-up-success", function(e, friend) {
        $scope.me = friend, $scope.paymentTotals();
    }), $scope.$watch("me", function(newValue) {
        handlePonyUp(newValue);
    }), $scope.sendPonyUp = function() {
        if (!$scope.sendPonyUpInProgress) {
            $scope.sendPonyUpInProgress = !0, $scope.error = $scope.formError = $scope.success = !1;
            var args = {};
            args.total = $scope.ponyUp.total, args.amount = parseInt(100 * parseFloat($scope.ponyUp.amountFormatted)), 
            args.transactionFee = parseInt($scope.ponyUp.transactionFee), args.cardHolderName = $scope.ponyUp.cardHolderName, 
            args.creditCardNumber = $scope.ponyUp.creditCardNumber, args.expirationDateMonth = $scope.ponyUp.expirationDateMonth, 
            args.expirationDateYear = $scope.ponyUp.expirationDateYear, args.cvv = $scope.ponyUp.cvv, 
            args.postalCode = $scope.ponyUp.postalCode, wembliRpc.fetch("plan.sendPonyUp", args, function(err, result) {
                return $scope.sendPonyUpInProgress = !1, err ? ($scope.error = !0, $scope.errorMessage = err, 
                void ($scope.success = !1)) : result.success ? ($scope.success = !0, void $rootScope.$broadcast("pony-up-success", result.friend)) : ($scope.error = !0, 
                $scope.success = !1, $scope.errorMessage = result.error, void ((result.error = "No Organizer Bank Account") && ($scope.errorMessage = "The organizer cannot receive funds until they provide a bank account to deposit in to. Please try again once the organizer has created their account")));
            });
        }
    }, planNav.activate("pony-up");
} ]).controller("ChatterCtrl", [ "$scope", "wembliRpc", "planNav", function($scope, wembliRpc, planNav) {
    $scope.createChatter = function() {
        $scope.chatterForm.$valid && ($scope.createChatterInProgress = !0, wembliRpc.fetch("chatter.create", {
            body: $scope.newChatter
        }, function(err, results) {
            $scope.chatters = results.chatters, $scope.createChatterInProgress = !1;
        }));
    }, $scope.upVoteChatter = function() {}, $scope.createChatterComment = function(chatterIdx) {
        var chatter = $scope.chatters[chatterIdx];
        if (chatter.newComment) {
            chatter.commentInProgress = !0;
            var args = {
                body: chatter.newComment,
                chatterId: chatter._id
            };
            wembliRpc.fetch("chatter.addComment", args, function(err, results) {
                chatter.comments = results.comments, chatter.commentInProgress = !1, chatter.newComment = "";
            });
        }
    }, $scope.$watch("newChatterComment", function() {}), $scope.chatterLoading = !0, 
    wembliRpc.fetch("chatter.get", {}, function(err, results) {
        console.log(results.chatters), $scope.chatters = results.chatters, $scope.chatterLoading = !1, 
        planNav.activate("chatter");
    });
} ]).controller("PlanCtrlOff", [ "$scope", "wembliRpc", "$window", "plan", "planNav", "$location", "$rootScope", "googleMap", function($scope, wembliRpc, $window, plan, planNav, $location, $rootScope, googleMap) {
    plan.get(function(p) {
        $scope.plan = p, $scope.activateSection = function(sectionName) {
            console.log("activateSection " + sectionName);
            var sectionName = parseInt(sectionName.charAt(sectionName.length - 1));
            planNav.activate(sectionName), googleMap.resize();
        };
        var activateSection = 1;
        if ($location.path()) {
            var h = $location.path();
            activateSection = "_=_" == h ? 1 : parseInt(h.charAt(h.length - 1)), console.log("activate section from path " + activateSection);
        } else "undefined" != typeof $scope.customer && p.organizer.customerId === $scope.customer.id ? p && p.rsvpComplete && (activateSection = 2, 
        p.tickets[0] || (activateSection = 2), p.preferences.addOns.parking && !p.parking[0] && (activateSection = 2), 
        p.preferences.addOns.restaurants && !p.restaurants[0] && (activateSection = 2), 
        p.preferences.addOns.hotels && !p.hotels[0] && (activateSection = 2)) : activateSection = p.rsvpComplete ? 4 : 1;
        planNav.setActivateSection(activateSection), planNav.setSectionsCount($scope.sections);
    });
} ]), angular.module("wembliApp.directives.plan", []).directive("notification", [ "$timeout", "notifications", function($timeout, notifications) {
    return {
        restrict: "EAC",
        cache: !1,
        compile: function() {
            return function(scope, element) {
                element.click(function() {
                    notifications.update();
                });
            };
        }
    };
} ]).directive("rsvpFor", [ "$rootScope", function($rootScope) {
    return {
        restrict: "C",
        cache: !1,
        compile: function() {
            return function(scope, element, attr) {
                var d = scope.$watch("friend", function() {
                    element.click(function() {
                        var f = JSON.parse(attr.friend);
                        f.rsvp.decision = !0, $rootScope.$broadcast("rsvp-for-clicked", f), $("#rsvp-for-modal").modal("show");
                    }), d();
                });
            };
        }
    };
} ]).directive("resendRsvpEmail", [ "wembliRpc", function(wembliRpc) {
    return {
        restrict: "C",
        compile: function() {
            return function(scope, element, attr) {
                scope.rsvpEmailSent = !1, scope.rsvpEmailInProgress = !1, attr.$observe("friendId", function() {
                    element.click(function() {
                        scope.rsvpEmailInProgress = !0;
                        var rpcArgs = {
                            friendId: attr.friendId
                        };
                        wembliRpc.fetch("plan.resendRsvpEmail", rpcArgs, function() {
                            scope.rsvpEmailSent = !0, scope.rsvpEmailInProgress = !1, scope.$broadcast("rsvp-email-sent");
                        });
                    });
                });
            };
        }
    };
} ]).directive("rsvpForModal", [ "$rootScope", "pluralize", "wembliRpc", "plan", function($rootScope, pluralize, wembliRpc, plan) {
    return {
        restrict: "C",
        cache: !1,
        compile: function() {
            return function(scope) {
                $rootScope.$on("rsvp-for-clicked", function(e, friend) {
                    scope.friend = friend, scope.$watch("friend.rsvp.guestCount", function() {
                        "undefined" == typeof scope.friend.rsvp.guestCount;
                    }), scope.setRsvp = function(rsvp) {
                        scope.friend.rsvp.decision = rsvp;
                    }, scope.saveRsvp = function() {
                        scope.friend.rsvp.decision === !1 && (scope.friend.rsvp.guestCount = 0), scope.friend.rsvp.decision === !0 && 0 == scope.friend.rsvp.guestCount && (scope.friend.rsvp.guestCount = 1);
                        var args = {
                            friendId: scope.friend._id,
                            decision: scope.friend.rsvp.decision,
                            guestCount: scope.friend.rsvp.guestCount,
                            tickets: scope.friend.rsvp.decision
                        };
                        "undefined" != typeof scope.friend.rsvp.parking.decision && (args.parking = scope.friend.rsvp.parking.decision), 
                        "undefined" != typeof scope.friend.rsvp.restaurant.decision && (args.restaurant = scope.friend.rsvp.restaurant.decision), 
                        "undefined" != typeof scope.friend.rsvp.hotel.decision && (args.hotel = scope.friend.rsvp.hotel.decision), 
                        wembliRpc.fetch("plan.submitRsvpFor", args, function(err, result) {
                            scope.friend = result.friend, plan.fetch(function() {
                                $rootScope.$broadcast("plan-friends-changed", plan.getFriends());
                            });
                        });
                    }, scope.guestCountKeyUp = function() {
                        "" !== scope.friend.rsvp.guestCount && (scope.friend.rsvp.decision = scope.friend.rsvp.guestCount > 0, 
                        scope.guestCountPlural = pluralize(scope.friend.rsvp.guestCount));
                    }, scope.guestCountKeyDown = function(scope, elm, attr, e) {
                        38 == e.keyCode && scope.friend.rsvp.guestCount++, 40 == e.keyCode && (scope.friend.rsvp.guestCount--, 
                        scope.friend.rsvp.guestCount < 0 && (scope.friend.rsvp.guestCount = 0));
                    };
                });
            };
        }
    };
} ]).directive("infoSlideDownLabel", [ function() {
    return {
        restrict: "C",
        controller: [ "$scope", "$element", "$attrs", "$transclude", function() {} ],
        compile: function() {
            return function(scope, element, attr) {
                scope.toggle = !1, attr.$observe("friendId", function(friendId) {
                    friendId && element.click(function() {
                        scope.$apply(function() {
                            scope.toggle = !scope.toggle;
                        });
                        var slideKey = "#" + friendId + " ." + attr.key, caretKey = "#" + friendId + " ." + attr.key + "-caret";
                        scope.toggle ? ($(slideKey).slideDown(200), $(caretKey).addClass("icon-caret-down").removeClass("icon-caret-right")) : ($(slideKey).slideUp(100), 
                        $(caretKey).addClass("icon-caret-right").removeClass("icon-caret-down"));
                    });
                });
            };
        }
    };
} ]).directive("planDashboardOff", [ "$templateCache", "$timeout", "$rootScope", "$window", "$location", "wembliRpc", "cart", "plan", "customer", "pluralize", "fetchModals", "planNav", function($templateCache, $timeout, $rootScope, $window, $location, wembliRpc, cart, plan, customer, pluralize) {
    return {
        restrict: "C",
        replace: !0,
        scope: !1,
        controller: [ "$scope", "$element", "$attrs", "$transclude", function() {} ],
        compile: function() {
            return function(scope) {
                $templateCache.removeAll(), scope.$watch("totalComing", function(val) {
                    "undefined" != typeof val && (scope.totalComingPlural = pluralize(scope.totalComing), 
                    scope.reconcileTicketQty());
                }), scope.$watch("me", function(val) {
                    if ("undefined" != typeof val) {
                        for (var f = [], i = 0; i < scope.friends.length; i++) {
                            var friend = scope.friends[i];
                            f.push(friend._id === scope.me._id ? scope.me : friend);
                        }
                        scope.friends = f, scope.friendsPonyUp(scope.friends), scope.calcTotalComing();
                    }
                });
            };
        }
    };
} ]).directive("organizerPlanDashboardOff", [ "$rootScope", "$window", "$location", "wembliRpc", "cart", "plan", "customer", "pluralize", "fetchModals", "planNav", function($rootScope, $window, $location, wembliRpc, cart, plan, customer, pluralize, fetchModals) {
    return {
        restrict: "C",
        scope: !1,
        controller: [ "$scope", "$element", "$attrs", "$transclude", function() {
            fetchModals.fetch("/partials/tickets-offsite", function(err) {});
        } ],
        compile: function() {
            return function() {
                fetchModals.fetch("/partials/modals/organizer-dashboard", function() {
                    plan.get(function() {});
                });
            };
        }
    };
} ]).directive("organizerItinerarySectionOff", [ "wembliRpc", "planNav", function(wembliRpc, planNav) {
    return {
        restrict: "E",
        cache: !1,
        replace: !0,
        scope: !1,
        templateUrl: "/partials/plan/itinerary-section/organizer",
        compile: function() {
            return function() {
                console.log("organize itinerary loaded"), planNav.registerSection();
            };
        }
    };
} ]).directive("organizerRsvpSectionOff", [ "planNav", "plan", function(planNav) {
    return {
        restrict: "E",
        cache: !1,
        replace: !0,
        scope: !1,
        templateUrl: "/partials/plan/rsvp-section/organizer",
        compile: function() {
            return function() {
                console.log("organize rsvp loaded"), planNav.registerSection();
            };
        }
    };
} ]).directive("organizerCartSectionOff", [ "ticketPurchaseUrls", "plan", "cart", "planNav", function(ticketPurchaseUrls, plan, cart, planNav) {
    return {
        restrict: "E",
        replace: !0,
        scope: !1,
        templateUrl: "/partials/plan/cart-section/organizer",
        controller: [ "$scope", "$element", "$attrs", "$transclude", function() {} ],
        compile: function() {
            return function(scope) {
                scope.tnUrl = ticketPurchaseUrls.tn, console.log("organize cart loaded"), planNav.registerSection();
                var d = scope.$on("rsvp-complete", function() {
                    scope.plan.rsvpComplete = !0, scope.rsvpComplete = !0, d();
                });
            };
        }
    };
} ]).directive("organizerPonyUpSectionOff", [ "$rootScope", "plan", "wembliRpc", "$timeout", "customer", "planNav", function($rootScope, plan, wembliRpc, $timeout, customer, planNav) {
    return {
        restrict: "E",
        cache: !1,
        replace: !0,
        scope: !1,
        templateUrl: "/partials/plan/pony-up-section/organizer",
        controller: [ "$scope", "$element", "$attrs", "$transclude", function() {} ],
        compile: function() {
            return function() {
                console.log("organize pony up loaded"), planNav.registerSection();
            };
        }
    };
} ]).directive("itineraryMap", [ "$rootScope", "googleMap", "googlePlaces", "plan", "mapInfoWindowContent", "mapVenue", "mapMarker", "$timeout", function($rootScope, googleMap, googlePlaces, plan, mapInfoWindowContent, mapVenue, mapMarker) {
    return {
        restrict: "EC",
        cache: !1,
        replace: !0,
        scope: !1,
        compile: function() {
            return function(scope, element, attr) {
                var mapTypeId = attr.mapTypeId ? google.maps.MapTypeId[attr.mapTypeId] : google.maps.MapTypeId.ROADMAP, mapOpts = {
                    mapTypeId: mapTypeId
                };
                mapOpts.center = new google.maps.LatLng(attr.lat, attr.lng), attr.zoom && (mapOpts.zoom = parseInt(attr.zoom)), 
                attr.draggable && (mapOpts.draggable = "true" === attr.draggable ? !0 : !1), mapOpts.scrollwheel = !0, 
                attr.scrollwheel && (mapOpts.scrollwheel = "true" === attr.scrollwheel ? !0 : !1), 
                googleMap.draw(element, mapOpts);
                var placeMarkers = function(p) {
                    var lat = p.venue.data.geocode.geometry.location.lat, lng = p.venue.data.geocode.geometry.location.lng;
                    mapVenue.create(googleMap, {
                        lat: lat,
                        lng: lng,
                        name: p.event.eventVenue,
                        street: p.venue.data.Street1,
                        city: p.event.eventCity,
                        state: p.event.eventState
                    });
                    var parking = plan.getParking();
                    console.log(parking), angular.forEach(parking, function(p) {
                        "google" === p.service && googlePlaces.getDetails(p.parking.reference, function(place) {
                            mapMarker.create(googleMap, {
                                icon: "/images/icons/map-icons/transportation/parkinggarage.png",
                                lat: place.geometry.location.lat(),
                                lng: place.geometry.location.lng(),
                                name: place.name,
                                body: place.vicinity
                            });
                        }), "pw" === p.service && mapMarker.create(googleMap, {
                            icon: "/images/icons/map-icons/transportation/parkinggarage.png",
                            lat: p.parking.lat,
                            lng: p.parking.lng,
                            name: p.parking.location_name,
                            body: p.parking.address + ", " + p.parking.city
                        });
                    });
                    var restaurants = plan.getRestaurants();
                    angular.forEach(restaurants, function(r) {
                        "google" === r.service && googlePlaces.getDetails(r.restaurant.reference, function(place) {
                            mapMarker.create(googleMap, {
                                icon: "/images/icons/map-icons/entertainment/restaurant.png",
                                lat: place.geometry.location.lat(),
                                lng: place.geometry.location.lng(),
                                name: place.name,
                                body: place.vicinity
                            });
                        }), "yipit" === r.service && mapMarker.create(googleMap, {
                            icon: "/images/icons/map-icons/entertainment/restaurant.png",
                            lat: r.restaurant.business.locations[0].lat,
                            lng: r.restaurant.business.locations[0].lon,
                            name: r.restaurant.title,
                            body: r.restaurant.business.name
                        });
                    });
                    var hotels = plan.getHotels();
                    angular.forEach(hotels, function(h) {
                        "google" === h.service && googlePlaces.getDetails(h.hotel.reference, function(place) {
                            mapMarker.create(googleMap, {
                                icon: "/images/icons/map-icons/entertainment/hotel_0star.png",
                                lat: place.geometry.location.lat(),
                                lng: place.geometry.location.lng(),
                                name: place.name,
                                body: place.vicinity
                            });
                        });
                    });
                };
                plan.get(function(p) {
                    scope.$on("google-map-resize", function() {
                        googleMap.init(), googleMap.draw(element, mapOpts), placeMarkers(p);
                    });
                    var dereg = scope.$on("google-map-drawn", function() {
                        placeMarkers(p);
                    });
                    googleMap.isDrawn() && (dereg(), placeMarkers(p));
                });
            };
        }
    };
} ]).directive("friendPlanDashboardOff", [ "$window", "$location", "wembliRpc", "plan", "customer", "pluralize", "fetchModals", function($window, $location, wembliRpc, plan, customer, pluralize, fetchModals) {
    return {
        restrict: "C",
        cache: !1,
        replace: !1,
        scope: !1,
        compile: function() {
            return function(scope) {
                var height = angular.element($window).height();
                $("#section6").css("min-height", height), fetchModals.fetch("/partials/modals/friend-dashboard", function() {
                    plan.get(function() {
                        var watchMe = function() {
                            scope.guestCountPlural = pluralize(scope.me.rsvp.guestCount), null === scope.me.rsvp.decision && scope.setRsvp("decision", !0), 
                            "undefined" == typeof scope.me.rsvp.parking.decision && (scope.me.rsvp.parking.decision = !0), 
                            "undefined" == typeof scope.me.rsvp.restaurant.decision && (scope.me.rsvp.restaurant.decision = !0), 
                            "undefined" == typeof scope.me.rsvp.hotel.decision && (scope.me.rsvp.hotel.decision = !1);
                        };
                        if (scope.me) watchMe(); else var d = scope.$watch("me", function(newVal) {
                            "undefined" != typeof newVal && (watchMe(), d());
                        });
                    });
                });
            };
        }
    };
} ]).directive("friendItinerarySection", [ "wembliRpc", "planNav", function(wembliRpc, planNav) {
    return {
        restrict: "E",
        cache: !1,
        replace: !0,
        scope: !1,
        templateUrl: "/partials/plan/itinerary-section/friend",
        compile: function() {
            return function() {
                planNav.registerSection();
            };
        }
    };
} ]).directive("friendRsvpSectionOff", [ "planNav", "wembliRpc", "pluralize", function(planNav) {
    return {
        restrict: "E",
        cache: !1,
        replace: !0,
        scope: !1,
        templateUrl: "/partials/plan/rsvp-section/friend",
        compile: function() {
            return function() {
                planNav.registerSection();
            };
        }
    };
} ]).directive("friendVoteSectionOff", [ "planNav", "wembliRpc", function(planNav) {
    return {
        restrict: "E",
        cache: !1,
        replace: !0,
        scope: !1,
        templateUrl: "/partials/plan/vote-section/friend",
        compile: function() {
            return function() {
                planNav.registerSection();
            };
        }
    };
} ]).directive("friendInviteesSection", [ "planNav", "wembliRpc", function(planNav) {
    return {
        restrict: "E",
        cache: !1,
        replace: !0,
        scope: !1,
        templateUrl: "/partials/plan/invitees-section/friend",
        compile: function() {
            return function() {
                planNav.registerSection();
            };
        }
    };
} ]).directive("friendPonyUpSection", [ "$rootScope", "wembliRpc", "planNav", function($rootScope, wembliRpc, planNav) {
    return {
        restrict: "E",
        cache: !1,
        replace: !0,
        scope: !1,
        templateUrl: "/partials/plan/pony-up-section/friend",
        controller: [ "$scope", "$element", "$attrs", "$transclude", function() {} ],
        compile: function() {
            return function() {
                planNav.registerSection();
            };
        }
    };
} ]).directive("jquerySlider", [ function() {
    return {
        restrict: "C",
        compile: function() {
            return function(scope, element, attr) {
                attr.$observe("value", function(val) {
                    var slideFn = scope.$eval(attr.slide), stopFn = scope.$eval(attr.stop), range = attr.range;
                    "true" === attr.range && (range = !0), "false" === attr.range && (range = !1);
                    var sliderArgs = {
                        range: range,
                        min: parseInt(attr.min),
                        max: parseInt(attr.max),
                        step: parseFloat(attr.step),
                        create: function() {
                            "undefined" != typeof attr.enable && scope.$watch(attr.enable, function(newVal) {
                                "undefined" != typeof newVal && element.slider(newVal ? "enable" : "disable");
                            });
                        },
                        slide: function(event, ui) {
                            scope.$apply(function() {
                                slideFn.call(slideFn, event, ui, scope, element, attr);
                            });
                        },
                        stop: function(event, ui) {
                            scope.$apply(function() {
                                stopFn.call(stopFn, event, ui, scope, element, attr);
                            });
                        }
                    };
                    "undefined" != typeof attr.value && (sliderArgs.value = parseInt(val)), "undefined" != typeof attr.values && (sliderArgs.values = scope.$eval(attr.values)), 
                    element.slider(sliderArgs);
                });
            };
        }
    };
} ]).directive("planFeed", [ "plan", "$timeout", "wembliRpc", function(plan) {
    return {
        restrict: "E",
        replace: !0,
        cache: !1,
        templateUrl: "/partials/plan/feed",
        compile: function() {
            return function(scope) {
                plan.get(function() {
                    scope.feed = plan.getFeed();
                });
            };
        }
    };
} ]), angular.module("wembliApp.filters.plan", []).filter("chatterDateString", [ "$filter", function($filter) {
    return function(date) {
        return createdAgoString(date, $filter);
    };
} ]).filter("historyStatus", [ function() {
    return function(historyStatus) {
        if ("undefined" == typeof historyStatus) return "logged";
        var historyStatusFilter = {
            queued: "Sending Email",
            delivered: "Email Sent",
            opened: "Email Opened",
            responded: "Payment Posted",
            received: "Payment Received"
        };
        return "undefined" != typeof historyStatusFilter[historyStatus] ? historyStatusFilter[historyStatus] : historyStatus;
    };
} ]).filter("friendComing", [ "plan", function() {
    return function(friends) {
        if ("undefined" == typeof friends) return friends;
        for (var newList = [], i = 0; i < friends.length; i++) {
            var f = friends[i];
            f.inviteStatus && f.rsvp.decision && newList.push(f);
        }
        return newList;
    };
} ]).filter("filterInvitees", [ "plan", function(plan) {
    return function(friends) {
        if ("undefined" == typeof friends) return friends;
        if ("organizer" === plan.getContext()) return friends;
        var newList = [], p = plan.get();
        if (console.log("guestlist: " + p.preferences.guestList), "private" === p.preferences.guestList) return newList;
        for (var i = 0; i < friends.length; i++) {
            var f = friends[i];
            "rsvp" === p.preferences.guestList && null !== f.rsvp.decision && newList.push(f), 
            "full" === p.preferences.guestList && newList.push(f);
        }
        return newList;
    };
} ]), angular.module("wembliApp.services.plan", []).factory("planNav", [ "$timeout", "$rootScope", "$location", "header", "notifications", function($timeout, $rootScope, $location, header, notifications) {
    var self = this;
    self.activateSection = 1, self.arrowTop = 111, self.arrowHeight = 109, self.navFactor = {
        rsvp: 1,
        vote: 2,
        cart: 2,
        "pony-up": 3,
        itinerary: 4,
        chatter: 5
    };
    var planNav = {
        onActivate: function(f) {
            self.onActivate = f;
        },
        setActivateSection: function(sectionName) {
            self.activateSection = sectionName, this.activate();
        },
        activate: function(sectionName) {
            self.activateSection = sectionName ? sectionName : self.activateSection, $(".plan-section").removeClass("hide").hide(), 
            $(".plan-section-nav").removeClass("active"), $("#nav-section-" + self.activateSection).addClass("active");
            var top = self.arrowTop + self.arrowHeight * self.navFactor[self.activateSection];
            $(".nav-arrow").css("top", top + "px").removeClass("hide").show(), $("#section-" + self.activateSection).fadeIn(500), 
            notifications.update(), header.fixed(), self.onActivate && self.onActivate();
        }
    };
    return planNav;
} ]).factory("notifications", [ "$timeout", "plan", function($timeout, plan) {
    var keyMapping = {
        rsvpComplete: {
            id: "#rsvp-complete-notification",
            nav: "notification-nav-section-rsvp"
        },
        notConfirmed: {
            id: "#not-confirmed-notification",
            nav: "notification-nav-section-rsvp"
        },
        ticketCountMismatch: {
            id: "#ticket-count-mismatch-notification",
            nav: "notification-nav-section-cart"
        }
    }, reverseKeyMapping = {
        "rsvp-complete-notification": "rsvpComplete",
        "not-confirmed-notification": "notConfirmed",
        "ticket-count-mismatch-notification": "ticketCountMismatch"
    };
    return {
        findInPlan: function(id, notifications) {
            var ret = null;
            return angular.forEach(notifications, function(n) {
                reverseKeyMapping[id] == n.key && (ret = n);
            }), ret ? ret : void 0;
        },
        update: function() {
            var self = this;
            $timeout(function() {
                var counts = {};
                plan.get(function(p) {
                    angular.forEach(p.notifications, function(n) {
                        if (!n.acknowledged) {
                            var mapping = keyMapping[n.key];
                            counts[mapping.nav] = "undefined" != typeof counts[mapping.nav] ? counts[mapping.nav]++ : 1;
                        }
                    }), $("section .notification").each(function(idx, el) {
                        var n = (keyMapping[reverseKeyMapping[el.id]], self.findInPlan(el.id, p.notifications));
                        console.log(el.id), "undefined" == typeof n || n.acknowledged ? (console.log("hiding notification because it has been acknowledged: "), 
                        $(el).hide()) : $(el).show();
                    }), $("#plan-nav a .notification").each(function(idx, n) {
                        counts[n.id] ? $(n).html(counts[n.id]).show() : $(n).html("0").hide();
                    });
                });
            }, 500);
        }
    };
} ]).factory("cart", [ "plan", function(plan) {
    var self = this;
    return self.tickets = {
        fee: .15,
        deliveryFee: 15,
        label: "Ticket Group "
    }, self.parking = {
        fee: 0,
        deliveryFee: 0,
        label: "Parking Spot "
    }, self.restaurants = {
        fee: 0,
        deliveryFee: 0,
        label: "Restaurant Deal "
    }, self.hotels = {
        fee: 0,
        deliveryFee: 0,
        label: "Hotel Room "
    }, {
        totals: function(key) {
            plan.get(function(p) {
                var methods = {
                    tickets: {
                        get: function() {
                            return plan.getTickets();
                        },
                        getConfig: function() {
                            return self.tickets;
                        },
                        getAmount: function(item) {
                            return item.purchased ? item.payment.qty ? item.payment.amount / item.payment.qty : 0 : item.ticketGroup.ActualPrice || 0;
                        },
                        getQty: function(item) {
                            return item.purchased ? item.payment.qty : item.ticketGroup.maxSplit;
                        },
                        totalEach: function(item, price, fee) {
                            return item.purchased ? price : price + fee;
                        },
                        total: function(item, totalEach, splitBy, deliveryFee) {
                            return item.purchased ? item.payment.amount || 0 : totalEach * splitBy + deliveryFee;
                        }
                    },
                    parking: {
                        get: function() {
                            return plan.getParking();
                        },
                        getConfig: function() {
                            return self.parking;
                        },
                        getAmount: function(item) {
                            return item.purchased ? item.payment.qty ? item.payment.amount / item.payment.qty : 0 : "pw" === item.service ? item.parking.price || 0 : 0;
                        },
                        getQty: function(item) {
                            return item.purchased ? item.payment.qty || 0 : "pw" === item.service ? item.parking.reservation : 0;
                        },
                        totalEach: function(item, price, fee) {
                            return item.purchased ? price : price + fee;
                        },
                        total: function(item, totalEach, splitBy, deliveryFee) {
                            return item.purchased ? item.payment.amount || 0 : (console.log("calc parking total"), 
                            console.log(totalEach, splitBy, deliveryFee), totalEach * splitBy + deliveryFee);
                        }
                    },
                    restaurants: {
                        get: function() {
                            return plan.getRestaurants();
                        },
                        getConfig: function() {
                            return self.restaurants;
                        },
                        getAmount: function(item) {
                            return item.purchased ? item.payment.qty ? item.payment.amount / item.payment.qty : 0 : "yipit" === item.service ? item.restaurant.price.raw || 0 : 0;
                        },
                        totalEach: function(item, price, fee) {
                            return item.purchased ? price : (console.log(price, fee), price + fee);
                        },
                        total: function(item, totalEach, splitBy, deliveryFee) {
                            return item.purchased ? item.payment.amount || 0 : totalEach * splitBy + deliveryFee;
                        },
                        getQty: function(item) {
                            return item.purchased ? item.payment.qty || 0 : "yipit" === item.service ? 1 : 0;
                        }
                    },
                    hotels: {
                        get: function() {
                            return plan.getHotels();
                        },
                        getConfig: function() {
                            return self.hotels;
                        },
                        getAmount: function() {
                            return 0;
                        },
                        getQty: function() {
                            return 0;
                        },
                        totalEach: function(item, price, fee) {
                            return item.purchased ? price : (console.log(price, fee), price + fee);
                        },
                        total: function(item, totalEach, splitBy, deliveryFee) {
                            return item.purchased ? item.payment.amount || 0 : totalEach * splitBy + deliveryFee;
                        }
                    }
                }, funcs = methods[key], config = funcs.getConfig(), items = funcs.get(), groupTotal = 0, groupCount = 0, groups = [], groupTotalEach = {}, fee = config.fee || 0, deliveryFee = config.deliveryFee || 0, splitBy = 0, deliverySplitBy = 0, remainingSplitBy = null;
                p.organizer.rsvp.decision && (splitBy += parseInt(p.organizer.rsvp.guestCount) + 1, 
                deliverySplitBy++);
                for (var friends = plan.getFriends(), i = 0; i < friends.length; i++) {
                    var f = friends[i];
                    f.inviteStatus && f.rsvp.decision && (splitBy += parseInt(f.rsvp.guestCount) + 1, 
                    deliverySplitBy++);
                }
                for (var purchasedFirst = [], notPurchased = [], i = 0; i < items.length; i++) items[i].purchased ? purchasedFirst.push(items[i]) : notPurchased.push(items[i]);
                for (var all = purchasedFirst.concat(notPurchased), i = 0; i < all.length; i++) {
                    var item = items[i], amount = parseFloat(funcs.getAmount(item)), qty = funcs.getQty(item);
                    "undefined" == typeof qty && (qty = 0), (p.organizer.rsvp.decision && 1 == splitBy || 0 == splitBy) && (splitBy = qty, 
                    deliverySplitBy = qty), null !== remainingSplitBy && (remainingSplitBy > 0 && (splitBy = remainingSplitBy, 
                    deliverySplitBy = remainingSplitBy), 0 >= remainingSplitBy && (splitBy = qty, deliverySplitBy = qty)), 
                    remainingSplitBy = splitBy - qty, splitBy > qty && (splitBy = qty, deliverySplitBy = qty);
                    var cb = {}, groupNumber = i + 1;
                    cb.claimed = splitBy, cb.price = parseFloat(amount) || 0, cb.serviceFee = cb.price * fee, 
                    cb.deliveryFee = deliveryFee, cb.deliveryFeeEach = deliverySplitBy > 0 ? cb.deliveryFee / deliverySplitBy : 0, 
                    cb.totalEach = funcs.totalEach(item, cb.price, cb.serviceFee, qty, splitBy), cb.total = funcs.total(item, cb.totalEach, splitBy, cb.deliveryFee), 
                    groupTotal += cb.total, groupCount += cb.claimed, groups.push({
                        value: i,
                        label: config.label + groupNumber
                    }), groupTotalEach[i] = cb.totalEach, item.costBreakdown = cb;
                }
                items.total = groupTotal, items.totalQty = groupCount, items.groups = groups, items.groupTotalEach = groupTotalEach;
            });
        }
    };
} ]), angular.module("wembliApp.services.google", []).factory("googleMap", [ "$rootScope", function($rootScope) {
    function floatEqual(f1, f2) {
        return Math.abs(f1 - f2) < 1e-6;
    }
    var self = this;
    self._markers = [], self._infoWindows = [], self._map = null, self.drawn = !1, self.dragging = !1, 
    self.zoom = 14, self.center = new google.maps.LatLng(32.722439302963, -117.1645658798);
    var mapDefaults = {
        center: self.center,
        zoom: self.zoom,
        draggable: !0,
        mapTypeId: google.maps.MapTypeId.ROADMAP
    };
    return {
        init: function() {
            self._markers = [], self._infoWindows = [], self._map = null, self.drawn = !1, self.dragging = !1, 
            self.zoom = 14, self.center = new google.maps.LatLng(32.722439302963, -117.1645658798);
        },
        draw: function(element, options, handlers) {
            var o = angular.extend(mapDefaults, options), lat = o.center.lat(), lng = o.center.lng();
            o.center = new google.maps.LatLng(lat, lng), self._map = new google.maps.Map(element[0], o), 
            google.maps.event.addListener(self._map, "dragstart", function() {
                self.dragging = !0;
            }), google.maps.event.addListener(self._map, "idle", function() {
                self.dragging = !1;
            }), google.maps.event.addListener(self._map, "drag", function() {
                self.dragging = !0;
            }), google.maps.event.addListener(self._map, "zoom_changed", function() {
                self.zoom = self._map.getZoom(), self.center = self._map.getCenter();
            }), google.maps.event.addListener(self._map, "center_changed", function() {
                self.center = self._map.getCenter();
            }), "undefined" != typeof handlers && handlers.length && angular.forEach(handlers, function(h) {
                google.maps.event.addListener(self._map, h.on, h.handler);
            }), self.drawn = !0, $rootScope.$broadcast("google-map-drawn");
        },
        isDrawn: function(val) {
            return "undefined" != typeof val && (self.drawn = val), self.drawn;
        },
        getMap: function() {
            return self._map;
        },
        addMarker: function(marker) {
            return self._markers.unshift(marker), marker;
        },
        findMarker: function(lat, lng) {
            for (var i = 0; i < self._markers.length; i++) {
                var pos = self._markers[i].getPosition();
                if (floatEqual(pos.lat(), lat) && floatEqual(pos.lng(), lng)) return self._markers[i];
            }
            return null;
        },
        hasMarker: function(lat, lng) {
            return null !== this.findMarker(lat, lng);
        },
        removeMarker: function() {},
        addInfoWindow: function(infoWindow, marker) {
            var win = {
                infoWindow: infoWindow,
                open: !1
            };
            if ("undefined" != typeof infoWindow && "undefined" != typeof marker && "undefined" != typeof infoWindow.getPosition() && "undefined" != typeof marker.getPosition()) return "undefined" != typeof marker && "undefined" != typeof marker.getPosition() ? (win.lat = marker.getPosition().lat(), 
            win.lng = marker.getPosition().lng()) : (win.lat = infoWindow.getPosition().lat(), 
            win.lng = infoWindow.getPosition().lng()), self._infoWindows.unshift(win), win;
        },
        _findInfoWindow: function(lat, lng) {
            for (var i = 0; i < self._infoWindows.length; i++) {
                var winLat = self._infoWindows[i].lat, winLng = self._infoWindows[i].lng;
                if (floatEqual(winLat, lat) && floatEqual(winLng, lng)) return self._infoWindows[i];
            }
            return null;
        },
        findInfoWindow: function(lat, lng) {
            var win = this._findInfoWindow(lat, lng);
            return win ? win.infoWindow : null;
        },
        isInfoWindowOpen: function(marker) {
            var lat = marker.getPosition().lat(), lng = marker.getPosition().lng(), win = this._findInfoWindow(lat, lng);
            return win ? win.open : !1;
        },
        closeInfoWindow: function(marker) {
            var lat = marker.getPosition().lat(), lng = marker.getPosition().lng(), win = this._findInfoWindow(lat, lng);
            win.open = !1, win.infoWindow.close();
        },
        openInfoWindow: function(marker) {
            var lat = marker.getPosition().lat(), lng = marker.getPosition().lng(), win = this._findInfoWindow(lat, lng);
            win && (win.open = !0, win.infoWindow.open(self._map, marker));
        },
        resize: function() {
            google.maps.event.trigger(self._map, "resize"), $rootScope.$broadcast("google-map-resize");
        }
    };
} ]).factory("googlePlaces", [ "googleMap", function(googleMap) {
    return {
        getParking: function(lat, lng, radius, callback) {
            var request = {
                location: new google.maps.LatLng(lat, lng),
                radius: radius,
                types: [ "parking" ]
            }, service = new google.maps.places.PlacesService(googleMap.getMap());
            service.nearbySearch(request, callback);
        },
        getRestaurants: function(lat, lng, radius, callback) {
            var request = {
                location: new google.maps.LatLng(lat, lng),
                radius: radius,
                types: [ "restaurant" ]
            }, service = new google.maps.places.PlacesService(googleMap.getMap());
            service.nearbySearch(request, callback);
        },
        getHotels: function(lat, lng, radius, callback) {
            var request = {
                location: new google.maps.LatLng(lat, lng),
                radius: radius,
                types: [ "lodging" ]
            }, service = new google.maps.places.PlacesService(googleMap.getMap());
            service.nearbySearch(request, callback);
        },
        getDetails: function(reference, callback) {
            var request = {
                reference: reference
            }, service = new google.maps.places.PlacesService(googleMap.getMap());
            service.getDetails(request, callback);
        }
    };
} ]).factory("mapMarker", [ "mapInfoWindowContent", function(mapInfoWindowContent) {
    return {
        create: function(googleMap, args) {
            var position, markerArgs = {
                map: googleMap.getMap()
            };
            "undefined" != typeof args.position && (position = args.position), "undefined" != typeof args.lat && "undefined" != typeof args.lng && (position = new google.maps.LatLng(args.lat, args.lng)), 
            markerArgs.position = position;
            var marker = new google.maps.Marker(markerArgs);
            marker.setIcon(args.icon), marker.setAnimation(google.maps.Animation.DROP);
            var win = new google.maps.InfoWindow({
                position: position,
                content: mapInfoWindowContent.create({
                    header: args.name,
                    body: args.body
                }),
                pixelOffset: new google.maps.Size(10, 0)
            });
            google.maps.event.addListener(marker, "click", function() {
                googleMap.isInfoWindowOpen(marker) ? googleMap.closeInfoWindow(marker) : googleMap.openInfoWindow(marker);
            }), "undefined" != typeof args.click && google.maps.event.addListener(marker, "click", function() {
                googleMap.isInfoWindowOpen(marker) ? args.click.on() : args.click.off();
            }), googleMap.addMarker(marker), googleMap.addInfoWindow(win, marker);
        }
    };
} ]).factory("mapVenue", [ "mapInfoWindowContent", function(mapInfoWindowContent) {
    return {
        create: function(googleMap, args) {
            var position;
            "undefined" != typeof args.position && (position = args.position), "undefined" != typeof args.lat && "undefined" != typeof args.lng && (position = new google.maps.LatLng(args.lat, args.lng));
            var marker = new google.maps.Marker({
                map: googleMap.getMap(),
                position: position
            });
            marker.setIcon("/images/icons/map-icons/sports/stadium.png"), marker.setAnimation(google.maps.Animation.DROP);
            var win = new google.maps.InfoWindow({
                position: position,
                content: mapInfoWindowContent.create({
                    header: args.name,
                    body: args.street + ", " + args.city + ", " + args.state
                }),
                pixelOffset: new google.maps.Size(10, 0)
            });
            google.maps.event.addListener(marker, "click", function() {
                googleMap.isInfoWindowOpen(marker) ? googleMap.closeInfoWindow(marker) : googleMap.openInfoWindow(marker);
            }), googleMap.addMarker(marker), googleMap.addInfoWindow(win, marker), googleMap.openInfoWindow(marker);
        }
    };
} ]).factory("mapInfoWindowContent", [ function() {
    return {
        create: function(args) {
            var html = '<div class="info-window">';
            return html += '<h3 class="info-window-header">' + args.header + "</h3>", html += '<div class="info-window-body">' + args.body + "</div>", 
            html += "</div>";
        }
    };
} ]);