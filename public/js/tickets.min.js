/*! wembli-website 2014-05-18 */
"use strict";

!function($, undefined) {
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img, nodeName = element.nodeName.toLowerCase();
        return "area" === nodeName ? (map = element.parentNode, mapName = map.name, element.href && mapName && "map" === map.nodeName.toLowerCase() ? (img = $("img[usemap=#" + mapName + "]")[0], 
        !!img && visible(img)) : !1) : (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
    }
    function visible(element) {
        return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
            return "hidden" === $.css(this, "visibility");
        }).length;
    }
    var uuid = 0, runiqueId = /^ui-id-\d+$/;
    $.ui = $.ui || {}, $.extend($.ui, {
        version: "1.10.4",
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            NUMPAD_ADD: 107,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            NUMPAD_ENTER: 108,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_SUBTRACT: 109,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    }), $.fn.extend({
        focus: function(orig) {
            return function(delay, fn) {
                return "number" == typeof delay ? this.each(function() {
                    var elem = this;
                    setTimeout(function() {
                        $(elem).focus(), fn && fn.call(elem);
                    }, delay);
                }) : orig.apply(this, arguments);
            };
        }($.fn.focus),
        scrollParent: function() {
            var scrollParent;
            return scrollParent = $.ui.ie && /(static|relative)/.test(this.css("position")) || /absolute/.test(this.css("position")) ? this.parents().filter(function() {
                return /(relative|absolute|fixed)/.test($.css(this, "position")) && /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
            }).eq(0) : this.parents().filter(function() {
                return /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
            }).eq(0), /fixed/.test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
        },
        zIndex: function(zIndex) {
            if (zIndex !== undefined) return this.css("zIndex", zIndex);
            if (this.length) for (var position, value, elem = $(this[0]); elem.length && elem[0] !== document; ) {
                if (position = elem.css("position"), ("absolute" === position || "relative" === position || "fixed" === position) && (value = parseInt(elem.css("zIndex"), 10), 
                !isNaN(value) && 0 !== value)) return value;
                elem = elem.parent();
            }
            return 0;
        },
        uniqueId: function() {
            return this.each(function() {
                this.id || (this.id = "ui-id-" + ++uuid);
            });
        },
        removeUniqueId: function() {
            return this.each(function() {
                runiqueId.test(this.id) && $(this).removeAttr("id");
            });
        }
    }), $.extend($.expr[":"], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
            return function(elem) {
                return !!$.data(elem, dataName);
            };
        }) : function(elem, i, match) {
            return !!$.data(elem, match[3]);
        },
        focusable: function(element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"), isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    }), $("<a>").outerWidth(1).jquery || $.each([ "Width", "Height" ], function(i, name) {
        function reduce(elem, size, border, margin) {
            return $.each(side, function() {
                size -= parseFloat($.css(elem, "padding" + this)) || 0, border && (size -= parseFloat($.css(elem, "border" + this + "Width")) || 0), 
                margin && (size -= parseFloat($.css(elem, "margin" + this)) || 0);
            }), size;
        }
        var side = "Width" === name ? [ "Left", "Right" ] : [ "Top", "Bottom" ], type = name.toLowerCase(), orig = {
            innerWidth: $.fn.innerWidth,
            innerHeight: $.fn.innerHeight,
            outerWidth: $.fn.outerWidth,
            outerHeight: $.fn.outerHeight
        };
        $.fn["inner" + name] = function(size) {
            return size === undefined ? orig["inner" + name].call(this) : this.each(function() {
                $(this).css(type, reduce(this, size) + "px");
            });
        }, $.fn["outer" + name] = function(size, margin) {
            return "number" != typeof size ? orig["outer" + name].call(this, size) : this.each(function() {
                $(this).css(type, reduce(this, size, !0, margin) + "px");
            });
        };
    }), $.fn.addBack || ($.fn.addBack = function(selector) {
        return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector));
    }), $("<a>").data("a-b", "a").removeData("a-b").data("a-b") && ($.fn.removeData = function(removeData) {
        return function(key) {
            return arguments.length ? removeData.call(this, $.camelCase(key)) : removeData.call(this);
        };
    }($.fn.removeData)), $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()), 
    $.support.selectstart = "onselectstart" in document.createElement("div"), $.fn.extend({
        disableSelection: function() {
            return this.bind(($.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection", function(event) {
                event.preventDefault();
            });
        },
        enableSelection: function() {
            return this.unbind(".ui-disableSelection");
        }
    }), $.extend($.ui, {
        plugin: {
            add: function(module, option, set) {
                var i, proto = $.ui[module].prototype;
                for (i in set) proto.plugins[i] = proto.plugins[i] || [], proto.plugins[i].push([ option, set[i] ]);
            },
            call: function(instance, name, args) {
                var i, set = instance.plugins[name];
                if (set && instance.element[0].parentNode && 11 !== instance.element[0].parentNode.nodeType) for (i = 0; i < set.length; i++) instance.options[set[i][0]] && set[i][1].apply(instance.element, args);
            }
        },
        hasScroll: function(el, a) {
            if ("hidden" === $(el).css("overflow")) return !1;
            var scroll = a && "left" === a ? "scrollLeft" : "scrollTop", has = !1;
            return el[scroll] > 0 ? !0 : (el[scroll] = 1, has = el[scroll] > 0, el[scroll] = 0, 
            has);
        }
    });
}(jQuery), function($, undefined) {
    var uuid = 0, slice = Array.prototype.slice, _cleanData = $.cleanData;
    $.cleanData = function(elems) {
        for (var elem, i = 0; null != (elem = elems[i]); i++) try {
            $(elem).triggerHandler("remove");
        } catch (e) {}
        _cleanData(elems);
    }, $.widget = function(name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype, proxiedPrototype = {}, namespace = name.split(".")[0];
        name = name.split(".")[1], fullName = namespace + "-" + name, prototype || (prototype = base, 
        base = $.Widget), $.expr[":"][fullName.toLowerCase()] = function(elem) {
            return !!$.data(elem, fullName);
        }, $[namespace] = $[namespace] || {}, existingConstructor = $[namespace][name], 
        constructor = $[namespace][name] = function(options, element) {
            return this._createWidget ? void (arguments.length && this._createWidget(options, element)) : new constructor(options, element);
        }, $.extend(constructor, existingConstructor, {
            version: prototype.version,
            _proto: $.extend({}, prototype),
            _childConstructors: []
        }), basePrototype = new base(), basePrototype.options = $.widget.extend({}, basePrototype.options), 
        $.each(prototype, function(prop, value) {
            return $.isFunction(value) ? void (proxiedPrototype[prop] = function() {
                var _super = function() {
                    return base.prototype[prop].apply(this, arguments);
                }, _superApply = function(args) {
                    return base.prototype[prop].apply(this, args);
                };
                return function() {
                    var returnValue, __super = this._super, __superApply = this._superApply;
                    return this._super = _super, this._superApply = _superApply, returnValue = value.apply(this, arguments), 
                    this._super = __super, this._superApply = __superApply, returnValue;
                };
            }()) : void (proxiedPrototype[prop] = value);
        }), constructor.prototype = $.widget.extend(basePrototype, {
            widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        }), existingConstructor ? ($.each(existingConstructor._childConstructors, function(i, child) {
            var childPrototype = child.prototype;
            $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
        }), delete existingConstructor._childConstructors) : base._childConstructors.push(constructor), 
        $.widget.bridge(name, constructor);
    }, $.widget.extend = function(target) {
        for (var key, value, input = slice.call(arguments, 1), inputIndex = 0, inputLength = input.length; inputLength > inputIndex; inputIndex++) for (key in input[inputIndex]) value = input[inputIndex][key], 
        input[inputIndex].hasOwnProperty(key) && value !== undefined && (target[key] = $.isPlainObject(value) ? $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value) : value);
        return target;
    }, $.widget.bridge = function(name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function(options) {
            var isMethodCall = "string" == typeof options, args = slice.call(arguments, 1), returnValue = this;
            return options = !isMethodCall && args.length ? $.widget.extend.apply(null, [ options ].concat(args)) : options, 
            this.each(isMethodCall ? function() {
                var methodValue, instance = $.data(this, fullName);
                return instance ? $.isFunction(instance[options]) && "_" !== options.charAt(0) ? (methodValue = instance[options].apply(instance, args), 
                methodValue !== instance && methodValue !== undefined ? (returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue, 
                !1) : void 0) : $.error("no such method '" + options + "' for " + name + " widget instance") : $.error("cannot call methods on " + name + " prior to initialization; attempted to call method '" + options + "'");
            } : function() {
                var instance = $.data(this, fullName);
                instance ? instance.option(options || {})._init() : $.data(this, fullName, new object(options, this));
            }), returnValue;
        };
    }, $.Widget = function() {}, $.Widget._childConstructors = [], $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: !1,
            create: null
        },
        _createWidget: function(options, element) {
            element = $(element || this.defaultElement || this)[0], this.element = $(element), 
            this.uuid = uuid++, this.eventNamespace = "." + this.widgetName + this.uuid, this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options), 
            this.bindings = $(), this.hoverable = $(), this.focusable = $(), element !== this && ($.data(element, this.widgetFullName, this), 
            this._on(!0, this.element, {
                remove: function(event) {
                    event.target === element && this.destroy();
                }
            }), this.document = $(element.style ? element.ownerDocument : element.document || element), 
            this.window = $(this.document[0].defaultView || this.document[0].parentWindow)), 
            this._create(), this._trigger("create", null, this._getCreateEventData()), this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,
        destroy: function() {
            this._destroy(), this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName)), 
            this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled ui-state-disabled"), 
            this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass("ui-state-hover"), 
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,
        widget: function() {
            return this.element;
        },
        option: function(key, value) {
            var parts, curOption, i, options = key;
            if (0 === arguments.length) return $.widget.extend({}, this.options);
            if ("string" == typeof key) if (options = {}, parts = key.split("."), key = parts.shift(), 
            parts.length) {
                for (curOption = options[key] = $.widget.extend({}, this.options[key]), i = 0; i < parts.length - 1; i++) curOption[parts[i]] = curOption[parts[i]] || {}, 
                curOption = curOption[parts[i]];
                if (key = parts.pop(), 1 === arguments.length) return curOption[key] === undefined ? null : curOption[key];
                curOption[key] = value;
            } else {
                if (1 === arguments.length) return this.options[key] === undefined ? null : this.options[key];
                options[key] = value;
            }
            return this._setOptions(options), this;
        },
        _setOptions: function(options) {
            var key;
            for (key in options) this._setOption(key, options[key]);
            return this;
        },
        _setOption: function(key, value) {
            return this.options[key] = value, "disabled" === key && (this.widget().toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value).attr("aria-disabled", value), 
            this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus")), 
            this;
        },
        enable: function() {
            return this._setOption("disabled", !1);
        },
        disable: function() {
            return this._setOption("disabled", !0);
        },
        _on: function(suppressDisabledCheck, element, handlers) {
            var delegateElement, instance = this;
            "boolean" != typeof suppressDisabledCheck && (handlers = element, element = suppressDisabledCheck, 
            suppressDisabledCheck = !1), handlers ? (element = delegateElement = $(element), 
            this.bindings = this.bindings.add(element)) : (handlers = element, element = this.element, 
            delegateElement = this.widget()), $.each(handlers, function(event, handler) {
                function handlerProxy() {
                    return suppressDisabledCheck || instance.options.disabled !== !0 && !$(this).hasClass("ui-state-disabled") ? ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments) : void 0;
                }
                "string" != typeof handler && (handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++);
                var match = event.match(/^(\w+)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
                selector ? delegateElement.delegate(selector, eventName, handlerProxy) : element.bind(eventName, handlerProxy);
            });
        },
        _off: function(element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, 
            element.unbind(eventName).undelegate(eventName);
        },
        _delay: function(handler, delay) {
            function handlerProxy() {
                return ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },
        _hoverable: function(element) {
            this.hoverable = this.hoverable.add(element), this._on(element, {
                mouseenter: function(event) {
                    $(event.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function(event) {
                    $(event.currentTarget).removeClass("ui-state-hover");
                }
            });
        },
        _focusable: function(element) {
            this.focusable = this.focusable.add(element), this._on(element, {
                focusin: function(event) {
                    $(event.currentTarget).addClass("ui-state-focus");
                },
                focusout: function(event) {
                    $(event.currentTarget).removeClass("ui-state-focus");
                }
            });
        },
        _trigger: function(type, event, data) {
            var prop, orig, callback = this.options[type];
            if (data = data || {}, event = $.Event(event), event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(), 
            event.target = this.element[0], orig = event.originalEvent) for (prop in orig) prop in event || (event[prop] = orig[prop]);
            return this.element.trigger(event, data), !($.isFunction(callback) && callback.apply(this.element[0], [ event ].concat(data)) === !1 || event.isDefaultPrevented());
        }
    }, $.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(method, defaultEffect) {
        $.Widget.prototype["_" + method] = function(element, options, callback) {
            "string" == typeof options && (options = {
                effect: options
            });
            var hasOptions, effectName = options ? options === !0 || "number" == typeof options ? defaultEffect : options.effect || defaultEffect : method;
            options = options || {}, "number" == typeof options && (options = {
                duration: options
            }), hasOptions = !$.isEmptyObject(options), options.complete = callback, options.delay && element.delay(options.delay), 
            hasOptions && $.effects && $.effects.effect[effectName] ? element[method](options) : effectName !== method && element[effectName] ? element[effectName](options.duration, options.easing, callback) : element.queue(function(next) {
                $(this)[method](), callback && callback.call(element[0]), next();
            });
        };
    });
}(jQuery), function($) {
    var mouseHandled = !1;
    $(document).mouseup(function() {
        mouseHandled = !1;
    }), $.widget("ui.mouse", {
        version: "1.10.4",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var that = this;
            this.element.bind("mousedown." + this.widgetName, function(event) {
                return that._mouseDown(event);
            }).bind("click." + this.widgetName, function(event) {
                return !0 === $.data(event.target, that.widgetName + ".preventClickEvent") ? ($.removeData(event.target, that.widgetName + ".preventClickEvent"), 
                event.stopImmediatePropagation(), !1) : void 0;
            }), this.started = !1;
        },
        _mouseDestroy: function() {
            this.element.unbind("." + this.widgetName), this._mouseMoveDelegate && $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
        },
        _mouseDown: function(event) {
            if (!mouseHandled) {
                this._mouseStarted && this._mouseUp(event), this._mouseDownEvent = event;
                var that = this, btnIsLeft = 1 === event.which, elIsCancel = "string" == typeof this.options.cancel && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : !1;
                return btnIsLeft && !elIsCancel && this._mouseCapture(event) ? (this.mouseDelayMet = !this.options.delay, 
                this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function() {
                    that.mouseDelayMet = !0;
                }, this.options.delay)), this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(event) !== !1, 
                !this._mouseStarted) ? (event.preventDefault(), !0) : (!0 === $.data(event.target, this.widgetName + ".preventClickEvent") && $.removeData(event.target, this.widgetName + ".preventClickEvent"), 
                this._mouseMoveDelegate = function(event) {
                    return that._mouseMove(event);
                }, this._mouseUpDelegate = function(event) {
                    return that._mouseUp(event);
                }, $(document).bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate), 
                event.preventDefault(), mouseHandled = !0, !0)) : !0;
            }
        },
        _mouseMove: function(event) {
            return $.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button ? this._mouseUp(event) : this._mouseStarted ? (this._mouseDrag(event), 
            event.preventDefault()) : (this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== !1, 
            this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event)), !this._mouseStarted);
        },
        _mouseUp: function(event) {
            return $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate), 
            this._mouseStarted && (this._mouseStarted = !1, event.target === this._mouseDownEvent.target && $.data(event.target, this.widgetName + ".preventClickEvent", !0), 
            this._mouseStop(event)), !1;
        },
        _mouseDistanceMet: function(event) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
        },
        _mouseDelayMet: function() {
            return this.mouseDelayMet;
        },
        _mouseStart: function() {},
        _mouseDrag: function() {},
        _mouseStop: function() {},
        _mouseCapture: function() {
            return !0;
        }
    });
}(jQuery), function($) {
    var numPages = 5;
    $.widget("ui.slider", $.ui.mouse, {
        version: "1.10.4",
        widgetEventPrefix: "slide",
        options: {
            animate: !1,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: !1,
            step: 1,
            value: 0,
            values: null,
            change: null,
            slide: null,
            start: null,
            stop: null
        },
        _create: function() {
            this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, 
            this._detectOrientation(), this._mouseInit(), this.element.addClass("ui-slider ui-slider-" + this.orientation + " ui-widget ui-widget-content ui-corner-all"), 
            this._refresh(), this._setOption("disabled", this.options.disabled), this._animateOff = !1;
        },
        _refresh: function() {
            this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue();
        },
        _createHandles: function() {
            var i, handleCount, options = this.options, existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"), handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>", handles = [];
            for (handleCount = options.values && options.values.length || 1, existingHandles.length > handleCount && (existingHandles.slice(handleCount).remove(), 
            existingHandles = existingHandles.slice(0, handleCount)), i = existingHandles.length; handleCount > i; i++) handles.push(handle);
            this.handles = existingHandles.add($(handles.join("")).appendTo(this.element)), 
            this.handle = this.handles.eq(0), this.handles.each(function(i) {
                $(this).data("ui-slider-handle-index", i);
            });
        },
        _createRange: function() {
            var options = this.options, classes = "";
            options.range ? (options.range === !0 && (options.values ? options.values.length && 2 !== options.values.length ? options.values = [ options.values[0], options.values[0] ] : $.isArray(options.values) && (options.values = options.values.slice(0)) : options.values = [ this._valueMin(), this._valueMin() ]), 
            this.range && this.range.length ? this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({
                left: "",
                bottom: ""
            }) : (this.range = $("<div></div>").appendTo(this.element), classes = "ui-slider-range ui-widget-header ui-corner-all"), 
            this.range.addClass(classes + ("min" === options.range || "max" === options.range ? " ui-slider-range-" + options.range : ""))) : (this.range && this.range.remove(), 
            this.range = null);
        },
        _setupEvents: function() {
            var elements = this.handles.add(this.range).filter("a");
            this._off(elements), this._on(elements, this._handleEvents), this._hoverable(elements), 
            this._focusable(elements);
        },
        _destroy: function() {
            this.handles.remove(), this.range && this.range.remove(), this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-widget ui-widget-content ui-corner-all"), 
            this._mouseDestroy();
        },
        _mouseCapture: function(event) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle, that = this, o = this.options;
            return o.disabled ? !1 : (this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            }, this.elementOffset = this.element.offset(), position = {
                x: event.pageX,
                y: event.pageY
            }, normValue = this._normValueFromMouse(position), distance = this._valueMax() - this._valueMin() + 1, 
            this.handles.each(function(i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) && (distance = thisDistance, 
                closestHandle = $(this), index = i);
            }), allowed = this._start(event, index), allowed === !1 ? !1 : (this._mouseSliding = !0, 
            this._handleIndex = index, closestHandle.addClass("ui-state-active").focus(), offset = closestHandle.offset(), 
            mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle"), 
            this._clickOffset = mouseOverHandle ? {
                left: 0,
                top: 0
            } : {
                left: event.pageX - offset.left - closestHandle.width() / 2,
                top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
            }, this.handles.hasClass("ui-state-hover") || this._slide(event, index, normValue), 
            this._animateOff = !0, !0));
        },
        _mouseStart: function() {
            return !0;
        },
        _mouseDrag: function(event) {
            var position = {
                x: event.pageX,
                y: event.pageY
            }, normValue = this._normValueFromMouse(position);
            return this._slide(event, this._handleIndex, normValue), !1;
        },
        _mouseStop: function(event) {
            return this.handles.removeClass("ui-state-active"), this._mouseSliding = !1, this._stop(event, this._handleIndex), 
            this._change(event, this._handleIndex), this._handleIndex = null, this._clickOffset = null, 
            this._animateOff = !1, !1;
        },
        _detectOrientation: function() {
            this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal";
        },
        _normValueFromMouse: function(position) {
            var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;
            return "horizontal" === this.orientation ? (pixelTotal = this.elementSize.width, 
            pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (pixelTotal = this.elementSize.height, 
            pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)), 
            percentMouse = pixelMouse / pixelTotal, percentMouse > 1 && (percentMouse = 1), 
            0 > percentMouse && (percentMouse = 0), "vertical" === this.orientation && (percentMouse = 1 - percentMouse), 
            valueTotal = this._valueMax() - this._valueMin(), valueMouse = this._valueMin() + percentMouse * valueTotal, 
            this._trimAlignValue(valueMouse);
        },
        _start: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            return this.options.values && this.options.values.length && (uiHash.value = this.values(index), 
            uiHash.values = this.values()), this._trigger("start", event, uiHash);
        },
        _slide: function(event, index, newVal) {
            var otherVal, newValues, allowed;
            this.options.values && this.options.values.length ? (otherVal = this.values(index ? 0 : 1), 
            2 === this.options.values.length && this.options.range === !0 && (0 === index && newVal > otherVal || 1 === index && otherVal > newVal) && (newVal = otherVal), 
            newVal !== this.values(index) && (newValues = this.values(), newValues[index] = newVal, 
            allowed = this._trigger("slide", event, {
                handle: this.handles[index],
                value: newVal,
                values: newValues
            }), otherVal = this.values(index ? 0 : 1), allowed !== !1 && this.values(index, newVal))) : newVal !== this.value() && (allowed = this._trigger("slide", event, {
                handle: this.handles[index],
                value: newVal
            }), allowed !== !1 && this.value(newVal));
        },
        _stop: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            this.options.values && this.options.values.length && (uiHash.value = this.values(index), 
            uiHash.values = this.values()), this._trigger("stop", event, uiHash);
        },
        _change: function(event, index) {
            if (!this._keySliding && !this._mouseSliding) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                this.options.values && this.options.values.length && (uiHash.value = this.values(index), 
                uiHash.values = this.values()), this._lastChangedValue = index, this._trigger("change", event, uiHash);
            }
        },
        value: function(newValue) {
            return arguments.length ? (this.options.value = this._trimAlignValue(newValue), 
            this._refreshValue(), void this._change(null, 0)) : this._value();
        },
        values: function(index, newValue) {
            var vals, newValues, i;
            if (arguments.length > 1) return this.options.values[index] = this._trimAlignValue(newValue), 
            this._refreshValue(), void this._change(null, index);
            if (!arguments.length) return this._values();
            if (!$.isArray(arguments[0])) return this.options.values && this.options.values.length ? this._values(index) : this.value();
            for (vals = this.options.values, newValues = arguments[0], i = 0; i < vals.length; i += 1) vals[i] = this._trimAlignValue(newValues[i]), 
            this._change(null, i);
            this._refreshValue();
        },
        _setOption: function(key, value) {
            var i, valsLength = 0;
            switch ("range" === key && this.options.range === !0 && ("min" === value ? (this.options.value = this._values(0), 
            this.options.values = null) : "max" === value && (this.options.value = this._values(this.options.values.length - 1), 
            this.options.values = null)), $.isArray(this.options.values) && (valsLength = this.options.values.length), 
            $.Widget.prototype._setOption.apply(this, arguments), key) {
              case "orientation":
                this._detectOrientation(), this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation), 
                this._refreshValue();
                break;

              case "value":
                this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
                break;

              case "values":
                for (this._animateOff = !0, this._refreshValue(), i = 0; valsLength > i; i += 1) this._change(null, i);
                this._animateOff = !1;
                break;

              case "min":
              case "max":
                this._animateOff = !0, this._refreshValue(), this._animateOff = !1;
                break;

              case "range":
                this._animateOff = !0, this._refresh(), this._animateOff = !1;
            }
        },
        _value: function() {
            var val = this.options.value;
            return val = this._trimAlignValue(val);
        },
        _values: function(index) {
            var val, vals, i;
            if (arguments.length) return val = this.options.values[index], val = this._trimAlignValue(val);
            if (this.options.values && this.options.values.length) {
                for (vals = this.options.values.slice(), i = 0; i < vals.length; i += 1) vals[i] = this._trimAlignValue(vals[i]);
                return vals;
            }
            return [];
        },
        _trimAlignValue: function(val) {
            if (val <= this._valueMin()) return this._valueMin();
            if (val >= this._valueMax()) return this._valueMax();
            var step = this.options.step > 0 ? this.options.step : 1, valModStep = (val - this._valueMin()) % step, alignValue = val - valModStep;
            return 2 * Math.abs(valModStep) >= step && (alignValue += valModStep > 0 ? step : -step), 
            parseFloat(alignValue.toFixed(5));
        },
        _valueMin: function() {
            return this.options.min;
        },
        _valueMax: function() {
            return this.options.max;
        },
        _refreshValue: function() {
            var lastValPercent, valPercent, value, valueMin, valueMax, oRange = this.options.range, o = this.options, that = this, animate = this._animateOff ? !1 : o.animate, _set = {};
            this.options.values && this.options.values.length ? this.handles.each(function(i) {
                valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100, 
                _set["horizontal" === that.orientation ? "left" : "bottom"] = valPercent + "%", 
                $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate), that.options.range === !0 && ("horizontal" === that.orientation ? (0 === i && that.range.stop(1, 1)[animate ? "animate" : "css"]({
                    left: valPercent + "%"
                }, o.animate), 1 === i && that.range[animate ? "animate" : "css"]({
                    width: valPercent - lastValPercent + "%"
                }, {
                    queue: !1,
                    duration: o.animate
                })) : (0 === i && that.range.stop(1, 1)[animate ? "animate" : "css"]({
                    bottom: valPercent + "%"
                }, o.animate), 1 === i && that.range[animate ? "animate" : "css"]({
                    height: valPercent - lastValPercent + "%"
                }, {
                    queue: !1,
                    duration: o.animate
                }))), lastValPercent = valPercent;
            }) : (value = this.value(), valueMin = this._valueMin(), valueMax = this._valueMax(), 
            valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0, 
            _set["horizontal" === this.orientation ? "left" : "bottom"] = valPercent + "%", 
            this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate), "min" === oRange && "horizontal" === this.orientation && this.range.stop(1, 1)[animate ? "animate" : "css"]({
                width: valPercent + "%"
            }, o.animate), "max" === oRange && "horizontal" === this.orientation && this.range[animate ? "animate" : "css"]({
                width: 100 - valPercent + "%"
            }, {
                queue: !1,
                duration: o.animate
            }), "min" === oRange && "vertical" === this.orientation && this.range.stop(1, 1)[animate ? "animate" : "css"]({
                height: valPercent + "%"
            }, o.animate), "max" === oRange && "vertical" === this.orientation && this.range[animate ? "animate" : "css"]({
                height: 100 - valPercent + "%"
            }, {
                queue: !1,
                duration: o.animate
            }));
        },
        _handleEvents: {
            keydown: function(event) {
                var allowed, curVal, newVal, step, index = $(event.target).data("ui-slider-handle-index");
                switch (event.keyCode) {
                  case $.ui.keyCode.HOME:
                  case $.ui.keyCode.END:
                  case $.ui.keyCode.PAGE_UP:
                  case $.ui.keyCode.PAGE_DOWN:
                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.RIGHT:
                  case $.ui.keyCode.DOWN:
                  case $.ui.keyCode.LEFT:
                    if (event.preventDefault(), !this._keySliding && (this._keySliding = !0, $(event.target).addClass("ui-state-active"), 
                    allowed = this._start(event, index), allowed === !1)) return;
                }
                switch (step = this.options.step, curVal = newVal = this.options.values && this.options.values.length ? this.values(index) : this.value(), 
                event.keyCode) {
                  case $.ui.keyCode.HOME:
                    newVal = this._valueMin();
                    break;

                  case $.ui.keyCode.END:
                    newVal = this._valueMax();
                    break;

                  case $.ui.keyCode.PAGE_UP:
                    newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / numPages);
                    break;

                  case $.ui.keyCode.PAGE_DOWN:
                    newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / numPages);
                    break;

                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.RIGHT:
                    if (curVal === this._valueMax()) return;
                    newVal = this._trimAlignValue(curVal + step);
                    break;

                  case $.ui.keyCode.DOWN:
                  case $.ui.keyCode.LEFT:
                    if (curVal === this._valueMin()) return;
                    newVal = this._trimAlignValue(curVal - step);
                }
                this._slide(event, index, newVal);
            },
            click: function(event) {
                event.preventDefault();
            },
            keyup: function(event) {
                var index = $(event.target).data("ui-slider-handle-index");
                this._keySliding && (this._keySliding = !1, this._stop(event, index), this._change(event, index), 
                $(event.target).removeClass("ui-state-active"));
            }
        }
    });
}(jQuery), function(t, e) {
    function n() {
        if (!i.READY) {
            i.event.determineEventTypes();
            for (var t in i.gestures) i.gestures.hasOwnProperty(t) && i.detection.register(i.gestures[t]);
            i.event.onTouch(i.DOCUMENT, i.EVENT_MOVE, i.detection.detect), i.event.onTouch(i.DOCUMENT, i.EVENT_END, i.detection.detect), 
            i.READY = !0;
        }
    }
    var i = function(t, e) {
        return new i.Instance(t, e || {});
    };
    i.defaults = {
        stop_browser_behavior: {
            userSelect: "none",
            touchAction: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
        }
    }, i.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled, 
    i.HAS_TOUCHEVENTS = "ontouchstart" in t, i.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i, 
    i.NO_MOUSEEVENTS = i.HAS_TOUCHEVENTS && navigator.userAgent.match(i.MOBILE_REGEX), 
    i.EVENT_TYPES = {}, i.DIRECTION_DOWN = "down", i.DIRECTION_LEFT = "left", i.DIRECTION_UP = "up", 
    i.DIRECTION_RIGHT = "right", i.POINTER_MOUSE = "mouse", i.POINTER_TOUCH = "touch", 
    i.POINTER_PEN = "pen", i.EVENT_START = "start", i.EVENT_MOVE = "move", i.EVENT_END = "end", 
    i.DOCUMENT = document, i.plugins = {}, i.READY = !1, i.Instance = function(t, e) {
        var r = this;
        return n(), this.element = t, this.enabled = !0, this.options = i.utils.extend(i.utils.extend({}, i.defaults), e || {}), 
        this.options.stop_browser_behavior && i.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior), 
        i.event.onTouch(t, i.EVENT_START, function(t) {
            r.enabled && i.detection.startDetect(r, t);
        }), this;
    }, i.Instance.prototype = {
        on: function(t, e) {
            for (var n = t.split(" "), i = 0; n.length > i; i++) this.element.addEventListener(n[i], e, !1);
            return this;
        },
        off: function(t, e) {
            for (var n = t.split(" "), i = 0; n.length > i; i++) this.element.removeEventListener(n[i], e, !1);
            return this;
        },
        trigger: function(t, e) {
            var n = i.DOCUMENT.createEvent("Event");
            n.initEvent(t, !0, !0), n.gesture = e;
            var r = this.element;
            return i.utils.hasParent(e.target, r) && (r = e.target), r.dispatchEvent(n), this;
        },
        enable: function(t) {
            return this.enabled = t, this;
        }
    };
    var r = null, o = !1, s = !1;
    i.event = {
        bindDom: function(t, e, n) {
            for (var i = e.split(" "), r = 0; i.length > r; r++) t.addEventListener(i[r], n, !1);
        },
        onTouch: function(t, e, n) {
            var a = this;
            this.bindDom(t, i.EVENT_TYPES[e], function(c) {
                var u = c.type.toLowerCase();
                if (!u.match(/mouse/) || !s) {
                    u.match(/touch/) || u.match(/pointerdown/) || u.match(/mouse/) && 1 === c.which ? o = !0 : u.match(/mouse/) && 1 !== c.which && (o = !1), 
                    u.match(/touch|pointer/) && (s = !0);
                    var h = 0;
                    o && (i.HAS_POINTEREVENTS && e != i.EVENT_END ? h = i.PointerEvent.updatePointer(e, c) : u.match(/touch/) ? h = c.touches.length : s || (h = u.match(/up/) ? 0 : 1), 
                    h > 0 && e == i.EVENT_END ? e = i.EVENT_MOVE : h || (e = i.EVENT_END), h || null === r ? r = c : c = r, 
                    n.call(i.detection, a.collectEventData(t, e, c)), i.HAS_POINTEREVENTS && e == i.EVENT_END && (h = i.PointerEvent.updatePointer(e, c))), 
                    h || (r = null, o = !1, s = !1, i.PointerEvent.reset());
                }
            });
        },
        determineEventTypes: function() {
            var t;
            t = i.HAS_POINTEREVENTS ? i.PointerEvent.getEvents() : i.NO_MOUSEEVENTS ? [ "touchstart", "touchmove", "touchend touchcancel" ] : [ "touchstart mousedown", "touchmove mousemove", "touchend touchcancel mouseup" ], 
            i.EVENT_TYPES[i.EVENT_START] = t[0], i.EVENT_TYPES[i.EVENT_MOVE] = t[1], i.EVENT_TYPES[i.EVENT_END] = t[2];
        },
        getTouchList: function(t) {
            return i.HAS_POINTEREVENTS ? i.PointerEvent.getTouchList() : t.touches ? t.touches : [ {
                identifier: 1,
                pageX: t.pageX,
                pageY: t.pageY,
                target: t.target
            } ];
        },
        collectEventData: function(t, e, n) {
            var r = this.getTouchList(n, e), o = i.POINTER_TOUCH;
            return (n.type.match(/mouse/) || i.PointerEvent.matchType(i.POINTER_MOUSE, n)) && (o = i.POINTER_MOUSE), 
            {
                center: i.utils.getCenter(r),
                timeStamp: new Date().getTime(),
                target: n.target,
                touches: r,
                eventType: e,
                pointerType: o,
                srcEvent: n,
                preventDefault: function() {
                    this.srcEvent.preventManipulation && this.srcEvent.preventManipulation(), this.srcEvent.preventDefault && this.srcEvent.preventDefault();
                },
                stopPropagation: function() {
                    this.srcEvent.stopPropagation();
                },
                stopDetect: function() {
                    return i.detection.stopDetect();
                }
            };
        }
    }, i.PointerEvent = {
        pointers: {},
        getTouchList: function() {
            var t = this, e = [];
            return Object.keys(t.pointers).sort().forEach(function(n) {
                e.push(t.pointers[n]);
            }), e;
        },
        updatePointer: function(t, e) {
            return t == i.EVENT_END ? this.pointers = {} : (e.identifier = e.pointerId, this.pointers[e.pointerId] = e), 
            Object.keys(this.pointers).length;
        },
        matchType: function(t, e) {
            if (!e.pointerType) return !1;
            var n = {};
            return n[i.POINTER_MOUSE] = e.pointerType == e.MSPOINTER_TYPE_MOUSE || e.pointerType == i.POINTER_MOUSE, 
            n[i.POINTER_TOUCH] = e.pointerType == e.MSPOINTER_TYPE_TOUCH || e.pointerType == i.POINTER_TOUCH, 
            n[i.POINTER_PEN] = e.pointerType == e.MSPOINTER_TYPE_PEN || e.pointerType == i.POINTER_PEN, 
            n[t];
        },
        getEvents: function() {
            return [ "pointerdown MSPointerDown", "pointermove MSPointerMove", "pointerup pointercancel MSPointerUp MSPointerCancel" ];
        },
        reset: function() {
            this.pointers = {};
        }
    }, i.utils = {
        extend: function(t, n, i) {
            for (var r in n) t[r] !== e && i || (t[r] = n[r]);
            return t;
        },
        hasParent: function(t, e) {
            for (;t; ) {
                if (t == e) return !0;
                t = t.parentNode;
            }
            return !1;
        },
        getCenter: function(t) {
            for (var e = [], n = [], i = 0, r = t.length; r > i; i++) e.push(t[i].pageX), n.push(t[i].pageY);
            return {
                pageX: (Math.min.apply(Math, e) + Math.max.apply(Math, e)) / 2,
                pageY: (Math.min.apply(Math, n) + Math.max.apply(Math, n)) / 2
            };
        },
        getVelocity: function(t, e, n) {
            return {
                x: Math.abs(e / t) || 0,
                y: Math.abs(n / t) || 0
            };
        },
        getAngle: function(t, e) {
            var n = e.pageY - t.pageY, i = e.pageX - t.pageX;
            return 180 * Math.atan2(n, i) / Math.PI;
        },
        getDirection: function(t, e) {
            var n = Math.abs(t.pageX - e.pageX), r = Math.abs(t.pageY - e.pageY);
            return n >= r ? t.pageX - e.pageX > 0 ? i.DIRECTION_LEFT : i.DIRECTION_RIGHT : t.pageY - e.pageY > 0 ? i.DIRECTION_UP : i.DIRECTION_DOWN;
        },
        getDistance: function(t, e) {
            var n = e.pageX - t.pageX, i = e.pageY - t.pageY;
            return Math.sqrt(n * n + i * i);
        },
        getScale: function(t, e) {
            return t.length >= 2 && e.length >= 2 ? this.getDistance(e[0], e[1]) / this.getDistance(t[0], t[1]) : 1;
        },
        getRotation: function(t, e) {
            return t.length >= 2 && e.length >= 2 ? this.getAngle(e[1], e[0]) - this.getAngle(t[1], t[0]) : 0;
        },
        isVertical: function(t) {
            return t == i.DIRECTION_UP || t == i.DIRECTION_DOWN;
        },
        stopDefaultBrowserBehavior: function(t, e) {
            var n, i = [ "webkit", "khtml", "moz", "ms", "o", "" ];
            if (e && t.style) {
                for (var r = 0; i.length > r; r++) for (var o in e) e.hasOwnProperty(o) && (n = o, 
                i[r] && (n = i[r] + n.substring(0, 1).toUpperCase() + n.substring(1)), t.style[n] = e[o]);
                "none" == e.userSelect && (t.onselectstart = function() {
                    return !1;
                });
            }
        }
    }, i.detection = {
        gestures: [],
        current: null,
        previous: null,
        stopped: !1,
        startDetect: function(t, e) {
            this.current || (this.stopped = !1, this.current = {
                inst: t,
                startEvent: i.utils.extend({}, e),
                lastEvent: !1,
                name: ""
            }, this.detect(e));
        },
        detect: function(t) {
            if (this.current && !this.stopped) {
                t = this.extendEventData(t);
                for (var e = this.current.inst.options, n = 0, r = this.gestures.length; r > n; n++) {
                    var o = this.gestures[n];
                    if (!this.stopped && e[o.name] !== !1 && o.handler.call(o, t, this.current.inst) === !1) {
                        this.stopDetect();
                        break;
                    }
                }
                return this.current && (this.current.lastEvent = t), t.eventType == i.EVENT_END && !t.touches.length - 1 && this.stopDetect(), 
                t;
            }
        },
        stopDetect: function() {
            this.previous = i.utils.extend({}, this.current), this.current = null, this.stopped = !0;
        },
        extendEventData: function(t) {
            var e = this.current.startEvent;
            if (e && (t.touches.length != e.touches.length || t.touches === e.touches)) {
                e.touches = [];
                for (var n = 0, r = t.touches.length; r > n; n++) e.touches.push(i.utils.extend({}, t.touches[n]));
            }
            var o = t.timeStamp - e.timeStamp, s = t.center.pageX - e.center.pageX, a = t.center.pageY - e.center.pageY, c = i.utils.getVelocity(o, s, a);
            return i.utils.extend(t, {
                deltaTime: o,
                deltaX: s,
                deltaY: a,
                velocityX: c.x,
                velocityY: c.y,
                distance: i.utils.getDistance(e.center, t.center),
                angle: i.utils.getAngle(e.center, t.center),
                direction: i.utils.getDirection(e.center, t.center),
                scale: i.utils.getScale(e.touches, t.touches),
                rotation: i.utils.getRotation(e.touches, t.touches),
                startEvent: e
            }), t;
        },
        register: function(t) {
            var n = t.defaults || {};
            return n[t.name] === e && (n[t.name] = !0), i.utils.extend(i.defaults, n, !0), t.index = t.index || 1e3, 
            this.gestures.push(t), this.gestures.sort(function(t, e) {
                return t.index < e.index ? -1 : t.index > e.index ? 1 : 0;
            }), this.gestures;
        }
    }, i.gestures = i.gestures || {}, i.gestures.Hold = {
        name: "hold",
        index: 10,
        defaults: {
            hold_timeout: 500,
            hold_threshold: 1
        },
        timer: null,
        handler: function(t, e) {
            switch (t.eventType) {
              case i.EVENT_START:
                clearTimeout(this.timer), i.detection.current.name = this.name, this.timer = setTimeout(function() {
                    "hold" == i.detection.current.name && e.trigger("hold", t);
                }, e.options.hold_timeout);
                break;

              case i.EVENT_MOVE:
                t.distance > e.options.hold_threshold && clearTimeout(this.timer);
                break;

              case i.EVENT_END:
                clearTimeout(this.timer);
            }
        }
    }, i.gestures.Tap = {
        name: "tap",
        index: 100,
        defaults: {
            tap_max_touchtime: 250,
            tap_max_distance: 10,
            tap_always: !0,
            doubletap_distance: 20,
            doubletap_interval: 300
        },
        handler: function(t, e) {
            if (t.eventType == i.EVENT_END) {
                var n = i.detection.previous, r = !1;
                if (t.deltaTime > e.options.tap_max_touchtime || t.distance > e.options.tap_max_distance) return;
                n && "tap" == n.name && t.timeStamp - n.lastEvent.timeStamp < e.options.doubletap_interval && t.distance < e.options.doubletap_distance && (e.trigger("doubletap", t), 
                r = !0), (!r || e.options.tap_always) && (i.detection.current.name = "tap", e.trigger(i.detection.current.name, t));
            }
        }
    }, i.gestures.Swipe = {
        name: "swipe",
        index: 40,
        defaults: {
            swipe_max_touches: 1,
            swipe_velocity: .7
        },
        handler: function(t, e) {
            if (t.eventType == i.EVENT_END) {
                if (e.options.swipe_max_touches > 0 && t.touches.length > e.options.swipe_max_touches) return;
                (t.velocityX > e.options.swipe_velocity || t.velocityY > e.options.swipe_velocity) && (e.trigger(this.name, t), 
                e.trigger(this.name + t.direction, t));
            }
        }
    }, i.gestures.Drag = {
        name: "drag",
        index: 50,
        defaults: {
            drag_min_distance: 10,
            drag_max_touches: 1,
            drag_block_horizontal: !1,
            drag_block_vertical: !1,
            drag_lock_to_axis: !1,
            drag_lock_min_distance: 25
        },
        triggered: !1,
        handler: function(t, n) {
            if (i.detection.current.name != this.name && this.triggered) return n.trigger(this.name + "end", t), 
            this.triggered = !1, e;
            if (!(n.options.drag_max_touches > 0 && t.touches.length > n.options.drag_max_touches)) switch (t.eventType) {
              case i.EVENT_START:
                this.triggered = !1;
                break;

              case i.EVENT_MOVE:
                if (t.distance < n.options.drag_min_distance && i.detection.current.name != this.name) return;
                i.detection.current.name = this.name, (i.detection.current.lastEvent.drag_locked_to_axis || n.options.drag_lock_to_axis && n.options.drag_lock_min_distance <= t.distance) && (t.drag_locked_to_axis = !0);
                var r = i.detection.current.lastEvent.direction;
                t.drag_locked_to_axis && r !== t.direction && (t.direction = i.utils.isVertical(r) ? 0 > t.deltaY ? i.DIRECTION_UP : i.DIRECTION_DOWN : 0 > t.deltaX ? i.DIRECTION_LEFT : i.DIRECTION_RIGHT), 
                this.triggered || (n.trigger(this.name + "start", t), this.triggered = !0), n.trigger(this.name, t), 
                n.trigger(this.name + t.direction, t), (n.options.drag_block_vertical && i.utils.isVertical(t.direction) || n.options.drag_block_horizontal && !i.utils.isVertical(t.direction)) && t.preventDefault();
                break;

              case i.EVENT_END:
                this.triggered && n.trigger(this.name + "end", t), this.triggered = !1;
            }
        }
    }, i.gestures.Transform = {
        name: "transform",
        index: 45,
        defaults: {
            transform_min_scale: .01,
            transform_min_rotation: 1,
            transform_always_block: !1
        },
        triggered: !1,
        handler: function(t, n) {
            if (i.detection.current.name != this.name && this.triggered) return n.trigger(this.name + "end", t), 
            this.triggered = !1, e;
            if (!(2 > t.touches.length)) switch (n.options.transform_always_block && t.preventDefault(), 
            t.eventType) {
              case i.EVENT_START:
                this.triggered = !1;
                break;

              case i.EVENT_MOVE:
                var r = Math.abs(1 - t.scale), o = Math.abs(t.rotation);
                if (n.options.transform_min_scale > r && n.options.transform_min_rotation > o) return;
                i.detection.current.name = this.name, this.triggered || (n.trigger(this.name + "start", t), 
                this.triggered = !0), n.trigger(this.name, t), o > n.options.transform_min_rotation && n.trigger("rotate", t), 
                r > n.options.transform_min_scale && (n.trigger("pinch", t), n.trigger("pinch" + (1 > t.scale ? "in" : "out"), t));
                break;

              case i.EVENT_END:
                this.triggered && n.trigger(this.name + "end", t), this.triggered = !1;
            }
        }
    }, i.gestures.Touch = {
        name: "touch",
        index: -1 / 0,
        defaults: {
            prevent_default: !1,
            prevent_mouseevents: !1
        },
        handler: function(t, n) {
            return n.options.prevent_mouseevents && t.pointerType == i.POINTER_MOUSE ? (t.stopDetect(), 
            e) : (n.options.prevent_default && t.preventDefault(), t.eventType == i.EVENT_START && n.trigger(this.name, t), 
            e);
        }
    }, i.gestures.Release = {
        name: "release",
        index: 1 / 0,
        handler: function(t, e) {
            t.eventType == i.EVENT_END && e.trigger(this.name, t);
        }
    }, "object" == typeof module && "object" == typeof module.exports ? module.exports = i : (t.Hammer = i, 
    "function" == typeof t.define && t.define.amd && t.define("hammer", [], function() {
        return i;
    }));
}(this), function(t, e) {
    t !== e && (Hammer.event.bindDom = function(n, i, r) {
        t(n).on(i, function(t) {
            var n = t.originalEvent || t;
            n.pageX === e && (n.pageX = t.pageX, n.pageY = t.pageY), n.target || (n.target = t.target), 
            n.which === e && (n.which = n.button), n.preventDefault || (n.preventDefault = t.preventDefault), 
            n.stopPropagation || (n.stopPropagation = t.stopPropagation), r.call(this, n);
        });
    }, Hammer.Instance.prototype.on = function(e, n) {
        return t(this.element).on(e, n);
    }, Hammer.Instance.prototype.off = function(e, n) {
        return t(this.element).off(e, n);
    }, Hammer.Instance.prototype.trigger = function(e, n) {
        var i = t(this.element);
        return i.has(n.target).length && (i = t(n.target)), i.trigger({
            type: e,
            gesture: n
        });
    }, t.fn.hammer = function(e) {
        return this.each(function() {
            var n = t(this), i = n.data("hammer");
            i ? i && e && Hammer.utils.extend(i.options, e) : n.data("hammer", new Hammer(this, e || {}));
        });
    });
}(window.jQuery || window.Zepto), document.createElement("canvas").getContext || !function() {
    function h() {
        return this.context_ || (this.context_ = new q(this));
    }
    function F(j, m) {
        var i = u.call(arguments, 2);
        return function() {
            return j.apply(m, i.concat(u.call(arguments)));
        };
    }
    function C(j) {
        var i = j.srcElement;
        switch (j.propertyName) {
          case "width":
            i.style.width = i.attributes.width.nodeValue + "px", i.getContext().clearRect();
            break;

          case "height":
            i.style.height = i.attributes.height.nodeValue + "px", i.getContext().clearRect();
        }
    }
    function b(j) {
        var i = j.srcElement;
        i.firstChild && (i.firstChild.style.width = i.clientWidth + "px", i.firstChild.style.height = i.clientHeight + "px");
    }
    function r() {
        return [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
    }
    function d(G, m) {
        for (var j = r(), i = 0; 3 > i; i++) for (var J = 0; 3 > J; J++) {
            for (var H = 0, I = 0; 3 > I; I++) H += G[i][I] * m[I][J];
            j[i][J] = H;
        }
        return j;
    }
    function x(j, i) {
        i.fillStyle = j.fillStyle, i.lineCap = j.lineCap, i.lineJoin = j.lineJoin, i.lineWidth = j.lineWidth, 
        i.miterLimit = j.miterLimit, i.shadowBlur = j.shadowBlur, i.shadowColor = j.shadowColor, 
        i.shadowOffsetX = j.shadowOffsetX, i.shadowOffsetY = j.shadowOffsetY, i.strokeStyle = j.strokeStyle, 
        i.globalAlpha = j.globalAlpha, i.arcScaleX_ = j.arcScaleX_, i.arcScaleY_ = j.arcScaleY_, 
        i.lineScale_ = j.lineScale_;
    }
    function c(m) {
        var I, H = 1;
        if (m = String(m), "rgb" == m.substring(0, 3)) {
            var K = m.indexOf("(", 3), j = m.indexOf(")", K + 1), J = m.substring(K + 1, j).split(",");
            I = "#";
            for (var G = 0; 3 > G; G++) I += e[Number(J[G])];
            4 == J.length && "a" == m.substr(3, 1) && (H = J[3]);
        } else I = m;
        return {
            color: I,
            alpha: H
        };
    }
    function t(i) {
        switch (i) {
          case "butt":
            return "flat";

          case "round":
            return "round";

          case "square":
          default:
            return "square";
        }
    }
    function q(j) {
        this.m_ = r(), this.mStack_ = [], this.aStack_ = [], this.currentPath_ = [], this.strokeStyle = "#000", 
        this.fillStyle = "#000", this.lineWidth = 1, this.lineJoin = "miter", this.lineCap = "butt", 
        this.miterLimit = 1 * a, this.globalAlpha = 1, this.canvas = j;
        var i = j.ownerDocument.createElement("div");
        i.style.width = j.clientWidth + "px", i.style.height = j.clientHeight + "px", i.style.overflow = "hidden", 
        i.style.position = "absolute", j.appendChild(i), this.element_ = i, this.arcScaleX_ = 1, 
        this.arcScaleY_ = 1, this.lineScale_ = 1;
    }
    function p(i, G, m, j) {
        i.currentPath_.push({
            type: "bezierCurveTo",
            cp1x: G.x,
            cp1y: G.y,
            cp2x: m.x,
            cp2y: m.y,
            x: j.x,
            y: j.y
        }), i.currentX_ = j.x, i.currentY_ = j.y;
    }
    function g(i) {
        for (var H = 0; 3 > H; H++) for (var G = 0; 2 > G; G++) if (!isFinite(i[H][G]) || isNaN(i[H][G])) return !1;
        return !0;
    }
    function B(j, i, G) {
        if (g(i) && (j.m_ = i, G)) {
            var H = i[0][0] * i[1][1] - i[0][1] * i[1][0];
            j.lineScale_ = D(n(H));
        }
    }
    function A(i) {
        this.type_ = i, this.x0_ = 0, this.y0_ = 0, this.r0_ = 0, this.x1_ = 0, this.y1_ = 0, 
        this.r1_ = 0, this.colors_ = [];
    }
    function f() {}
    var v = Math, w = v.round, s = v.sin, E = v.cos, n = v.abs, D = v.sqrt, a = 10, o = a / 2, u = Array.prototype.slice, k = {
        init: function(i) {
            if (/MSIE/.test(navigator.userAgent) && !window.opera) {
                var j = i || document;
                j.createElement("canvas"), j.attachEvent("onreadystatechange", F(this.init_, this, j));
            }
        },
        init_: function(H) {
            if (H.namespaces.g_vml_ || H.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML"), 
            H.namespaces.g_o_ || H.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML"), 
            !H.styleSheets.ex_canvas_) {
                var G = H.createStyleSheet();
                G.owningElement.id = "ex_canvas_", G.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}g_vml_\\:*{behavior:url(#default#VML)}g_o_\\:*{behavior:url(#default#VML)}";
            }
            for (var m = H.getElementsByTagName("canvas"), j = 0; j < m.length; j++) this.initElement(m[j]);
        },
        initElement: function(j) {
            if (!j.getContext) {
                j.getContext = h, j.innerHTML = "", j.attachEvent("onpropertychange", C), j.attachEvent("onresize", b);
                var i = j.attributes;
                i.width && i.width.specified ? j.style.width = i.width.nodeValue + "px" : j.width = j.clientWidth, 
                i.height && i.height.specified ? j.style.height = i.height.nodeValue + "px" : j.height = j.clientHeight;
            }
            return j;
        }
    };
    k.init();
    for (var e = [], z = 0; 16 > z; z++) for (var y = 0; 16 > y; y++) e[16 * z + y] = z.toString(16) + y.toString(16);
    var l = q.prototype;
    l.clearRect = function() {
        this.element_.innerHTML = "";
    }, l.beginPath = function() {
        this.currentPath_ = [];
    }, l.moveTo = function(j, i) {
        var m = this.getCoords_(j, i);
        this.currentPath_.push({
            type: "moveTo",
            x: m.x,
            y: m.y
        }), this.currentX_ = m.x, this.currentY_ = m.y;
    }, l.lineTo = function(j, i) {
        var m = this.getCoords_(j, i);
        this.currentPath_.push({
            type: "lineTo",
            x: m.x,
            y: m.y
        }), this.currentX_ = m.x, this.currentY_ = m.y;
    }, l.bezierCurveTo = function(m, j, L, K, J, H) {
        var i = this.getCoords_(J, H), I = this.getCoords_(m, j), G = this.getCoords_(L, K);
        p(this, I, G, i);
    }, l.quadraticCurveTo = function(J, m, j, i) {
        var I = this.getCoords_(J, m), H = this.getCoords_(j, i), K = {
            x: this.currentX_ + 2 / 3 * (I.x - this.currentX_),
            y: this.currentY_ + 2 / 3 * (I.y - this.currentY_)
        }, G = {
            x: K.x + (H.x - this.currentX_) / 3,
            y: K.y + (H.y - this.currentY_) / 3
        };
        p(this, K, G, H);
    }, l.arc = function(M, K, L, H, j, m) {
        L *= a;
        var Q = m ? "at" : "wa", N = M + E(H) * L - o, P = K + s(H) * L - o, i = M + E(j) * L - o, O = K + s(j) * L - o;
        N != i || m || (N += .125);
        var G = this.getCoords_(M, K), J = this.getCoords_(N, P), I = this.getCoords_(i, O);
        this.currentPath_.push({
            type: Q,
            x: G.x,
            y: G.y,
            radius: L,
            xStart: J.x,
            yStart: J.y,
            xEnd: I.x,
            yEnd: I.y
        });
    }, l.rect = function(m, j, i, G) {
        this.moveTo(m, j), this.lineTo(m + i, j), this.lineTo(m + i, j + G), this.lineTo(m, j + G), 
        this.closePath();
    }, l.strokeRect = function(m, j, i, G) {
        var H = this.currentPath_;
        this.beginPath(), this.moveTo(m, j), this.lineTo(m + i, j), this.lineTo(m + i, j + G), 
        this.lineTo(m, j + G), this.closePath(), this.stroke(), this.currentPath_ = H;
    }, l.fillRect = function(m, j, i, G) {
        var H = this.currentPath_;
        this.beginPath(), this.moveTo(m, j), this.lineTo(m + i, j), this.lineTo(m + i, j + G), 
        this.lineTo(m, j + G), this.closePath(), this.fill(), this.currentPath_ = H;
    }, l.createLinearGradient = function(j, G, i, m) {
        var H = new A("gradient");
        return H.x0_ = j, H.y0_ = G, H.x1_ = i, H.y1_ = m, H;
    }, l.createRadialGradient = function(G, I, m, j, H, i) {
        var J = new A("gradientradial");
        return J.x0_ = G, J.y0_ = I, J.r0_ = m, J.x1_ = j, J.y1_ = H, J.r1_ = i, J;
    }, l.drawImage = function(T) {
        var M, K, O, ab, R, P, V, ad, N = T.runtimeStyle.width, S = T.runtimeStyle.height;
        T.runtimeStyle.width = "auto", T.runtimeStyle.height = "auto";
        var L = T.width, Z = T.height;
        if (T.runtimeStyle.width = N, T.runtimeStyle.height = S, 3 == arguments.length) M = arguments[1], 
        K = arguments[2], R = P = 0, V = O = L, ad = ab = Z; else if (5 == arguments.length) M = arguments[1], 
        K = arguments[2], O = arguments[3], ab = arguments[4], R = P = 0, V = L, ad = Z; else {
            if (9 != arguments.length) throw Error("Invalid number of arguments");
            R = arguments[1], P = arguments[2], V = arguments[3], ad = arguments[4], M = arguments[5], 
            K = arguments[6], O = arguments[7], ab = arguments[8];
        }
        var ac = this.getCoords_(M, K), aa = [], i = 10, J = 10;
        if (aa.push(" <g_vml_:group", ' coordsize="', a * i, ",", a * J, '"', ' coordorigin="0,0"', ' style="width:', i, "px;height:", J, "px;position:absolute;"), 
        1 != this.m_[0][0] || this.m_[0][1]) {
            var I = [];
            I.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", w(ac.x / a), ",", "Dy=", w(ac.y / a), "");
            var Y = ac, X = this.getCoords_(M + O, K), U = this.getCoords_(M, K + ab), Q = this.getCoords_(M + O, K + ab);
            Y.x = v.max(Y.x, X.x, U.x, Q.x), Y.y = v.max(Y.y, X.y, U.y, Q.y), aa.push("padding:0 ", w(Y.x / a), "px ", w(Y.y / a), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", I.join(""), ", sizingmethod='clip');");
        } else aa.push("top:", w(ac.y / a), "px;left:", w(ac.x / a), "px;");
        aa.push(' ">', '<g_vml_:image src="', T.src, '"', ' style="width:', a * O, "px;", " height:", a * ab, 'px;"', ' cropleft="', R / L, '"', ' croptop="', P / Z, '"', ' cropright="', (L - R - V) / L, '"', ' cropbottom="', (Z - P - ad) / Z, '"', " />", "</g_vml_:group>"), 
        this.element_.insertAdjacentHTML("BeforeEnd", aa.join(""));
    }, l.stroke = function(ag, ai, ah) {
        var L = [], au = c(ag ? this.fillStyle : this.strokeStyle), ac = au.color, ao = au.alpha * this.globalAlpha, I = 10, O = 10;
        L.push("<g_vml_:shape", ' filled="', !!ag, '"', ' style="position:absolute;width:', I, "px;height:", O, 'px;"', ' coordorigin="0 0" coordsize="', a * I, " ", a * O, '"', ' stroked="', !ag, '"', ' path="');
        for (var at = {
            x: null,
            y: null
        }, Y = {
            x: null,
            y: null
        }, an = 0; an < this.currentPath_.length; an++) {
            var ar, am = this.currentPath_[an];
            switch (am.type) {
              case "moveTo":
                ar = am, L.push(" m ", w(am.x), ",", w(am.y));
                break;

              case "lineTo":
                L.push(" l ", w(am.x), ",", w(am.y));
                break;

              case "close":
                L.push(" x "), am = null;
                break;

              case "bezierCurveTo":
                L.push(" c ", w(am.cp1x), ",", w(am.cp1y), ",", w(am.cp2x), ",", w(am.cp2y), ",", w(am.x), ",", w(am.y));
                break;

              case "at":
              case "wa":
                L.push(" ", am.type, " ", w(am.x - this.arcScaleX_ * am.radius), ",", w(am.y - this.arcScaleY_ * am.radius), " ", w(am.x + this.arcScaleX_ * am.radius), ",", w(am.y + this.arcScaleY_ * am.radius), " ", w(am.xStart), ",", w(am.yStart), " ", w(am.xEnd), ",", w(am.yEnd));
            }
            am && ((null == at.x || am.x < at.x) && (at.x = am.x), (null == Y.x || am.x > Y.x) && (Y.x = am.x), 
            (null == at.y || am.y < at.y) && (at.y = am.y), (null == Y.y || am.y > Y.y) && (Y.y = am.y));
        }
        if (L.push(' "'), ai && (L.push(" id='" + ah + "'"), L.push(' OnMouseOver="' + ai + "(event,this,'over','" + ah + "');\""), 
        L.push(' OnMouseOut="' + ai + "(event,this,'out','" + ah + "');\""), L.push(' href="javascript:' + ai + "(event,this,'click','" + ah + "');\"")), 
        L.push(">"), ag) if ("object" == typeof this.fillStyle) {
            var P = this.fillStyle, U = 0, al = {
                x: 0,
                y: 0
            }, ad = 0, S = 1;
            if ("gradient" == P.type_) {
                var R = P.x0_ / this.arcScaleX_, m = P.y0_ / this.arcScaleY_, Q = P.x1_ / this.arcScaleX_, av = P.y1_ / this.arcScaleY_, aq = this.getCoords_(R, m), ap = this.getCoords_(Q, av), K = ap.x - aq.x, J = ap.y - aq.y;
                U = 180 * Math.atan2(K, J) / Math.PI, 0 > U && (U += 360), 1e-6 > U && (U = 0);
            } else {
                var aq = this.getCoords_(P.x0_, P.y0_), j = Y.x - at.x, G = Y.y - at.y;
                al = {
                    x: (aq.x - at.x) / j,
                    y: (aq.y - at.y) / G
                }, j /= this.arcScaleX_ * a, G /= this.arcScaleY_ * a;
                var ak = v.max(j, G);
                ad = 2 * P.r0_ / ak, S = 2 * P.r1_ / ak - ad;
            }
            var ab = P.colors_;
            ab.sort(function(H, i) {
                return H.offset - i.offset;
            });
            for (var V = ab.length, aa = ab[0].color, Z = ab[V - 1].color, af = ab[0].alpha * this.globalAlpha, ae = ab[V - 1].alpha * this.globalAlpha, aj = [], an = 0; V > an; an++) {
                var T = ab[an];
                aj.push(T.offset * S + ad + " " + T.color);
            }
            L.push('<g_vml_:fill type="', P.type_, '"', ' method="none" focus="100%"', ' color="', aa, '"', ' color2="', Z, '"', ' colors="', aj.join(","), '"', ' opacity="', ae, '"', ' g_o_:opacity2="', af, '"', ' angle="', U, '"', ' focusposition="', al.x, ",", al.y, '" />');
        } else L.push('<g_vml_:fill color="', ac, '" opacity="', ao, '" />'); else {
            var X = this.lineScale_ * this.lineWidth;
            1 > X && (ao *= X), L.push("<g_vml_:stroke", ' opacity="', ao, '"', ' joinstyle="', this.lineJoin, '"', ' miterlimit="', this.miterLimit, '"', ' endcap="', t(this.lineCap), '"', ' weight="', X, 'px"', ' color="', ac, '" />');
        }
        L.push("</g_vml_:shape>"), this.element_.insertAdjacentHTML("beforeEnd", L.join(""));
    }, l.fill = function() {
        this.stroke(!0);
    }, l.closePath = function() {
        this.currentPath_.push({
            type: "close"
        });
    }, l.getCoords_ = function(G, j) {
        var i = this.m_;
        return {
            x: a * (G * i[0][0] + j * i[1][0] + i[2][0]) - o,
            y: a * (G * i[0][1] + j * i[1][1] + i[2][1]) - o
        };
    }, l.save = function() {
        var i = {};
        x(this, i), this.aStack_.push(i), this.mStack_.push(this.m_), this.m_ = d(r(), this.m_);
    }, l.restore = function() {
        x(this.aStack_.pop(), this), this.m_ = this.mStack_.pop();
    }, l.translate = function(m, j) {
        var i = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ m, j, 1 ] ];
        B(this, d(i, this.m_), !1);
    }, l.rotate = function(j) {
        var G = E(j), m = s(j), i = [ [ G, m, 0 ], [ -m, G, 0 ], [ 0, 0, 1 ] ];
        B(this, d(i, this.m_), !1);
    }, l.scale = function(m, j) {
        this.arcScaleX_ *= m, this.arcScaleY_ *= j;
        var i = [ [ m, 0, 0 ], [ 0, j, 0 ], [ 0, 0, 1 ] ];
        B(this, d(i, this.m_), !0);
    }, l.transform = function(H, G, J, I, j, i) {
        var m = [ [ H, G, 0 ], [ J, I, 0 ], [ j, i, 1 ] ];
        B(this, d(m, this.m_), !0);
    }, l.setTransform = function(I, H, K, J, G, j) {
        var i = [ [ I, H, 0 ], [ K, J, 0 ], [ G, j, 1 ] ];
        B(this, i, !0);
    }, l.clip = function() {}, l.arcTo = function() {}, l.createPattern = function() {
        return new f();
    }, A.prototype.addColorStop = function(j, i) {
        i = c(i), this.colors_.push({
            offset: j,
            color: i.color,
            alpha: i.alpha
        });
    }, G_vmlCanvasManager = k, CanvasRenderingContext2D = q, CanvasGradient = A, CanvasPattern = f;
}(), function(d) {
    var f = {
        defaults: {
            MapId: null,
            MapSet: "tu",
            MapType: "Interactive",
            EventId: null,
            AutoSwitchToStatic: !0,
            SeatingChartAutoCorrect: !0,
            FailoverMapUrl: null,
            Columns: {
                flag: {
                    Title: "",
                    Sortable: !1,
                    Visible: !1,
                    Width: 50,
                    Formatter: function(i) {
                        var h = "";
                        return i.preferred && (h += '<span class="tuMapPreferred"></span>'), i.eticket && (h += '<span class="tuMapeTicket"></span>'), 
                        h;
                    }
                },
                section: {
                    Title: "Section",
                    Sortable: !0,
                    Width: 150,
                    SortType: "string",
                    Visible: !0
                },
                row: {
                    Title: "Row",
                    Sortable: !0,
                    SortType: "string",
                    Visible: !0
                },
                quantity: {
                    Title: "Quantity",
                    Sortable: !0,
                    SortType: "numeric",
                    Visible: !0,
                    Formatter: function(i, g, j) {
                        var h = "";
                        if ("object" == typeof j) {
                            var h = '<select lang="Quantity">';
                            d.each(j, function(l, k) {
                                h += "<option>" + k + "</option>";
                            }), h += "</select>";
                        } else h = j + '<input type="hidden" value="' + j + '" lang="Quantity"/>';
                        return h;
                    }
                },
                price: {
                    Title: "Price",
                    Sortable: !0,
                    SortType: "numeric",
                    Visible: !0
                },
                notes: {
                    Title: "",
                    Width: 35,
                    Sortable: !1,
                    Visible: !0,
                    Formatter: function(h, g, i) {
                        return "" != i ? '<span class="Notes" title="' + i + '"></span>' : "";
                    }
                },
                action: {
                    Title: "",
                    Sortable: !1,
                    Visible: !0,
                    Formatter: function(h) {
                        return '<a class="BuyLink" href="javascript:void(0);" lang="' + h.id + '">' + f.Settings.BuyButtonText + "</a>";
                    }
                }
            },
            DisplayListHeader: !0,
            PreferredFirst: !1,
            Tickets: [],
            TicketsFilter: {
                MinPrice: 0,
                MaxPrice: 0,
                Quantity: 0,
                Ids: null
            },
            TicketsSort: {
                Column: "section",
                Order: "ASC",
                SortType: "string"
            },
            TicketsListContainer: null,
            SectionViewContainer: null,
            SectionViewTrigger: "mouseover",
            TooltipSectionViewSize: "250",
            EnableTooltipSectionView: !0,
            AlwaysShowTooltip: !1,
            AnimateTooltip: !1,
            SingleSectionSelection: !1,
            RowSelector: null,
            SectionSelector: null,
            RowNumberSelector: null,
            PriceSelector: null,
            QuantitySelector: null,
            eTicketSelector: null,
            BuyButtonText: "Select",
            PreferredText: "Display Preferred Inventory First",
            ResetButtonText: "Reset",
            GroupsContainer: null,
            ControlsPosition: "Inside",
            ZoomLevel: 3,
            AdaptiveThreshold: 1,
            MaxZoom: 0,
            BgColor: "#FFFFFF",
            ServiceUrl: "http://imap.ticketutils.net",
            OnInit: null,
            OnBeforeListRender: null,
            OnAfterListRender: null,
            OnClick: null,
            OnGroupClick: null,
            OnMouseover: null,
            OnMouseout: null,
            OnError: null,
            OnReset: null,
            OnTicketSelected: null,
            OnControlClick: null,
            ColorScheme: 0,
            HighlightStyle: {
                strokeWeight: 2,
                fillColor: "#0000FF",
                fillOpacity: .2
            },
            NormalStyle: {
                fillOpacity: 0,
                fillColor: "#FFFFFF",
                strokeColor: "#FFFFFF",
                strokeWeight: 0
            },
            SelectedStyle: {
                strokeWeight: 2,
                fillColor: "#FFFFFF",
                fillOpacity: .3
            },
            InactiveStyle: {
                strokeColor: "#FFFFFF",
                strokeWeight: 0,
                fillColor: "#666666",
                fillOpacity: .7
            },
            NoResultsFormatter: function() {
                return "No Tickets Found";
            },
            TooltipFormatter: function(i) {
                var g = '<div style="width:' + f.Settings.TooltipSectionViewSize + 'px;">', h = i.LongName;
                return g += '<span class="SectionColor" style="background-color:' + i.Group.Color + ';"></span>', 
                g += '<span class="Title">' + h + "</span>", "" != i.RowDetails && (g += '<span class="RowDetails">Row: ' + i.RowDetails + "</span>"), 
                g += '<span class="SectionViewClose"></span><br/>', i.SectionViewThumbnailUrl && (f.ShowSectionView(i.Key, "mouseover"), 
                f.Settings.EnableTooltipSectionView && (g += '<img src="' + i.SectionViewThumbnailUrl + '" alt="' + h + '" style="width:100%;height:' + Math.round(f.Settings.TooltipSectionViewSize / 2) + 'px"/>', 
                g += '<div class="SectionViewZoom"></div>', g += "<br/>", g += '<div style="color:#666666;font-size:9px;padding-bottom:5px;">Approximate view from this section. May differ based on row, seat, camera or obstructions.</div>')), 
                i.Active ? i.Quantity > 0 && (g += '<span class="tuMapHighlight">' + i.Quantity + "</span> ticket" + (i.Quantity > 1 ? "s" : "") + " available from " + i.MinPrice + (i.MinPrice != i.MaxPrice ? " to " + i.MaxPrice : "")) : g += "No Tickets currently available for this Section", 
                g += "</div>";
            }
        },
        Container: null,
        Map: null,
        Groups: {},
        Sections: {},
        Selection: [],
        ParkingFlag: !1,
        PreferredFlag: !1,
        eTicketFlag: !1,
        ConvertZoom: function(g) {
            return g || (g = f.Settings.ZoomLevel - 1), e.Resolutions.length > g ? e.Resolutions[g] / 100 : (e.Zoom = e.Resolutions.length - 1, 
            e.Resolutions[e.Resolutions.length - 1] / 100);
        },
        ZoomIn: function() {
            return e.ZoomIn();
        },
        ZoomOut: function() {
            return e.ZoomOut();
        },
        Reset: function() {
            f.HideSectionView("click"), e.Wrapper.trigger("OnReset");
        },
        SetOptions: function(g) {
            return d.each(g, function(h, l) {
                switch (f.Settings[h] = l, h) {
                  case "Tickets":
                  case "Columns":
                    "Reset" != f.RefreshType && (f.RefreshType = "ProcessTickets");
                    break;

                  case "PreferredFirst":
                  case "TicketsSort":
                    "Reset" != f.RefreshType && "ProcessTickets" != f.RefreshType && (f.RefreshType = "SortTickets");
                    break;

                  case "PreferredText":
                  case "TicketsFilter":
                    var n = f.Settings.TicketsFilter.Quantity, o = 0, k = "eq";
                    if ("string" == typeof f.Settings.TicketsFilter.Quantity) {
                        var i = f.Settings.TicketsFilter.Quantity.indexOf("-");
                        if (-1 != i) n = f.Settings.TicketsFilter.Quantity.substring(0, i), o = f.Settings.TicketsFilter.Quantity.substring(i + 1), 
                        k = "bt"; else {
                            n = f.Settings.TicketsFilter.Quantity.replace(/[^0-9]+/g, "").toString();
                            var m = d.trim(f.Settings.TicketsFilter.Quantity.replace(n, ""));
                            "+" == m && (k = "gt");
                        }
                    }
                    var j = {
                        MinPrice: parseFloat(f.Settings.TicketsFilter.MinPrice),
                        MaxPrice: parseFloat(f.Settings.TicketsFilter.MaxPrice),
                        Quantity: parseInt(n),
                        MaxQuantity: parseInt(o),
                        Comparison: k,
                        eTicket: f.Settings.TicketsFilter.eTicket,
                        Ids: null != f.Settings.TicketsFilter.Ids && f.Settings.TicketsFilter.Ids.length > 0 ? f.Settings.TicketsFilter.Ids : null
                    };
                    f.Settings.TicketsFilter = j, "Reset" != f.RefreshType && (f.RefreshType = "ProcessTickets");
                    break;

                  case "ZoomLevel":
                    e.Zoom = f.Settings.ZoomLevel, e.CheckMaxZoom(), e.SetZoom(f.ConvertZoom());
                    break;

                  case "EventId":
                  case "MapId":
                  case "MapSet":
                  case "MapType":
                  case "Columns":
                  case "TicketsListContainer":
                  case "GroupsContainer":
                  case "TooltipFormatter":
                    f.RefreshType = "Reset";
                }
            }), this;
        },
        AddMapControl: function(i, g, h) {
            e.AddMapControl(i, g, h);
        },
        RemoveMapControl: function(g) {
            d(".tuMapControl").each(function() {
                return d.trim(d(this).html()).toLowerCase() == g.toLowerCase() ? (d(this).remove(), 
                "Inside" == f.Settings.ControlsPosition && e.ControlsContainer.css("margin-left", 0 - parseInt(e.ControlsContainer.width() / 2)), 
                !1) : void 0;
            });
        },
        GetSelectedSections: function(h) {
            var g = [];
            return d.each(f.Selection, function(m, j) {
                var l = f.Sections[j], i = null;
                if (l) {
                    if (h) {
                        if (h.IncludeGroupName) {
                            {
                                f.Groups[l.GroupId];
                            }
                            g.push(l.LongName);
                        } else g.push(l.Name);
                        return;
                    }
                    i = l.Mappings;
                } else if (f.OtherSections[j]) {
                    if (h) return void g.push(f.OtherSections[j].Name);
                    i = f.OtherSections[j].Mappings;
                }
                d.each(i, function(o, n) {
                    g.push(n);
                });
            }), g;
        },
        GetSections: function(h) {
            var g = [];
            return d.each(f.Sections, function(j, i) {
                h && 0 == i.Alias.length || g.push({
                    Active: i.Active,
                    Selected: i.Selected,
                    Key: i.Key,
                    Name: i.Name,
                    DisplayName: i.DisplayName,
                    DisplayGroupName: i.DisplayGroupName,
                    Alias: i.Alias,
                    ExactMatchAlias: i.ExactMatchAlias,
                    Group: f.Groups[i.GroupId],
                    SectionViewAvailable: i.IsSectionViewAvailable,
                    SectionViewThumbnailUrl: i.SectionViewThumbnailUrl,
                    SectionViewUrl: i.SectionViewUrl
                });
            }), g;
        },
        GetOtherSections: function() {
            var g = [];
            return d.each(f.OtherSections, function(i, h) {
                g.push({
                    Name: h.Name,
                    Alias: h.Alias,
                    Enabled: h.Enabled,
                    IsExactMatch: h.IsExactMatch
                });
            }), g;
        },
        GetSectionsInGroup: function(h, i, g) {
            d.each(f.Sections, function(j, k) {
                if (null != k && k && k.GroupId == h) {
                    if (null != i && i.OnlyActive && !k.Active) return;
                    if (null != i && i.OnlyUnselected && k.Selected) return;
                    g(j, k);
                }
            });
        },
        HighlightGroup: function(g) {
            return this.GetSectionsInGroup(g, {
                OnlyActive: !0,
                OnlyUnselected: !0
            }, function(h, i) {
                i.SetStyle(f.Settings.HighlightStyle);
            }), this;
        },
        ResetGroup: function(g) {
            return this.GetSectionsInGroup(g, {
                OnlyActive: !0,
                OnlyUnselected: !0
            }, function(h, i) {
                i.SetStyle(f.Settings.NormalStyle);
            }), this;
        },
        HighlightSection: function(g, i) {
            i || (g = f.GetSectionKey(g));
            var h = f.Sections[g];
            return null != h && e.Trigger("OnMouseOver", f.Sections[g]), this;
        },
        ResetSection: function(g, i) {
            i || (g = f.GetSectionKey(g));
            var h = f.Sections[g];
            return null != h && e.Trigger("OnMouseOut", f.Sections[g]), this;
        },
        BlinkTimer: null,
        BlinkState: 1,
        Blink: function() {
            var g = f.Settings.HighlightStyle;
            1 == f.BlinkState ? (g = f.Settings.SelectedStyle, f.BlinkState = 0, d(".tuMapControlSelected").addClass("tuMapControlBlink").removeClass("tuMapControlSelected")) : (f.BlinkState = 1, 
            d(".tuMapControlBlink").addClass("tuMapControlSelected").removeClass("tuMapControlBlink")), 
            d.each(f.Selection, function(j, h) {
                var i = f.Sections[h];
                null != i && i.SetStyle(g);
            });
        },
        FilterTickets: function(g, h, k, j) {
            if (k || (f.Selection.length > 0 && (d.each(f.Selection, function(l, m) {
                f.Sections[m] && (f.Sections[m].Selected = !1);
            }), f.Selection = [], clearInterval(f.BlinkTimer), f.BlinkTimer = null), g = f.GetSectionKey(g)), 
            h) f.Selection.push(g), null == f.BlinkTimer && (f.BlinkTimer = setInterval(f.Blink, 500)); else {
                for (var i = -1; (i = d.inArray(g, f.Selection)) > -1; ) f.Selection.splice(i, 1);
                0 == f.Selection.length && (clearInterval(f.BlinkTimer), f.BlinkTimer = null);
            }
            j || (f.ProcessTickets(), f.SortTickets(), f.ShowTickets());
        },
        AddMarker: function(g, j) {
            var i = g.Section;
            j || (i = f.GetSectionKey(g.Section));
            var h = f.Sections[i];
            h && h.AddMarker(g.Url, h.GetCenter(), g.Offset);
        },
        RemoveMarker: function(h, i) {
            i || (h = f.GetSectionKey(h));
            var g = f.Sections[h];
            g && g.RemoveMarker(g.GetCenter());
        },
        ToggleSelection: function(j, k, g) {
            if (f.Settings.SingleSectionSelection && f.Selection.length > 0) {
                var h = f.Selection[0];
                f.Selection.length = 0, f.ToggleSelection(h, !0, !0);
            }
            k || (j = f.GetSectionKey(j));
            var i = f.Sections[j];
            if (i && i.Active) return i.Selected ? (null != f.Settings.GroupsContainer && (f.ZoneSelected = !1, 
            f.Groups[i.GroupId].Selected = !1), 0 == f.Selection.length ? f.HideSectionView("click") : f.ShowSectionView(j, "click")) : f.ShowSectionView(j, "click"), 
            i.Selected = !i.Selected, f.FilterTickets(j, i.Selected, !0, g), this;
        },
        ToggleAll: function() {
            d.each(f.Sections, function(h, g) {
                f.ToggleSelection(g.Key, !0, !0);
            }), f.ProcessTickets(), f.SortTickets(), f.ShowTickets();
        },
        ProcessTickets: function() {
            var j = null == f.Settings.TicketsListContainer && (null == f.Settings.Tickets || 0 == f.Settings.Tickets.length) && null == f.Settings.RowSelector;
            d.each(f.Sections, function(m, n) {
                n.Active = j, n.FilteredTickets = 0, n.MinPrice = 9007199254740992, n.MaxPrice = 0, 
                n.MinPriceValue = "", n.MinPriceValue = "", n.Quantity = 0, n.SetStyle(f.Settings.InactiveStyle);
            }), d.each(f.Groups, function(m) {
                f.Groups[m].ActiveSections = 0, f.Groups[m].HasZoneTickets = !1;
            });
            var l = f.Settings.Tickets;
            f.FilteredTickets = [];
            if (!f.Settings.TicketsListContainer && f.Settings.RowSelector && (null == l || 0 == l.length)) {
                if (!f.Settings.SectionSelector) throw "Section Selector Required";
                l = [];
                var i = /<\S[^><]*>/g;
                d(f.Settings.RowSelector).each(function() {
                    var v = null, m = null, q = d(this).find(f.Settings.SectionSelector).text().replace(i, "");
                    "" == q && f.Settings.ZoneSelector ? v = d(this).find(f.Settings.ZoneSelector).text().replace(i, "") : m = d(this).find(f.Settings.RowNumberSelector).text().replace(i, "");
                    var o = f.Settings.PriceSelector ? d(this).find(f.Settings.PriceSelector).text().replace(i, "") : 0, n = 0;
                    if (f.Settings.QuantitySelector) {
                        var p = d(this).find(f.Settings.QuantitySelector);
                        p.length > 0 && (1 == p.length ? n = d.trim(p.text().replace(i, "")) : (n = [], 
                        d.each(p, function(w, x) {
                            n.push(parseInt(d.trim(d(x).text().replace(i, ""))));
                        })));
                    }
                    var r = f.Settings.eTicketSelector ? d(this).find(f.Settings.eTicketSelector).length > 0 : !1, s = d(this), u = "Zone", t = null;
                    v ? t = f.GetZone(v) : u = f.GetSectionKey(q, m), d(this).mouseenter(function() {
                        f.HighlightSection(u, !0);
                    }).mouseleave(function() {
                        f.ResetSection(u, !0);
                    }), l.push({
                        SectionKey: u,
                        ZoneKey: t,
                        section: q,
                        row: m,
                        RowObject: s,
                        price: o,
                        quantity: n,
                        eticket: r
                    });
                });
            }
            var k = f.IsFilterSet();
            d.each(l, function(p, n) {
                if (n.section ? null == n.SectionKey && (n.SectionKey = f.GetSectionKey(n.section, n.row)) : n.zone && null == n.ZoneKey && (n.ZoneKey = f.GetZone(n.zone), 
                n.SectionKey = "Zone"), "Parking" == n.SectionKey && (f.ParkingFlag = !0), n.price && (n.PriceValue = "number" == typeof n.price ? n.price : parseFloat(n.price.replace(/[^0-9.-]+/g, ""))), 
                f.Settings.Columns.flag && (n.preferred && (f.Settings.Columns.flag.Visible = !0, 
                f.PreferredFlag = !0), n.eticket && (f.Settings.Columns.flag.Visible = !0, f.eTicketFlag = !0)), 
                n.MaxQuantity = 0, n.quantity && ("object" == typeof n.quantity ? d.each(n.quantity, function(r, q) {
                    parseInt(q) > n.MaxQuantity && (n.MaxQuantity = parseInt(q));
                }) : n.MaxQuantity = parseInt(n.quantity)), 0 != n.MaxQuantity) {
                    var o = f.IsTicketFiltered(n);
                    if (o && (!(f.Selection.length > 0 && -1 == d.inArray(n.SectionKey, f.Selection)) || n.ZoneKey && f.Groups[n.ZoneKey].Selected)) {
                        var m = f.Sections[n.SectionKey];
                        (!f.ZoneSelected || n.ZoneKey || null == m || 0 != f.Groups[m.GroupId].Selected) && (f.FilteredTickets.push(n), 
                        null != m && (n.GroupColor = f.Groups[m.GroupId].Color));
                    }
                    if (f.Sections[n.SectionKey]) {
                        var m = f.Sections[n.SectionKey];
                        n.FormattedSection = m.LongName, n.CleanGroupName = m.CleanGroupName, n.CleanSectionName = m.CleanSectionName, 
                        o && f.Sections[n.SectionKey].FilteredTickets++, f.Sections[n.SectionKey].MinPrice > n.PriceValue && (f.Sections[n.SectionKey].MinPrice = n.PriceValue, 
                        f.Sections[n.SectionKey].MinPriceValue = n.price), f.Sections[n.SectionKey].MaxPrice < n.PriceValue && (f.Sections[n.SectionKey].MaxPrice = n.PriceValue, 
                        f.Sections[n.SectionKey].MaxPriceValue = n.price), f.Sections[n.SectionKey].Quantity += n.MaxQuantity, 
                        f.Sections[n.SectionKey].Active = !0;
                    }
                    n.ZoneKey && (f.Groups[n.ZoneKey].HasZoneTickets = !0);
                }
            }), l = null;
            var h = !1;
            d.each(f.Sections, function(m, n) {
                return !n.Active || k && 0 == n.FilteredTickets ? (n.Selected && (f.Sections[m].Active = !0, 
                f.ToggleSelection(m, !0, !0), h = !0), f.Sections[m].Active = !1, void n.SetStyle(f.Settings.InactiveStyle)) : (n.SetStyle(f.Settings.NormalStyle), 
                void f.Groups[n.GroupId].ActiveSections++);
            }), h && (f.ProcessTickets(), f.SortTickets(), f.ShowTickets()), null != f.Settings.GroupsContainer && f.Groups && f.GenerateGroups();
        },
        SortTickets: function() {
            if (null != f.Settings.TicketsListContainer) {
                var k = f.Settings.TicketsSort.SortType;
                null == k && (k = "string");
                var g = f.Settings.TicketsSort.Column, j = null, h = f.Settings.Columns[f.Settings.TicketsSort.Column];
                null != h && (k = h.SortType), "price" == g ? g = "PriceValue" : "quantity" == g ? g = "MaxQuantity" : "section" == g && (j = "row");
                var i = f.Settings.TicketsSort.Order.toUpperCase();
                f.FilteredTickets.sort(function(x, v) {
                    var s = null, p = null, n = null, l = null, r = 1 == x.preferred, w = 1 == v.preferred;
                    if ("string" == k) {
                        s = x[g].toString().toUpperCase(), p = v[g].toString().toUpperCase();
                        var u = parseFloat(s), t = parseFloat(p);
                        if (isNaN(u) || isNaN(t)) {
                            if (!isNaN(u) && isNaN(t)) return "ASC" == i ? -1 : 1;
                            if (isNaN(u) && !isNaN(t)) return "ASC" == i ? 1 : -1;
                        } else s = u, p = t;
                        if (null != j && x[j]) {
                            n = x[j].toString().toUpperCase(), l = v[j].toString().toUpperCase();
                            var q = parseFloat(n), o = parseFloat(l);
                            isNaN(q) || isNaN(o) || (n = q, l = o);
                        }
                    } else s = parseFloat(x[g]), p = parseFloat(v[g]);
                    if (f.Settings.PreferredFirst && r != w) return "ASC" == i ? r ? -1 : 1 : r ? -1 : 1;
                    var m = 0;
                    return m = "ASC" == i ? p > s ? -1 : s > p ? 1 : 0 : p > s ? 1 : s > p ? -1 : 0, 
                    0 == m && null != n && null != l ? l > n ? -1 : n > l ? 1 : 0 : m;
                });
            }
        },
        AddSectionMapping: function(g, h) {
            f.Sections[g] && -1 == d.inArray(h, f.Sections[g].Mappings) && f.Sections[g].Mappings.push(h), 
            f.OtherSections[g] && -1 == d.inArray(h, f.OtherSections[g].Mappings) && f.OtherSections[g].Mappings.push(h);
        },
        GetZone: function(h) {
            var g = "";
            return d.each(f.Groups, function(k, j) {
                return j.Name.toLowerCase() == h.toLowerCase() ? (g = j.Id, !1) : void d.each(j.Alias, function() {
                    return j.Alias == h ? (g = j.Id, !1) : void 0;
                });
            }), g;
        },
        GetSectionKey: function(h, k) {
            k = parseInt(k);
            var g = "Unmapped", SectionName = h.toLowerCase();
            SectionName = d.trim(SectionName.replace(/[^0-9a-z]+/g, " "));
            var j = "", m = "", l = [];
            if (d.each(f.Groups, function(o, n) {
                return d.each(n.Alias, function(p, r) {
                    var q = SectionName.indexOf(r);
                    if (-1 != q && (0 == q || q == SectionName.length - r.length) && r.length >= m.length) {
                        if (m = r, l.push({
                            GroupId: n.Id,
                            Alias: r
                        }), 1 == n.SectionCount) return g = n.Id, !1;
                        if (j = d.trim(SectionName.replace(m, "")), f.Sections[j + "_" + n.Id]) return g = j + "_" + n.Id, 
                        !1;
                    }
                }), "Unmapped" != g ? !1 : void 0;
            }), "Unmapped" != g) return f.AddSectionMapping(g, h), g;
            var i = [];
            return d.each(l, function(n, o) {
                o.Alias.length == m.length && i.push(o.GroupId);
            }), l = i, 0 == l.length && (j = SectionName.replace(/[^0-9]+/g, "").toString(), 
            m = SectionName.replace(j, "")), d.each(f.Sections, function(p, o) {
                var n = f.Groups[o.GroupId];
                if (null != n) {
                    if (o.Name.toLowerCase() == SectionName) {
                        if (n.IsExactMatch && f.SectionCounts[SectionName] > 1) return;
                        if (o.RowStart > 0 && o.RowEnd > 0 && (k < o.RowStart || k > o.RowEnd)) return;
                        return g = o.Key, !1;
                    }
                    if (o.Name.toLowerCase() == j && (!n.IsExactMatch || -1 != d.inArray(n.Id, l))) return g = f.ResolveOtherSection(SectionName), 
                    "Unmapped" == g ? g = o.Key : f.OtherSections[g] && (f.OtherSections[g].Enabled = !0), 
                    !1;
                    "Unmapped" == g && null != o.ExactMatchAlias && o.ExactMatchAlias.length > 0 && d.each(o.ExactMatchAlias, function(q, r) {
                        return r == SectionName ? (g = o.Key, !1) : void 0;
                    }), "Unmapped" == g && null != o.Alias && o.Alias.length > 0 && d.each(o.Alias, function(q, r) {
                        if (r == SectionName) return g = o.Key, !1;
                        if (r == j) {
                            if (n.IsExactMatch && -1 == d.inArray(n.Id, l)) return;
                            return g = f.ResolveOtherSection(SectionName), "Unmapped" == g ? g = o.Key : f.OtherSections[g] && (f.OtherSections[g].Enabled = !0), 
                            !1;
                        }
                    });
                }
            }), "Unmapped" == g && (g = f.ResolveOtherSection(SectionName), f.OtherSections[g] && (f.OtherSections[g].Enabled = !0)), 
            f.AddSectionMapping(g, h), g;
        },
        ResolveOtherSection: function(h) {
            var g = "Unmapped";
            return d.each(f.OtherSections, function(j, i) {
                if (i.IsExactMatch) {
                    if (j.toLowerCase() == h) return g = j, !1;
                } else if (-1 != h.indexOf(j.toLowerCase())) return g = j, !1;
                null != i.Alias && i.Alias.length > 0 && d.each(i.Alias, function(k, l) {
                    if (i.IsExactMatch) {
                        if (l == h) return g = j, !1;
                    } else if (-1 != h.indexOf(l)) return g = j, !1;
                });
            }), g;
        },
        IsFilterSet: function() {
            return f.Settings.TicketsFilter.MinPrice > 0 || f.Settings.TicketsFilter.MaxPrice > 0 || 1 == f.Settings.TicketsFilter.eTicket || f.Settings.TicketsFilter.Quantity > 0 || null != f.Settings.TicketsFilter.Ids;
        },
        IsTicketFiltered: function(g) {
            if (null != f.Settings.TicketsFilter.Ids && -1 == d.inArray(g.id, f.Settings.TicketsFilter.Ids)) return !1;
            if (f.Settings.TicketsFilter.MinPrice > 0 && g.PriceValue > 0 && g.PriceValue < f.Settings.TicketsFilter.MinPrice) return !1;
            if (f.Settings.TicketsFilter.MaxPrice > 0 && g.PriceValue > 0 && g.PriceValue > f.Settings.TicketsFilter.MaxPrice) return !1;
            if (f.Settings.TicketsFilter.eTicket && f.eTicketFlag && !g.eticket) return !1;
            if (!isNaN(f.Settings.TicketsFilter.Quantity) && f.Settings.TicketsFilter.Quantity > 0) if ("eq" == f.Settings.TicketsFilter.Comparison) {
                if ("object" == typeof g.quantity) {
                    if (-1 == d.inArray(f.Settings.TicketsFilter.Quantity, g.quantity)) return !1;
                } else if (g.MaxQuantity > 0 && g.MaxQuantity != f.Settings.TicketsFilter.Quantity) return !1;
            } else {
                if ("gt" == f.Settings.TicketsFilter.Comparison && g.MaxQuantity > 0 && g.MaxQuantity < f.Settings.TicketsFilter.Quantity) return !1;
                if ("bt" == f.Settings.TicketsFilter.Comparison) if ("object" == typeof g.quantity) {
                    if (-1 == d.inArray(f.Settings.TicketsFilter.Quantity, g.quantity)) return !1;
                    if (-1 == d.inArray(f.Settings.TicketsFilter.MaxQuantity, g.quantity)) return !1;
                } else if (g.quantity < f.Settings.TicketsFilter.MaxQuantity || g.MaxQuantity > 0 && g.MaxQuantity > f.Settings.TicketsFilter.MaxQuantity) return !1;
            }
            return !0;
        },
        ShowTickets: function() {
            if (null == f.Settings.TicketsListContainer) return void (null != f.Settings.RowSelector && (d(f.Settings.RowSelector).hide(), 
            d.each(f.FilteredTickets, function(i, h) {
                h.RowObject.show();
            })));
            var g = 0;
            c.Initialize({
                Container: f.vTableContainer,
                Rows: f.FilteredTickets.length,
                TableFormatter: function(h) {
                    return h;
                },
                ColumnsFormatter: function(h) {
                    return f.Settings.DisplayListHeader ? (d.each(f.Settings.Columns, function(i, j) {
                        if (null == j.Visible || j.Visible) {
                            g++;
                            var k = d("<th>");
                            j.Sortable && k.addClass("Sort" + (i == f.Settings.TicketsSort.Column ? " " + f.Settings.TicketsSort.Order : "")), 
                            j.Width && k.css("width", j.Width + "px"), k.attr("lang", i).html("<span>" + j.Title + "</span>"), 
                            k.click(function() {
                                if (d(this).hasClass("Sort")) {
                                    var l = "";
                                    l = d(this).hasClass("ASC") ? "DESC" : "ASC", f.Settings.TicketsSort = {
                                        Column: i,
                                        Order: l
                                    }, f.SortTickets(), f.ShowTickets();
                                }
                            }), h.append(k);
                        }
                    }), h) : h.css("display", "none");
                },
                RowFormatter: function(i, j) {
                    var h = f.FilteredTickets[j];
                    return i.addClass(j % 2 == 0 ? "EvenRow" : "OddRow"), d.each(f.Settings.Columns, function(k, l) {
                        if (null == l.Visible || l.Visible) {
                            var m = d("<td>");
                            if (l.CSSClass && m.addClass(l.CSSClass), l.Align && m.css("text-align", l.Align), 
                            !h.section && h.zone) if ("section" == k) m.attr("colspan", 2), k = "zone"; else if ("row" == k) return;
                            m.html(l.Formatter ? l.Formatter(h, k, h[k], null != h.FormattedSection ? h.FormattedSection : h.section, null != h.CleanGroupName ? h.CleanGroupName : "", null != h.CleanSectionName ? h.CleanSectionName : h.section) : h[k]), 
                            i.append(m), m.children(".BuyLink").click(function() {
                                var o = d(this).attr("lang"), n = 0;
                                i.children("td").each(function() {
                                    var p = d(this).children("[lang=Quantity]");
                                    return p.length > 0 ? (n = d(p[0]).val(), !1) : void 0;
                                }), f.Container.trigger("OnTicketSelected", {
                                    Id: o,
                                    Quantity: n
                                });
                            }), m.children(".Notes").hover(function() {
                                var n = d.trim(d(this).attr("title"));
                                if ("" != n) {
                                    var o = d(this).position();
                                    f.Tooltip.css({
                                        top: o.top + 20,
                                        left: o.left + 20
                                    }).html(n), f.Tooltip.show(), d(this).attr("title", "");
                                }
                            }, function() {
                                d(this).attr("title", f.Tooltip.html()), f.Tooltip.hide();
                            });
                        }
                    }), i.hover(function() {
                        f.HighlightSection(h.SectionKey, !0);
                    }, function() {
                        f.ResetSection(h.SectionKey, !0);
                    }), i;
                },
                NoResultsFormatter: function(h) {
                    return h.append(d("<td>").attr("colspan", g).html(f.Settings.NoResultsFormatter()));
                }
            }), f.Container.trigger("OnAfterListRender");
        },
        ShowTooltip: function(k, j, n) {
            if (!f.TooltipZoomed) {
                f.TooltipTimeout && (clearTimeout(f.TooltipTimeout), f.TooltipTimeout = null), n || (k = f.GetSectionKey(k));
                var m = f.Sections[k];
                if (!(f.Settings.AlwaysShowTooltip || m.Active && 0 != m.Quantity)) return void f.HideTooltip();
                var h = f.Settings.TooltipFormatter({
                    Key: m.Key,
                    Section: m.Name,
                    DisplayName: null != m.DisplayName ? m.DisplayName : m.Name,
                    LongName: m.LongName,
                    Mappings: m.Mappings,
                    DisplayGroupName: m.DisplayGroupName,
                    SectionViewThumbnailUrl: m.SectionViewThumbnailUrl,
                    SectionViewUrl: m.SectionViewUrl,
                    Group: f.Groups[m.GroupId],
                    Active: m.Active,
                    Quantity: m.Quantity,
                    MinPrice: m.MinPriceValue,
                    MaxPrice: m.MaxPriceValue,
                    RowDetails: m.RowDetails
                });
                if (f.Tooltip.html(h), f.Settings.EnableTooltipSectionView) {
                    var l = function() {
                        f.Tooltip.unbind().hide().css("position", "absolute"), f.TooltipTimeout = null, 
                        f.TooltipZoomed = !1, d(".SectionViewBG").remove();
                    }, g = function(o) {
                        f.TooltipZoomed = !0, d("<div>").attr("class", "SectionViewBG").css("width", "100%").css("height", "100%").css("position", "fixed").css("left", 0).css("top", 0).css("z-index", 999).appendTo(d("body")).click(function() {
                            l();
                        }), f.Tooltip.animate({
                            left: (d(window).outerWidth(!0) - f.SectionViewSize) / 2,
                            top: (d(window).outerHeight(!0) - f.SectionViewSize / 2) / 2
                        }, "fast").css("position", "fixed"), o.parent().animate({
                            width: f.SectionViewSize
                        }, "fast"), o.animate({
                            height: Math.round(f.SectionViewSize / 2)
                        }, "fast"), o.attr("src", m.SectionViewUrl), d(".SectionViewZoom", f.Tooltip).remove(), 
                        o.unbind(), o.css("cursor", "auto");
                    }, i = "Firefox" == a.browser ? "-moz-zoom-in" : "Chrome" == a.browser || "Safari" == a.browser ? "-webkit-zoom-in" : "pointer";
                    d("img", f.Tooltip).css("cursor", i).click(function(o) {
                        o.preventDefault(), g(d(this));
                    }), d(".SectionViewZoom", f.Tooltip).css("cursor", i).click(function(o) {
                        o.preventDefault(), g(d("img", f.Tooltip));
                    }), d(".SectionViewClose", f.Tooltip).click(function() {
                        l();
                    }), f.Tooltip.mouseover(function() {
                        e.MouseOnTooltip = !0;
                    }).mouseout(function() {
                        e.MouseOnTooltip = !1;
                    });
                }
                f.MoveTooltip(m, j), h = d.trim(h), "" != h && f.Tooltip.show();
            }
        },
        MoveTooltip: function(k, i) {
            var g = "BottomRight", j = k.GetCorner(i, g), h = f.Container.position();
            j.x += h.left, j.y += h.top, (j.x + f.Tooltip.width() > h.left + f.Container.outerWidth(!0) || j.x + f.Tooltip.width() > d(window).width()) && (g = "BottomLeft", 
            j = k.GetCorner(i, g), j.y += h.top, j.x = h.left + j.x - f.Tooltip.width() - 10), 
            (j.y + f.Tooltip.height() > h.top + f.Container.outerHeight(!0) || j.y + f.Tooltip.height() > d(window).height()) && (g = "BottomLeft" == g ? "TopLeft" : "TopRight", 
            j = k.GetCorner(i, g), "TopRight" == g ? j.x += h.left : j.x = h.left + j.x - f.Tooltip.width() - 10, 
            j.y = h.top + j.y - f.Tooltip.height() - 10), f.Settings.AnimateTooltip ? (f.Tooltip.stop(), 
            f.Tooltip.animate({
                top: j.y,
                left: j.x
            })) : f.Tooltip.css("top", j.y).css("left", j.x);
        },
        HideTooltip: function(h) {
            if (!f.TooltipTimeout) {
                var g = function() {
                    e.MouseOnTooltip || (d(".SectionViewBG").remove(), f.Tooltip.unbind().hide().css("position", "absolute"), 
                    h || f.HideSectionView("mouseover"), f.TooltipZoomed = !1);
                };
                f.TooltipTimeout = setTimeout(g, 800);
            }
        },
        ShowSectionView: function(k, g) {
            if (f.Settings.SectionViewContainer && f.Settings.SectionViewTrigger == g) {
                var j = f.Sections[k];
                if (!j.SectionViewUrl) return void f.HideSectionView(g);
                var i = "Approximate View from " + j.LongName, h = d("<div>");
                if ("click" == g) {
                    h.addClass("tuMapSectionViewContainer");
                    var i = d("<div>").html(i).append(d("<div>").addClass("CloseButton").click(function() {
                        f.HideSectionView(g);
                    }));
                    h.append(i);
                }
                h.append('<img src="' + j.SectionViewUrl + '" alt="' + i + '" style="max-width:100%;"/>'), 
                d(f.Settings.SectionViewContainer).html(h), d(f.Settings.SectionViewContainer).show();
            }
        },
        HideSectionView: function(g) {
            f.Settings.SectionViewContainer && f.Settings.SectionViewTrigger == g && (d(f.Settings.SectionViewContainer).html(""), 
            d(f.Settings.SectionViewContainer).hide());
        },
        InitSection: function(i, h) {
            i.Key = 1 == f.Groups[i.GroupId].SectionCount ? i.GroupId : i.Name.toLowerCase() + "_" + i.GroupId;
            var g = f.Groups[i.GroupId];
            i.LongName = (i.DisplayGroupName ? (null != g.DisplayName ? g.DisplayName : g.Name) + " " : "") + (null != i.DisplayName ? i.DisplayName : i.Name), 
            i.CleanGroupName = i.DisplayGroupName ? null != g.DisplayName ? g.DisplayName : g.Name : "", 
            i.CleanSectionName = null != i.DisplayName ? i.DisplayName : i.Name, f.SectionCounts[i.Name.toLowerCase()] || (f.SectionCounts[i.Name.toLowerCase()] = 0), 
            f.SectionCounts[i.Name.toLowerCase()]++, i.IsSectionViewAvailable && (i.IsSectionViewAvailable = null != h), 
            i.Active = null == f.Settings.TicketsListContainer && null == f.Settings.RowSelector, 
            i.IsSectionViewAvailable && (i.SectionViewThumbnailUrl = h + f.Settings.TooltipSectionViewSize + "X/" + i.Key + ".jpg", 
            i.SectionViewUrl = h + f.SectionViewSize + "X/" + i.Key + ".jpg"), e.Add(new b.Map.Section(i));
        },
        Refresh: function(g) {
            switch (null != g && (f.RefreshType = g), f.RefreshType) {
              case "Reset":
                !f.Settings.TicketsListContainer && f.Settings.RowSelector ? f.Settings.Tickets = null : f.Settings.Tickets ? d.each(f.Settings.Tickets, function(h, i) {
                    i.SectionKey = null;
                }) : f.Settings.Tickets = [], d.extend(f.Settings, f.GetStyles(f.Settings.ColorScheme)), 
                d(this).tuMap(f.Settings);
                break;

              case "ProcessTickets":
                f.ProcessTickets(), f.SortTickets(), f.ShowTickets();
                break;

              case "SortTickets":
                f.SortTickets(), f.ShowTickets();
                break;

              case "ShowTickets":
                f.ShowTickets();
            }
            return this;
        },
        GenerateGroups: function() {
            var k = "";
            d.each(f.Groups, function(p, o) {
                k += '<div lang="' + o.Id + '" class="tuMapGroup ' + (o.ActiveSections > 0 || o.HasZoneTickets ? "" : "Disabled") + " " + (o.Selected ? "tuMapGroupChecked" : "") + '">', 
                k += '<span class="tuMapGroupColor" style="background-color:' + o.Color + ';"></span>', 
                k += '<span class="tuMapGroupTitle">' + o.Name + "</span>", k += '<br style="clear:both"/>', 
                k += "</div>";
            }), d(f.Settings.GroupsContainer).html(k).addClass("tuMapGroupsContainer");
            var n = 0;
            d(f.Settings.GroupsContainer).children(".tuMapGroup").each(function() {
                d(this).outerWidth(!0) > n && (n = Math.round(d(this).outerWidth(!0)));
            }), f.InteractiveMode ? (d(f.Settings.GroupsContainer).addClass("tuMapActiveGroupsContainer"), 
            d(f.Settings.GroupsContainer).children("div").mouseenter(function() {
                if (d(this).hasClass("Disabled")) {
                    var o = d(this).offset();
                    f.Tooltip.html("No Inventory Available").css({
                        top: o.top - f.Tooltip.height(),
                        left: o.left - f.Tooltip.width()
                    }), f.Tooltip.show();
                } else f.HighlightGroup(d(this).attr("lang"));
            }).mouseleave(function() {
                d(this).hasClass("Disabled") ? f.Tooltip.hide() : f.ResetGroup(d(this).attr("lang"));
            }).click(function() {
                if (!d(this).hasClass("Disabled")) {
                    var o = d(this).attr("lang"), r = f.Groups[o].Selected;
                    r ? (f.Groups[o].Selected = !1, f.ZoneSelected = !1) : (f.Groups[o].Selected = !0, 
                    f.ZoneSelected = !0);
                    var q = [];
                    f.GetSectionsInGroup(o, {
                        OnlyActive: !0,
                        OnlyUnselected: !1
                    }, function(s, t) {
                        q.push({
                            Name: t.Name,
                            Active: t.Active
                        }), f.Sections[s].Selected = r, f.ToggleSelection(s, !0, !0);
                    }), f.ProcessTickets(), f.SortTickets(), f.ShowTickets();
                    var p = f.Groups[o];
                    f.Container.trigger("OnGroupClick", {
                        Name: p.Name,
                        Selected: p.Selected,
                        Sections: q
                    });
                }
            })) : d(f.Settings.GroupsContainer).removeClass("tuMapActiveGroupsContainer");
            for (var g = d(f.Settings.GroupsContainer).outerWidth(!0), m = d(f.Settings.GroupsContainer + " > DIV").length, i = parseInt(g / n), l = parseInt(m / i) + (m % i > 0 ? 1 : 0); ;) {
                var h = parseInt(m / (i - 1)) + (m % (i - 1) > 0 ? 1 : 0);
                if (!(l >= h)) break;
                i--;
            }
            n = Math.floor(g / i);
            var j = 0;
            d(f.Settings.GroupsContainer + " .tuMapGroup").each(function() {
                0 == j && d(f.Settings.GroupsContainer).append(d("<div>").addClass("TempContainer").css("width", n)), 
                d(f.Settings.GroupsContainer + " > .TempContainer:last").append(d(this)), j++, j == l && (j = 0);
            }), d(f.Settings.GroupsContainer + " > .TempContainer").removeClass("TempContainer"), 
            d(f.Settings.GroupsContainer).append('<br style="clear:both;"/>');
        },
        OnLoad: function(h, j) {
            try {
                if (1 == j.Status) {
                    if (e.GetTile = function(r, p, o) {
                        if ("Interactive" == j.MapType || "Static" == j.MapType) {
                            var q = "";
                            1 == f.Settings.ColorScheme && (q = "WB/");
                            var n = o.createElement("IMG");
                            return n.src = j.MapBaseUrl + j.VenueChartId + "/" + q + p + "_" + r.x + "_" + r.y + ".jpg", 
                            n.onerror = function() {
                                0 != f.Settings.ColorScheme && (this.src = j.MapBaseUrl + j.VenueChartId + "/" + p + "_" + r.x + "_" + r.y + ".jpg");
                            }, n;
                        }
                        var n = o.createElement("IMG");
                        return n.src = j.MapBaseUrl + j.MapType + "/" + p + "_" + r.x + "_" + r.y + ".jpg", 
                        n;
                    }, e.Resolutions = j.Resolutions, e.AdaptiveDisplay = j.AdaptiveDisplay, e.ZoomLevel = f.ConvertZoom(), 
                    e.Initialize(d(this)), j.Groups && j.Groups.length > 0 && d.each(j.Groups, function(o, n) {
                        n.ActiveSections = 0, f.Groups[n.Id] = n;
                    }), null != j.Sections) {
                        var i = j.SectionViewBaseUrl ? j.SectionViewBaseUrl + j.VenueChartId + "/" : null;
                        f.SectionViewSize = 500, f.Settings.SectionViewContainer ? f.SectionViewSize = f.CalculateSVWidth(d(f.Settings.SectionViewContainer).width()) : (f.Settings.TooltipSectionViewSize = f.CalculateSVWidth(f.Settings.TooltipSectionViewSize), 
                        f.SectionViewSize = f.CalculateSVWidth(2 * f.Settings.TooltipSectionViewSize)), 
                        f.SectionCounts = {}, f.Sections = {}, d.each(j.Sections, function(o, n) {
                            f.InitSection(n, i);
                        });
                        var m = function() {
                            e.Zoom = f.Settings.ZoomLevel, e.CheckMaxZoom(), e.SetZoom(f.ConvertZoom());
                        }, k = 1;
                        e.IsOldIE() && (k = 1e3), setTimeout(m, k);
                    }
                    f.OtherSections = {}, null != j.OtherSections && d.each(j.OtherSections, function(o, n) {
                        f.OtherSections[n.Name] = n, f.OtherSections[n.Name].Enabled = !1, f.OtherSections[n.Name].Mappings = [];
                    }), f.OtherSections.Unmapped = {
                        Name: "Unmapped",
                        Alias: [],
                        IsExactMatch: !1,
                        Enabled: !1,
                        Mappings: []
                    }, f.OnLoadContinue(j);
                } else if (f.Settings.FailoverMapUrl) {
                    var g = d("<img>").attr("src", f.Settings.FailoverMapUrl).attr("alt", "Venue Map").css("max-width", f.Container.outerWidth(!0)).load(function() {
                        f.OnLoadContinue(j);
                    });
                    d("<div>").css("text-align", "center").append(g).appendTo(f.Container);
                }
            } catch (l) {
                throw f.Container.trigger("OnError", {
                    Code: -1,
                    Message: l.message
                }), f.MapError = !0, l;
            }
        },
        OnLoadContinue: function(g) {
            f.InteractiveMode = "Interactive" == g.MapType, f.InteractiveMode || null != g.OtherSection || (f.OtherSections.Parking = {
                Name: "Parking",
                Alias: [ "parking", "park" ],
                IsExactMatch: !1,
                Enabled: !0,
                Mappings: []
            }), f.ProcessTickets(), f.SortTickets(), f.InteractiveMode && d.each(f.OtherSections, function(h, i) {
                i.Enabled && e.AddMapControl(i.Name, function(j) {
                    f.FilterTickets(h, j, !0), f.Container.trigger("OnControlClick", {
                        Name: i.Name,
                        Selected: j,
                        Mappings: i.Mappings
                    });
                }, !0);
            }), f.GenerateFilters(), f.ShowTickets(), 1 == g.Status ? f.Container.trigger("OnInit", {
                MapType: g.MapType,
                ResolvedBy: g.ResolvedBy
            }) : (f.Container.trigger("OnError", {
                Code: g.ErrorCode,
                Message: g.Error
            }), f.MapError = !0);
        },
        CalculateSVWidth: function(i) {
            var h = [ 250, 500, 1e3, 1500 ];
            if (i <= h[0]) return h[0];
            for (var g = 0; 4 > g; g++) {
                if (g == h.length - 1) return h[h.length - 1];
                if (i >= h[g] && i < h[g + 1]) return i - h[g] < h[g + 1] - i ? h[g] : h[g + 1];
            }
        },
        GenerateFilters: function() {
            if (f.Settings.TicketsListContainer) {
                f.Container.trigger("OnBeforeListRender"), d(f.Settings.TicketsListContainer).css("overflow", "visible"), 
                d(f.Settings.TicketsListContainer).html("");
                var h = d(f.Settings.TicketsListContainer).outerHeight(!0), k = 0;
                if (f.PreferredFlag || f.eTicketFlag) {
                    var i = d("<div>").addClass("tuMapPreferredFilter");
                    if (f.PreferredFlag) {
                        var l = d("<div>").addClass("tuMapPreferred");
                        l.append(d("<span>").addClass("Icon"));
                        var g = d("<input>").attr("type", "checkbox").attr("checked", f.Settings.PreferredFirst ? 'checked="checked"' : "");
                        g.change(function() {
                            f.Settings.PreferredFirst = d(this).is(":checked"), f.SortTickets(), f.ShowTickets();
                        }), l.append(g), l.append(d("<span>").html(f.Settings.PreferredText)), i.append(l);
                    }
                    if (f.eTicketFlag) {
                        var j = d("<div>").addClass("tuMapeTicket");
                        j.append(d("<span>").addClass("Icon")), j.append(d("<span>").html("E-Ticket")), 
                        i.append(j);
                    }
                    d(f.Settings.TicketsListContainer).append(i), d("<br>").css("clear", "both").appendTo(i), 
                    h > 0 && (k = i.outerHeight(!0));
                }
                f.vTableContainer = d("<div>"), d(f.Settings.TicketsListContainer).append(f.vTableContainer), 
                0 == h && (h = f.Container.outerHeight(!0), f.Settings.GroupsContainer && (h += d(f.Settings.GroupsContainer).outerHeight(!0)), 
                h -= Math.abs(f.Container.offset().top - d(f.vTableContainer).offset().top)), h -= k, 
                f.vTableContainer.height(h);
            }
        },
        Extend: function(g) {
            return d.extend(!0, f, g), this;
        },
        GetStyles: function(g) {
            return 0 == g ? {
                HighlightStyle: {
                    strokeColor: "#FFFFFF",
                    strokeWeight: 2,
                    fillColor: "#0000FF",
                    fillOpacity: .2
                },
                NormalStyle: {
                    fillOpacity: 0,
                    fillColor: "#FFFFFF",
                    strokeColor: "#FFFFFF",
                    strokeWeight: 0
                },
                SelectedStyle: {
                    strokeWeight: 2,
                    fillColor: "#FFFFFF",
                    fillOpacity: .3
                },
                InactiveStyle: {
                    strokeColor: "#FFFFFF",
                    strokeWeight: 0,
                    fillColor: "#666666",
                    fillOpacity: .7
                }
            } : {
                HighlightStyle: {
                    strokeColor: "#333333",
                    strokeWeight: 2,
                    fillColor: "#FFFF00",
                    fillOpacity: .5
                },
                NormalStyle: {
                    fillOpacity: 0,
                    fillColor: "#FFFFFF",
                    strokeColor: "#FFFFFF",
                    strokeWeight: 0
                },
                SelectedStyle: {
                    strokeWeight: 2,
                    fillColor: "#FFFFFF",
                    fillOpacity: .3
                },
                InactiveStyle: {
                    strokeColor: "#FFFFFF",
                    strokeWeight: 0,
                    fillColor: "#666666",
                    fillOpacity: .7
                }
            };
        },
        Initialize: function(h) {
            f.Groups = {}, f.Sections = {}, f.OtherSections = {}, f.Selection = [], f.RefreshType = "None", 
            null != h.ColorScheme && d.extend(f.defaults, f.GetStyles(h.ColorScheme)), f.Settings = d.extend({}, f.defaults, h), 
            f.Container = d(this), f.Container.unbind(), d(".tuMapTooltip").remove();
            var g = f.Container.position();
            f.Tooltip = d('<div class="tuMapTooltip"></div>').insertAfter(f.Container).css({
                position: "absolute",
                display: "none",
                "z-index": 2e4,
                left: g.left,
                top: g.top
            }), f.Container.bind("OnTicketSelected", f.Settings.OnTicketSelected), f.Container.bind("OnMouseover", f.Settings.OnMouseover), 
            f.Container.bind("OnMouseout", f.Settings.OnMouseout), f.Container.bind("OnClick", f.Settings.OnClick), 
            f.Container.bind("OnGroupClick", f.Settings.OnGroupClick), f.Container.bind("OnLoad", f.OnLoad), 
            f.Container.bind("OnInit", f.Settings.OnInit), f.Container.bind("OnBeforeListRender", f.Settings.OnBeforeListRender), 
            f.Container.bind("OnAfterListRender", f.Settings.OnAfterListRender), f.Container.bind("OnError", f.Settings.OnError), 
            f.Container.bind("OnReset", f.Settings.OnReset), f.Container.bind("OnControlClick", f.Settings.OnControlClick);
            var i = "Version=3.1.11&MapSet=" + f.Settings.MapSet + "&MapType=" + f.Settings.MapType + "&EnableGroups=" + (null != f.Settings.GroupsContainer).toString() + "&Domain=" + window.location.host + "&AutoSwitchToStatic=" + f.Settings.AutoSwitchToStatic;
            if (null == f.Settings.MapId && null == f.Settings.EventId) throw "MapId or EventId Required";
            return null != f.Settings.EventId && (i = "EventId=" + f.Settings.EventId + "&SeatingChartAutoCorrect=" + f.Settings.SeatingChartAutoCorrect + "&" + i), 
            null != f.Settings.MapId && (i = "MapId=" + f.Settings.MapId + "&" + i), null != f.Settings.EventInfo && (i = "Venue=" + escape(f.Settings.EventInfo.Venue) + "&Event=" + escape(f.Settings.EventInfo.EventName) + "&EventDate=" + f.Settings.EventInfo.EventDate + "&" + i), 
            d.ajax({
                url: f.Settings.ServiceUrl,
                dataType: "jsonp",
                crossDomain: !0,
                data: i,
                type: "POST",
                success: function(j) {
                    null != f.Settings.GroupsContainer && d(f.Settings.GroupsContainer).html(""), null != f.Settings.TicketsListContainer && d(f.Settings.TicketsListContainer).html(""), 
                    f.Container.html(""), f.Container.trigger("OnLoad", j);
                },
                error: function() {}
            }), this;
        }
    }, c = {
        defaults: {
            Rows: 0,
            TableFormatter: function(g) {
                return g;
            },
            ColumnsFormatter: function(g) {
                return g.append(d("<th>").text("Column"));
            },
            RowFormatter: function(h, g) {
                return h.attr("lang", g).append(d("<td>").text("Row" + g));
            },
            NoResultsFormatter: function() {}
        },
        Initialize: function(i) {
            if (c.Body = null, c.Fillers = [], c.RowData = [], c.RowHeight = 0, c.Settings = d.extend({}, c.defaults, i), 
            c.Settings.Container.unbind(), c.Settings.Container.html("").attr("class", "tuMapTicketList"), 
            c.ColTable = c.Settings.TableFormatter(d("<table>").attr("cellpadding", 3).attr("cellspacing", 0).attr("style", "width:100%;")), 
            c.ColTable.append(d("<thead>").append(c.Settings.ColumnsFormatter(d("<tr>")))), 
            c.ColTable.appendTo(c.Settings.Container), c.TableContainer = d("<div>").css("overflow", "auto").css("height", c.Settings.Container.height() - c.ColTable.height() - 1), 
            c.TableContainer.appendTo(c.Settings.Container), c.Table = c.ColTable.clone(), c.ColTable.css("table-layout", "fixed"), 
            c.Body = c.Table.append("<tbody>"), c.Table.appendTo(c.TableContainer), 0 == c.Settings.Rows) return c.Body.append(c.Settings.NoResultsFormatter(d("<tr>"))), 
            void c.AdjustColumns();
            for (var g = 0; g < c.Settings.Rows; g++) if (c.RowData[g] = {
                Created: !0,
                tr: d("<tr>")
            }, c.Body.append(c.Settings.RowFormatter(c.RowData[g].tr, g)), c.Table.height() > c.TableContainer.height()) {
                c.RowHeight = d(c.Table.find("tr")[1]).height();
                var h = d("<tr>").attr("height", c.Settings.Rows * c.RowHeight);
                c.Body.append(h), c.Fillers.push({
                    startIndex: g + 1,
                    endIndex: c.Settings.Rows - 1,
                    tr: h
                }), c.CreateRow(0, g);
                break;
            }
            c.AdjustColumns(), c.TableContainer.scroll(function() {
                var j = d(this).scrollTop();
                c.scrollTop != j && (null != c.verticalScrollHandle && clearTimeout(c.verticalScrollHandle), 
                c.verticalScrollHandle = setTimeout(function() {
                    c.RenderRows();
                }, 10), c.scrollTop = j);
            });
        },
        CreateRow: function(u, p) {
            for (var w = c.RowData, o = u; p >= o; o++) null == w[o] && (w[o] = {});
            for (var h = !1, o = u; p >= o; o++) if (null == w[o].tr) {
                h = !0;
                break;
            }
            if (h) {
                for (var g = (c.Body, c.RowHeight), j = c.Fillers, k = [], o = j.length; o--; ) {
                    var n = j[o];
                    u <= n.endIndex && p >= n.startIndex && k.push(n);
                }
                for (var o = k.length; o--; ) {
                    for (var n = k[o], q = u >= n.startIndex ? u : n.startIndex, t = p <= n.endIndex ? p : n.endIndex, r = q; t >= r; r++) {
                        var s = w[r];
                        s.tr = d("<tr>").height(g + "px").insertBefore(n.tr);
                    }
                    var m = !1, l = n.startIndex;
                    if (t < n.endIndex && (n.startIndex = t + 1, n.tr.height((n.endIndex - n.startIndex + 1) * g + "px"), 
                    m = !0), q > l) if (m) {
                        var n = {
                            startIndex: l,
                            endIndex: q - 1,
                            tr: d("<tr>")
                        };
                        n.tr.height((n.endIndex - n.startIndex + 1) * g + "px").insertBefore(w[q].tr), j.push(n);
                    } else n.endIndex = q - 1, n.tr.height((n.endIndex - n.startIndex + 1) * g + "px").insertBefore(w[q].tr), 
                    m = !0;
                    if (!m) {
                        for (var r = j.length; r--; ) if (n == j[r]) {
                            j.splice(r, 0);
                            break;
                        }
                        n.tr.remove();
                    }
                }
            }
        },
        RenderRows: function() {
            if (0 != c.Settings.Rows) {
                var h = Math.floor(c.TableContainer.scrollTop() / c.RowHeight) - 5, k = Math.ceil((c.TableContainer.scrollTop() + c.TableContainer.outerHeight(!0)) / c.RowHeight) + 5;
                0 > h && (h = 0), k > c.Settings.Rows - 1 && (k = c.Settings.Rows - 1), c.CreateRow(h, k);
                for (var g = h; k >= g; g++) {
                    var j = c.RowData[g];
                    j.Created !== !0 && (c.Settings.RowFormatter(j.tr, g), j.Created = !0);
                }
                c.AdjustColumns();
            }
        },
        AdjustColumns: function() {
            for (var i = c.Table.find("tr:first").children(), h = c.ColTable.find("tr:first").children(), g = 0; g < i.length - 1; g++) d(h[g]).width(d(i[g]).width());
            c.Table.css("margin-top", -d(i[0]).outerHeight(!0) - 1);
        }
    }, e = {
        TileSize: 100,
        BaseTileSize: 100,
        OnMouseOver: function(g, h, i) {
            i && (i.Active && !i.Selected && i.SetStyle(f.Settings.HighlightStyle), h && f.ShowTooltip(i.Key, h, !0), 
            f.Container.trigger("OnMouseover", {
                Active: i.Active,
                Selected: i.Selected,
                Key: i.Key,
                Name: i.Name,
                DisplayName: i.DisplayName,
                DisplayGroupName: i.DisplayGroupName,
                ExactMatchAlias: i.ExactMatchAlias,
                Alias: i.Alias,
                Group: f.Groups[i.GroupId],
                SectionViewAvailable: i.IsSectionViewAvailable,
                SectionViewThumbnailUrl: i.SectionViewThumbnailUrl,
                SectionViewUrl: i.SectionViewUrl,
                Mappings: i.Mappings,
                MousePosition: h,
                RowDetails: i.RowDetails,
                RowStart: i.RowStart,
                RowEnd: i.RowEnd
            }));
        },
        OnMouseOut: function(g, h, i) {
            i && (i.Active && !i.Selected && i.SetStyle(f.Settings.NormalStyle), h && f.HideTooltip(), 
            f.Container.trigger("OnMouseout", {
                Active: i.Active,
                Selected: i.Selected,
                Key: i.Key,
                Name: i.Name,
                DisplayName: i.DisplayName,
                DisplayGroupName: i.DisplayGroupName,
                ExactMatchAlias: i.ExactMatchAlias,
                Alias: i.Alias,
                Group: f.Groups[i.GroupId],
                SectionViewAvailable: i.IsSectionViewAvailable,
                SectionViewThumbnailUrl: i.SectionViewThumbnailUrl,
                SectionViewUrl: i.SectionViewUrl,
                Mappings: i.Mappings,
                MousePosition: h,
                RowDetails: i.RowDetails,
                RowStart: i.RowStart,
                RowEnd: i.RowEnd
            }));
        },
        OnMouseMove: function() {},
        OnClick: function(g, h, i) {
            f.HideTooltip(!0), i && i.Active && (f.ToggleSelection(i.Key, !0), f.Container.trigger("OnClick", {
                Active: i.Active,
                Selected: i.Selected,
                Key: i.Key,
                Name: i.Name,
                DisplayName: i.DisplayName,
                DisplayGroupName: i.DisplayGroupName,
                ExactMatchAlias: i.ExactMatchAlias,
                Alias: i.Alias,
                Group: f.Groups[i.GroupId],
                SectionViewAvailable: i.IsSectionViewAvailable,
                SectionViewThumbnailUrl: i.SectionViewThumbnailUrl,
                SectionViewUrl: i.SectionViewUrl,
                Mappings: i.Mappings,
                RowDetails: i.RowDetails,
                RowStart: i.RowStart,
                RowEnd: i.RowEnd
            }));
        },
        OnReset: function() {
            d.each(f.Selection, function(h, g) {
                f.Sections[g] && (f.Sections[g].Selected = !1);
            }), f.Selection = [], f.ZoneSelected = !1, d.each(f.Groups, function(g) {
                f.Groups[g].Selected = !1;
            }), null != f.BlinkTimer && (clearInterval(f.BlinkTimer), f.BlinkTimer = null), 
            d(".tuMapControlSelected").each(function() {
                d(this).removeClass("tuMapControlSelected");
            }), d(".tuMapControlBlink").each(function() {
                d(this).removeClass("tuMapControlBlink");
            }), e.SetCenter(new b.Map.Point(0, 0)), e.Zoom = f.Settings.ZoomLevel, e.CheckMaxZoom(), 
            e.SetZoom(f.ConvertZoom()), f.ProcessTickets(), f.SortTickets(), f.ShowTickets(), 
            f.Container.trigger("OnReset");
        },
        GetTile: function() {},
        Container: null,
        Wrapper: null,
        Canvas: null,
        GCanvas: null,
        CanvasContext: null,
        GCanvasContext: null,
        GhostSections: {},
        CurrentShape: null,
        TranslatePos: null,
        StartDragOffset: {},
        BaseUrl: "http://data.ticketutils.com/Charts/",
        ZoomLevel: 5,
        Side: 500,
        Tiles: [],
        IsOldIE: function() {
            var g = navigator.userAgent.toLowerCase();
            return -1 != g.indexOf("msie") ? parseInt(g.split("msie")[1]) <= 8 : !1;
        },
        CheckMaxZoom: function() {
            f.Settings.MaxZoom > 0 && e.Zoom > f.Settings.MaxZoom && (e.Zoom = f.Settings.MaxZoom);
        },
        DetectZoomLevel: function(h) {
            for (var g = 0; g < e.Resolutions.length; g++) if (e.Resolutions[g] > h) {
                e.Zoom = g > 0 ? h >= e.Resolutions[g - 1] + (e.Resolutions[g] - e.Resolutions[g - 1]) * f.Settings.AdaptiveThreshold ? g + 1 : g : 1;
                break;
            }
            e.CheckMaxZoom(), e.ZoomLevel = e.Resolutions[e.Zoom - 1] / 100, f.Settings.ZoomLevel = e.Zoom;
        },
        Initialize: function(i) {
            var n = i.outerHeight(!0), h = i.outerWidth(!0);
            if (0 == h || 0 == n) if (h > 0) n = h; else if (n > 0) h = n; else {
                var m = i.clone().css("postion", "absolute").css("display", "block").css("left", "-1000").css("top", "-1000");
                d("body").append(m), h = m.outerWidth(!0), n = m.outerHeight(!0), m.remove(), (0 == h || 0 == n) && (n = e.Side * e.ZoomLevel, 
                h = n);
            }
            e.AdaptiveDisplay ? e.DetectZoomLevel(h) : (e.Zoom = f.Settings.ZoomLevel, e.CheckMaxZoom()), 
            e.Container = d("<div>").attr("class", "tuMapContainer").attr("style", "position:relative;margin:auto;overflow:hidden;width:" + h + "px;height:" + n + "px").appendTo(i).disableSelection().mousemove(function(o) {
                return e.MouseDown ? (e.CurrentShape && e.Wrapper.trigger("OnMouseOut", [ e.GetAbsolutePosition(o), e.CurrentShape ]), 
                d(e.Canvas).css("cursor", "move"), e.CurrentShape = null, e.TranslatePos.x = o.clientX - e.StartDragOffset.x, 
                e.TranslatePos.y = o.clientY - e.StartDragOffset.y, void e.Translate()) : void 0;
            }), e.TranslatePos = new b.Map.Point(0, 0), e.Side = e.BaseTileSize * e.ZoomLevel, 
            e.Wrapper = d("<div>").attr("style", "z-index:0;position:absolute;width:" + e.Side + "px;height:" + e.Side + "px").disableSelection().appendTo(e.Container).mousedown(function(o) {
                e.MouseDown = !0, e.StartDragOffset.x = o.clientX - e.TranslatePos.x, e.StartDragOffset.y = o.clientY - e.TranslatePos.y;
            }).mouseup(function() {
                e.MouseDown = !1, e.Dragging = !1, d(e.Canvas).css("cursor", "auto");
            }).mouseover(function() {
                e.MouseDown = !1, e.Dragging = !1;
            }).mouseout(function() {
                return e.MouseDown = !1, e.Dragging = !1, !1;
            }), e.GenerateTiles();
            var g = d("<canvas />").attr("style", "position:absolute; top:0; left:0; z-index:1").disableSelection().appendTo(e.Wrapper);
            if (e.Canvas = g[0], e.Canvas.width = e.Wrapper.width(), e.Canvas.height = e.Wrapper.height(), 
            e.Canvas.onselectstart = function() {
                return !1;
            }, window.G_vmlCanvasManager && G_vmlCanvasManager.initElement(e.Canvas), e.CanvasContext = e.Canvas.getContext("2d"), 
            !e.IsOldIE()) {
                var j = d("<canvas />");
                e.GCanvas = j[0], e.GCanvas.width = e.Wrapper.width(), e.GCanvas.height = e.Wrapper.height(), 
                window.G_vmlCanvasManager && G_vmlCanvasManager.initElement(e.GCanvas), e.GCanvasContext = e.GCanvas.getContext("2d");
            }
            e.ZoomControls = d("<div>").addClass("ZoomControls").appendTo(e.Container), d("<div>").addClass("ZoomIn").appendTo(e.ZoomControls).click(function() {
                e.ZoomIn();
            }), d("<div>").addClass("ZoomOut").appendTo(e.ZoomControls).click(function() {
                e.ZoomOut();
            }), e.ResetContainer = d("<div>").attr("style", "position:absolute;right:5px;top:5px;").appendTo(e.Container), 
            e.ResetButton = d("<div>").addClass("tuMapControl").html(f.Settings.ResetButtonText).appendTo(e.ResetContainer).click(function() {
                f.Reset();
            }), d(".tuMapControlsContainer").remove(), e.ControlsContainer = "Inside" == f.Settings.ControlsPosition ? d('<div class="tuMapControlsContainer">').attr("style", "text-align:center;bottom:0;left:50%;position:absolute;").appendTo(e.Container) : d('<div class="tuMapControlsContainer">').attr("style", "text-align:center;margin:0 auto;").insertAfter(i), 
            e.IsOldIE() && (e.CallbackFunctionId = "TMCB" + Math.floor(1e6 * Math.random()) + 1e3, 
            window[e.CallbackFunctionId] = function(t, s, p, o) {
                var q = (e.Wrapper.offset(), {
                    x: t.x,
                    y: t.y
                });
                "out" == p ? e.TriggerEvent(q, null) : "click" == p ? e.Wrapper.trigger("OnClick", [ q, null != e.CurrentShape ? e.CurrentShape : f.Sections[o] ]) : e.TriggerEvent(q, o);
            });
            var l = function(r) {
                if (!e.Dragging) {
                    var q = e.GetAbsolutePosition(r), p = e.GetSectionUnderMouse(r);
                    if (p) {
                        var o = f.Sections[p];
                        o && e.Wrapper.trigger("OnClick", [ q, o ]);
                    }
                }
            };
            if (g.bind("mouseup", function(o) {
                l(o);
            }).bind("mousemove", function(o) {
                e.IsOldIE() || e.TriggerEvent(e.GetAbsolutePosition(o), e.GetSectionUnderMouse(o));
            }).bind("contextmenu", function(o) {
                o.preventDefault();
            }), jQuery().hammer) {
                var k = g.hammer({
                    prevent_default: !0,
                    drag_block_horizontal: !0,
                    drag_block_vertical: !0,
                    drag_min_distance: 20,
                    tap: !0,
                    tap_always: !0,
                    show_touches: !0,
                    prevent_mouseevents: !0
                });
                k.on("tap", function(o) {
                    l(o.gesture.center);
                }).on("pinch", function(o) {
                    var p = Math.ceil(e.Zoom * o.gesture.scale);
                    1 > p ? p = 1 : p > e.Resolutions.length && (p = e.Resolutions.length), p != e.Zoom && (e.Zoom = p, 
                    e.SetZoom(e.Resolutions[e.Zoom - 1] / 100));
                }).on("drag", function(o) {
                    e.TranslatePos.x = o.gesture.center.pageX - e.StartDragOffset.x, e.TranslatePos.y = o.gesture.center.pageY - e.StartDragOffset.y, 
                    e.Translate();
                }).on("dragstart", function(o) {
                    e.Dragging = !0, e.StartDragOffset.x = o.gesture.center.pageX - e.TranslatePos.x, 
                    e.StartDragOffset.y = o.gesture.center.pageY - e.TranslatePos.y;
                }).on("dragend", function() {
                    e.Dragging = !1;
                });
            }
            return e.Wrapper.bind("OnMouseOver", e.OnMouseOver), e.Wrapper.bind("OnMouseOut", e.OnMouseOut), 
            e.Wrapper.bind("OnClick", e.OnClick), e.Wrapper.bind("OnMouseMove", e.OnMouseMove), 
            e.Wrapper.bind("OnReset", e.OnReset), e.SetCenter(new b.Map.Point(0, 0)), this;
        },
        AddMapControl: function(i, g, h) {
            d("<div>").addClass("tuMapControl").html(i).appendTo(e.ControlsContainer).click(function() {
                var j = !0;
                h && (d(this).hasClass("tuMapControlSelected") || d(this).hasClass("tuMapControlBlink") ? (d(this).removeClass("tuMapControlSelected"), 
                d(this).removeClass("tuMapControlBlink"), j = !1) : d(this).addClass("tuMapControlSelected")), 
                g(j);
            }), "Inside" == f.Settings.ControlsPosition ? e.ControlsContainer.css("margin-left", 0 - parseInt(e.ControlsContainer.width() / 2)) : e.ControlsContainer.css("padding", "3px");
        },
        GetAbsolutePosition: function(g) {
            var h = e.Container.offset();
            return new b.Map.Point(g.pageX - h.left, g.pageY - h.top);
        },
        GetSectionUnderMouse: function(j) {
            if (!e.IsOldIE()) {
                var i = e.Wrapper.offset(), h = new b.Map.Point(j.pageX - i.left, j.pageY - i.top), k = e.GCanvasContext.getImageData(h.x, h.y, 1, 1).data, g = "#" + ("000000" + e.RGBToHex(k[0], k[1], k[2])).slice(-6);
                return e.GhostSections[g];
            }
        },
        GenerateTiles: function() {
            for (var h = 0; h < this.Tiles.length; h++) this.Tiles[h].remove();
            var g = 1, j = e.BaseTileSize * e.ZoomLevel;
            e.ZoomLevel <= 5 ? (g = 1, e.TileSize = j) : e.ZoomLevel <= 12 ? (g = 2, e.TileSize = j / 2) : (g = j / 500, 
            e.TileSize = 500);
            for (var h = 0; g > h; h++) for (var k = 0; g > k; k++) {
                var i = e.GetTile(new b.Map.Point(h, k), e.ZoomLevel, document);
                d(i).attr("style", "position:absolute;top:" + k * e.TileSize + "px;left:" + h * e.TileSize + "px;z-index:0;width:" + e.TileSize + "px;height:" + e.TileSize + "px;").appendTo(e.Wrapper).disableSelection(), 
                this.Tiles.push(d(i));
            }
        },
        Trigger: function(g, h) {
            e.Wrapper.trigger(g, [ null, h ]);
        },
        TriggerEvent: function(g, h) {
            h ? (null == e.CurrentShape ? (d(e.Canvas).css("cursor", "pointer"), e.Wrapper.trigger("OnMouseOver", [ g, f.Sections[h] ])) : e.CurrentShape.Key == h ? e.Wrapper.trigger("OnMouseMove", [ g, f.Sections[h] ]) : (e.Wrapper.trigger("OnMouseOut", [ g, e.CurrentShape ]), 
            e.Wrapper.trigger("OnMouseOver", [ g, f.Sections[h] ])), e.CurrentShape = f.Sections[h]) : null != e.CurrentShape && (e.Wrapper.trigger("OnMouseOut", [ g, e.CurrentShape ]), 
            d(e.Canvas).css("cursor", "move"), e.CurrentShape = null);
        },
        Add: function(g) {
            for (f.Sections[g.Key] = g; ;) if (g.SetGhostColor(), !e.GhostSections[g.GhostColor]) {
                e.GhostSections[g.GhostColor] = g.Key;
                break;
            }
        },
        SetZoom: function(h) {
            var g = e.ZoomLevel;
            e.ZoomLevel = h, e.ZoomLevel > 20 ? e.ZoomLevel = 20 : e.ZoomLevel < 3 && (e.ZoomLevel = 3), 
            e.Side = e.BaseTileSize * e.ZoomLevel, e.Wrapper.width(e.Side).height(e.Side), e.GenerateTiles(), 
            e.Canvas.width = e.Side, e.Canvas.height = e.Side, e.CanvasContext.clearRect(0, 0, e.Side, e.Side), 
            e.IsOldIE() ? (g == e.ZoomLevel && (g = 1), e.CanvasContext.scale(e.ZoomLevel / g, e.ZoomLevel / g)) : (e.GCanvas.width = e.Side, 
            e.GCanvas.height = e.Side, e.GCanvasContext.clearRect(0, 0, e.Side, e.Side), e.GCanvasContext.scale(e.ZoomLevel, e.ZoomLevel), 
            e.CanvasContext.scale(e.ZoomLevel, e.ZoomLevel)), e.SetCenter(new b.Map.Point(e.Center.x * e.ZoomLevel / g, e.Center.y * e.ZoomLevel / g)), 
            e.Draw();
        },
        GetCenter: function(g) {
            var h = f.Sections[g];
            return h ? h.GetCenter() : void 0;
        },
        ZoomIn: function() {
            return e.Zoom++, e.Zoom > e.Resolutions.length ? (e.Zoom = e.Resolutions.length, 
            !1) : (e.CheckMaxZoom(), e.SetZoom(e.Resolutions[e.Zoom - 1] / 100), !0);
        },
        ZoomOut: function() {
            return e.Zoom--, e.Zoom <= 0 ? (e.Zoom = 1, !1) : (e.SetZoom(e.Resolutions[e.Zoom - 1] / 100), 
            !0);
        },
        Translate: function(h) {
            if (e.TranslatePos.x > 0 ? (e.TranslatePos.x = e.Wrapper.outerWidth(!0) < e.Container.outerWidth(!0) ? (e.Container.outerWidth(!0) - e.Wrapper.outerWidth(!0)) / 2 : 0, 
            h = !1) : e.TranslatePos.x + e.Wrapper.outerWidth(!0) - e.Container.outerWidth(!0) < 0 && (e.TranslatePos.x = e.Container.outerWidth(!0) - e.Wrapper.outerWidth(!0), 
            h = !1), e.TranslatePos.y > 0 ? (e.TranslatePos.y = e.Wrapper.outerHeight(!0) < e.Container.outerHeight(!0) ? (e.Container.outerHeight(!0) - e.Wrapper.outerHeight(!0)) / 2 : 0, 
            h = !1) : e.TranslatePos.y + e.Wrapper.outerHeight(!0) - e.Container.outerHeight(!0) < 0 && (e.TranslatePos.y = e.Container.outerHeight(!0) - e.Wrapper.outerHeight(!0), 
            h = !1), e.Wrapper.css("left", e.TranslatePos.x + "px").css("top", e.TranslatePos.y + "px"), 
            !h) {
                var g = new b.Map.Point(e.Container.outerWidth(!0) / 2, e.Container.outerHeight(!0) / 2), i = new b.Map.Point(e.Wrapper.outerWidth(!0) / 2, e.Wrapper.outerHeight(!0) / 2);
                e.Center = new b.Map.Point(g.x - i.x - e.TranslatePos.x, g.y - i.y - e.TranslatePos.y);
            }
        },
        SetCenter: function(i) {
            e.Center = i;
            var g = new b.Map.Point(e.Container.outerWidth(!0) / 2, e.Container.outerHeight(!0) / 2), h = new b.Map.Point(e.Wrapper.outerWidth(!0) / 2, e.Wrapper.outerHeight(!0) / 2);
            e.TranslatePos = new b.Map.Point(g.x - h.x - i.x, g.y - h.x - i.y), e.Translate(!0);
        },
        Draw: function() {
            for (var g in f.Sections) {
                var h = f.Sections[g];
                h.hasOwnProperty("Draw") && h.Draw();
            }
        },
        RGBToHex: function(j, i, h) {
            if (j > 255 || i > 255 || h > 255) throw "Invalid Color Component";
            return (j << 16 | i << 8 | h).toString(16);
        },
        HexToRGB: function(h) {
            var g = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);
            return g ? {
                r: parseInt(g[1], 16),
                g: parseInt(g[2], 16),
                b: parseInt(g[3], 16)
            } : null;
        }
    }, b = b || {
        Map: {}
    };
    b.Map.Section = function(g) {
        d.extend(this, g), this.Quantity = 0, this.MinPrice = 9007199254740992, this.MaxPrice = 0, 
        this.MinPriceValue = "", this.MaxPriceValue = "", this.Style = {}, d.extend(this.Style, this.Active ? f.Settings.NormalStyle : f.Settings.InactiveStyle), 
        this.Selected = !1, this.Mappings = [], this.Coords = [], this.Markers = [];
        var h = this;
        d.each(this.Coordinates, function(j, i) {
            h.Coords.push(new b.Map.Point(i[0], i[1]));
        }), delete this.Coordinates, this.GetOpaqueColor = function(k, i) {
            if (1 == i) return k;
            var j = e.HexToRGB(k);
            return k = "rgba(" + j.r + "," + j.g + "," + j.b + "," + i + ")";
        }, this.Draw = function() {
            this.DrawOnContext(e.CanvasContext, this.Style), e.IsOldIE() || this.DrawOnContext(e.GCanvasContext, {
                fillColor: this.GhostColor,
                fillOpacity: 1
            });
        }, this.IsStyleChanged = function(i) {
            return this.Style.fillColor == i.fillColor && this.Style.fillOpacity == i.fillOpacity && this.Style.strokeColor == i.strokeColor && this.Style.strokeWeight == i.strokeWeight ? !1 : !0;
        }, this.GetCenter = function() {
            var i = 0, k = 0, j = 0;
            return d.each(this.Coords, function(l, m) {
                j++, i += m.x * e.ZoomLevel, k += m.y * e.ZoomLevel;
            }), i /= j, k /= j, new b.Map.Point(i, k);
        }, this.GetCorner = function(r, i) {
            if ("Dynamic" == i) return r;
            var t = null, j = 1e5, n = 500 * e.ZoomLevel, s = 500 * e.ZoomLevel;
            switch (i) {
              case "TopRight":
                s = -s;
                break;

              case "TopLeft":
                n = -n, s = -s;
                break;

              case "BottomLeft":
                n = -n;
            }
            var q = 1e4, o = 0, p = 1e4, m = 0;
            d.each(this.Coords, function(v, w) {
                w.x < q ? q = w.x : w.x > o && (o = w.x), w.y < p ? p = w.y : w.y > m && (m = w.y);
                var u = Math.sqrt(Math.pow(w.x - (r.x + n), 2) + Math.pow(w.y - (r.y + s), 2));
                j > u && (j = u, t = new b.Map.Point(w.x * e.ZoomLevel + e.TranslatePos.x, w.y * e.ZoomLevel + e.TranslatePos.y));
            });
            var l = 5;
            switch ((o - q > 20 || m - p > 20) && (t = {
                x: r.x,
                y: r.y
            }, l = -5), i) {
              case "TopRight":
                t.y += l, t.x -= l;
                break;

              case "TopLeft":
                t.y += l, t.x += l;
                break;

              case "BottomLeft":
                t.y -= l, t.x += l;
                break;

              default:
                t.y -= l, t.x -= l;
            }
            return t;
        }, this.AddMarker = function(i, j, m) {
            j || (j = this.GetCenter()), m || (m = {
                x: 0,
                y: 0
            });
            var k = this, l = new Image();
            l.src = i, l.onload = function() {
                k.Markers.push({
                    Image: l,
                    Point: j,
                    Adjustment: m
                }), k.DrawMarkers();
            };
        }, this.DrawMarkers = function() {
            d.each(this.Markers, function(j, i) {
                e.CanvasContext.drawImage(i.Image, (i.Point.x - i.Image.width) / e.ZoomLevel - i.Adjustment.x, (i.Point.y - i.Image.height) / e.ZoomLevel - i.Adjustment.y, i.Image.width / e.ZoomLevel, i.Image.height / e.ZoomLevel);
            });
        }, this.RemoveMarker = function(j) {
            for (var i = 0; i < this.Markers.length; i++) if (this.Markers[i].Point.x == j.x && this.Markers[i].Point.y == j.y) {
                this.Markers.splice(i, 1);
                break;
            }
            this.Clear(e.CanvasContext), this.DrawOnContext(e.CanvasContext, this.Style);
        }, this.SetStyle = function(i) {
            if (this.IsStyleChanged(i)) if (e.IsOldIE()) {
                d.extend(this.Style, i);
                var j = document.getElementById(this.Key);
                j && (j.filled = this.Style.fillOpacity > 0, void 0 != typeof j.fill && null != j.fill && (j.fill.opacity = 100 * this.Style.fillOpacity + "%"), 
                j.fillcolor = this.Style.fillColor, j.strokecolor = this.Style.strokeColor, j.strokeweight = this.Style.strokeWeight, 
                j.stroked = this.Style.strokeWeight > 0);
            } else this.Clear(e.CanvasContext), d.extend(this.Style, i), this.DrawOnContext(e.CanvasContext, this.Style);
        }, this.Clear = function(i) {
            i.save(), i.globalCompositeOperation = "destination-out", this.DrawOnContext(e.CanvasContext, {
                fillColor: "#FFFFFF",
                strokeColor: "#FFFFFF",
                strokeWeight: this.Style.strokeWeight,
                fillOpacity: 1
            }), i.restore();
        }, this.DrawOnContext = function(k, j) {
            k.save(), k.beginPath(), k.moveTo(this.Coords[0].x, this.Coords[0].y);
            for (var i = 0; i < this.Coords.length; i++) k.lineTo(this.Coords[i].x, this.Coords[i].y);
            k.closePath(), e.IsOldIE() ? (k.fillStyle = this.GetOpaqueColor(j.fillColor, j.fillOpacity), 
            k.lineWidth = j.strokeWeight / e.ZoomLevel, k.strokeStyle = j.strokeColor, k.stroke(!0, e.CallbackFunctionId, this.Key)) : (j.fillOpacity > 0 && (k.fillStyle = this.GetOpaqueColor(j.fillColor, j.fillOpacity), 
            k.fill()), j.strokeWeight > 0 && (k.lineWidth = j.strokeWeight / e.ZoomLevel, k.strokeStyle = j.strokeColor, 
            k.stroke())), this.Markers.length > 0 && j.fillColor != this.GhostColor && this.DrawMarkers(), 
            k.restore();
        }, this.SetGhostColor = function() {
            this.GhostColor = "#" + ("000" + (Math.random() * (1 << 24) | 0).toString(16)).substr(-6);
        };
    }, b.Map.Point = function(g, h) {
        this.x = g, this.y = h;
    }, d.fn.tuMap = function(g) {
        return null != f[g] ? "function" == typeof f[g] ? f[g].apply(this, Array.prototype.slice.call(arguments, 1)) : f[g] : "object" != typeof g && g ? void d.error("Method " + g + " does not exist") : f.Initialize.apply(this, arguments);
    };
    var a = {
        init: function() {
            this.browser = this.searchString(this.dataBrowser) || "Unknown", this.version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "Unknown";
        },
        searchString: function(k) {
            for (var g = 0; g < k.length; g++) {
                var h = k[g].string, j = k[g].prop;
                if (this.versionSearchString = k[g].versionSearch || k[g].identity, h) {
                    if (-1 != h.indexOf(k[g].subString)) return k[g].identity;
                } else if (j) return k[g].identity;
            }
        },
        searchVersion: function(h) {
            var g = h.indexOf(this.versionSearchString);
            if (-1 != g) return parseFloat(h.substring(g + this.versionSearchString.length + 1));
        },
        dataBrowser: [ {
            string: navigator.userAgent,
            subString: "Chrome",
            identity: "Chrome"
        }, {
            string: navigator.vendor,
            subString: "Apple",
            identity: "Safari",
            versionSearch: "Version"
        }, {
            prop: window.opera,
            identity: "Opera",
            versionSearch: "Version"
        }, {
            string: navigator.userAgent,
            subString: "Firefox",
            identity: "Firefox"
        }, {
            string: navigator.userAgent,
            subString: "MSIE",
            identity: "Explorer",
            versionSearch: "MSIE"
        } ]
    };
    a.init(), d.fn.disableSelection = function() {
        return this.each(function() {
            d(this).attr("unselectable", "on").css({
                "-webkit-touch-callout": "none",
                "-webkit-user-select": "none",
                "-khtml-user-select": "none",
                "-moz-user-select": "none",
                "-ms-user-select": "none",
                "user-select": "none"
            }).each(function() {
                this.onselectstart = function() {
                    return !1;
                };
            });
        });
    };
}(jQuery), angular.module("wembliApp", [ "ngRoute", "mgcrea.ngStrap", "wembliApp.controllers", "wembliApp.controllers.tickets", "wembliApp.controllers.header", "wembliApp.filters", "wembliApp.services", "wembliApp.services.header", "wembliApp.services.facebook", "wembliApp.services.twitter", "wembliApp.services.pixel", "wembliApp.services.venueMap", "wembliApp.directives", "wembliApp.directives.header", "wembliApp.directives.venueMap" ]).config([ "$routeProvider", "$locationProvider", function() {} ]).run([ "$timeout", "initRootScope", "$rootScope", "$location", "$route", "$window", "facebook", "twitter", "plan", "wembliRpc", function($timeout, initRootScope, $scope, $location, $route, $window, facebook, twitter, plan) {
    console.log("run event-options angular app"), $timeout(function() {
        plan.fetch(function() {});
    }), $window.fbAsyncInit = function() {
        facebook.getLoginStatus(), $scope.facebook = facebook;
    }, twitter.getLoginStatus();
} ]), angular.module("wembliApp.controllers.tickets", []).controller("TicketsCtrl", [ "$scope", "wembliRpc", "plan", "customer", "ticketPurchaseUrls", "tuMap", "$location", "$window", "$timeout", function($scope, wembliRpc, plan, customer, ticketPurchaseUrls, tuMap, $location, $window) {
    $scope.tnUrl = ticketPurchaseUrls.tn, console.log("running tix ctrl");
    var generateTnSessionId = function() {
        for (var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", sid_length = 5, sid = "", i = 0; sid_length > i; i++) {
            var rnum = Math.floor(Math.random() * chars.length);
            sid += chars.substring(rnum, rnum + 1);
        }
        return sid;
    };
    $scope.predicate = "ActualPrice", $scope.reverse = !1, $scope.showTicketsPopover = !1, 
    $scope.$watch("tickets", function(newVal, oldVal) {}), $scope.handlePriceRange = function() {
        wembliRpc.fetch("plan.setTicketsPriceRange", {
            low: $scope.priceRange.low,
            med: $scope.priceRange.med,
            high: $scope.priceRange.high
        }, function() {}), angular.forEach($scope.tickets, function(t) {
            return t.hide = !1, parseInt(t.ActualPrice) <= 100 ? t.hide = !$scope.priceRange.low : parseInt(t.ActualPrice) > 100 && parseInt(t.ActualPrice) <= 300 ? t.hide = !$scope.priceRange.med : parseInt(t.ActualPrice) > 300 ? t.hide = !$scope.priceRange.high : void 0;
        });
    }, $scope.sortByPrice = function() {
        "undefined" == typeof $scope.ticketSort && ($scope.ticketSort = 1), $scope.tickets.sort(function(a, b) {
            return scope.ticketSort ? a.ActualPrice - b.ActualPrice : b.ActualPrice - a.ActualPrice;
        }), $scope.ticketSort = $scope.ticketSort ? 0 : 1;
    }, $scope.sortBySection = function() {
        "undefined" == typeof $scope.sectionSort && ($scope.sectionSort = 1), $scope.tickets.sort(function(a, b) {
            return $scope.sectionSort ? a.Section.localeCompare(b.Section) : b.Section.localeCompare(a.Section);
        }), $scope.sectionSort = $scope.sectionSort ? 0 : 1;
    }, $scope.sortByQty = function() {
        "undefined" == typeof $scope.qtySort && ($scope.qtySort = 1), $scope.tickets.sort(function(a, b) {
            var cmpA = "", cmpB = "";
            return "string" == typeof a.ValidSplits.int ? cmpA = a.ValidSplits.int : (a.ValidSplits.int.sort(), 
            cmpA = a.ValidSplits.int[a.ValidSplits.int.length - 1]), "string" == typeof b.ValidSplits.int ? cmpB = b.ValidSplits.int : (b.ValidSplits.int.sort(), 
            cmpB = b.ValidSplits.int[b.ValidSplits.int.length - 1]), $scope.qtySort ? parseInt(cmpA) - parseInt(cmpB) : parseInt(cmpB) - parseInt(cmpA);
        }), $scope.qtySort = $scope.qtySort ? 0 : 1;
    }, $scope.$watch("showTicketsPopover", function(newVal) {
        "undefined" != typeof newVal && (newVal ? angular.element("#static-popover-content").show() : angular.element("#static-popover-content").hide());
    }), plan.get(function(p) {
        console.log($scope.plan), $scope.organizer = plan.getOrganizer(), $scope.context = plan.getContext() || "visitor", 
        $scope.backToPlan = !0, 0 == plan.getFriends().length && ($scope.backToPlan = !1), 
        "friend" === $scope.context && ($scope.backToPlan = !0), wembliRpc.fetch("event.getTickets", {
            eventID: p.event.eventId
        }, function(err, result) {
            if (console.log("fetched tix"), err) return void alert("error happened - contact help@wembli.com");
            "undefined" == typeof result.tickets[0] && ($scope.noTickets = !0, $scope.notFound = !0), 
            $scope.event = result.event, $scope.tickets = result.tickets, $scope.minTixPrice = 0, 
            $scope.maxTixPrice = 200;
            var newT = [];
            angular.forEach($scope.tickets, function(el) {
                if (!/parking/gi.test(el.Section)) {
                    parseInt(el.ActualPrice) < $scope.minTixPrice && ($scope.minTixPrice = parseInt(el.ActualPrice)), 
                    parseInt(el.ActualPrice) > $scope.maxTixPrice && ($scope.maxTixPrice = parseInt(el.ActualPrice)), 
                    el.selectedQty = el.ValidSplits.int[0], $scope.maxSplit = 1, el.maxSplit = 1, angular.forEach(el.ValidSplits.int, function(split) {
                        split > $scope.maxSplit && ($scope.maxSplit = split), split > el.maxSplit && (el.maxSplit = split), 
                        $location.search().qty && $location.search().qty == split && (el.selectedQty = $location.search().qty);
                    }), el.ticketsInPlan = !1, el.sessionId = generateTnSessionId();
                    for (var t = plan.getTickets(), i = 0; i < t.length; i++) t[i].ticketGroup.ID == el.ID && (el.ticketsInPlan = !0, 
                    el._id = t[i]._id);
                    newT.push(el);
                }
            }), $scope.tickets = newT;
            var options = {};
            options.MapId = $scope.plan.event.data.VenueConfigurationID, options.ControlsPosition = "Inside", 
            options.SingleSectionSelection = !0, options.OnInit = function(e, data) {
                console.log("maptype: "), console.log(data.MapType), "Interactive" === data.MapType && (/ga_venue_tn/.test($scope.plan.event.data.MapUrl) || ($(".ZoomIn").html("+"), 
                $(".ZoomOut").html("-")));
                var zl = $("#venue-map-container").tuMap("ConvertZoom");
                zl > 3 && (zl = parseInt(zl / 2)), $("#venue-map-container").tuMap("SetOptions", {
                    ZoomLevel: zl
                });
            }, options.OnError = function(e, Error) {
                console.log("error with map"), console.log(Error), 1 === Error.Code && "undefined" == typeof $scope.plan.event.data.MapURL && ($scope.plan.event.data.MapURL = "/images/no-seating-chart.jpg");
            }, options.ToolTipFormatter = function() {}, options.OnMouseover = function(e, Section) {
                Section.Active;
            }, options.OnMouseout = function(e, Section) {
                Section.Active;
            }, options.OnClick = function(e, Section) {
                Section.Active && Section.Selected;
            }, options.OnControlClick = function() {
                Section.Selected;
            }, options.OnGroupClick = function(e, Group) {
                Group.Selected;
            }, options.OnTicketSelected = function() {}, options.OnReset = function() {}, $($window).width() > 992 && ($(".addons-content-container").css("height", $($window).height() - 60), 
            $(".addons-list-container").css("height", $($window).height() - 60)), tuMap.init("#venue-map-container", options);
        });
    });
} ]).controller("TicketsLoginCtrl", [ "$rootScope", "$scope", "$location", "plan", "customer", "wembliRpc", "ticketPurchaseUrls", "pixel", "googleAnalytics", function($rootScope, $scope, $location, plan, customer, wembliRpc, ticketPurchaseUrls, pixel, googleAnalytics) {
    $scope.tnUrl = ticketPurchaseUrls.tn, $scope.listId = "a55323395c", plan.get(function() {
        $scope.$on("tickets-login-clicked", function(e, args) {
            $scope.redirectUrl = "/tickets/" + $scope.plan.event.eventId + "/" + $scope.plan.event.eventName + "/login/" + args.ticket.ID, 
            $scope.ticket = args.ticket;
        });
    }), $scope.authActions = {
        signup: function() {
            wembliRpc.fetch("customer.signup", {
                firstName: $scope.firstName,
                lastName: $scope.lastName,
                email: $scope.email,
                listId: $scope.listId
            }, function(err, result) {
                if (result.customer && customer.set(result.customer), result.loggedIn && ($rootScope.loggedIn = result.loggedIn), 
                result.exists) return $scope.formError = !1, $scope.signupError = !0, void ($scope.accountExists = result.exists);
                if (result.formError) return $scope.signupError = !0, $scope.formError = !0, void ($scope.accountExists = !1);
                $scope.signupError = !1, $scope.formError = !1, $scope.accountExists = !1;
                var gCookie = googleAnalytics.getCookie();
                pixel.fire({
                    type: "signup",
                    campaign: gCookie.__utmz.utmccn,
                    source: "google",
                    medium: gCookie.__utmz.utmcmd,
                    term: gCookie.__utmz.utmctr,
                    content: "1070734106"
                }), pixel.fire({
                    type: "signup",
                    campaign: "Signup Conversion Pixel Facebook Ad",
                    source: "facebook",
                    medium: "cpc",
                    term: "",
                    content: "6013588786171"
                });
            }, function(data) {
                return $scope.continueSpinner = !0, data;
            }, function(data) {
                return $scope.continueSpinner = !1, JSON.parse(data);
            });
        },
        login: function() {
            wembliRpc.fetch("customer.login", {
                email: $scope.email,
                password: $scope.password
            }, function(err, result) {
                result.error && ($scope.loginError = result.error, "undefined" != typeof result.noPassword ? $scope.noPassword = result.noPassword : result.invalidCredentials && ($scope.invalidCredentials = result.invalidCredentials)), 
                result.customer && customer.set(result.customer), result.loggedIn && ($rootScope.loggedIn = result.loggedIn);
            });
        }
    };
} ]).controller("TicketsOffsiteCtrl", [ "$scope", "plan", "$http", "$location", "$rootScope", function($scope, plan, $http, $location, $rootScope) {
    plan.get(function(p) {
        $scope.plan = p;
    }), $scope.$on("tickets-offsite-clicked", function(e, args) {
        $scope.qty = args.qty, $scope.amountPaid = args.amountPaid, $scope.eventId = args.eventId, 
        $scope.eventName = args.eventName, $scope.sessionId = args.sessionId, $scope.ticketGroup = args.ticketGroup, 
        $scope.ticketId = args.ticketId, $scope.backToPlan = "undefined" == typeof args.backToPlan || "false" == args.backToPlan ? !1 : args.backToPlan, 
        $scope.continueLink = $scope.backToPlan ? "/plan" : "/event-options/" + args.eventId + "/" + args.eventName;
    }), $scope.showButton = function() {
        return "bought" === $scope.ticketsOffsite;
    }, $scope.submitForm = function() {
        plan.addTicketGroupReceipt({
            ticketId: $scope.ticketId,
            service: "tn",
            receipt: {
                qty: $scope.qty,
                amountPaid: $scope.amountPaid
            }
        }, function(err, result) {
            $("#tickets-offsite-modal").modal("hide"), $location.path($scope.continueLink ? $scope.continueLink : "/plan");
            var t = plan.getTickets(), newT = [];
            if ("undefined" == typeof t[0]) newT.push(result.ticket); else for (var i = 0; i < t.length; i++) newT.push((t[i]._id = result.ticket._id) ? result.ticket : t[i]);
            plan.setTickets(newT), $rootScope.$broadcast("tickets-changed", {
                restaurants: newT
            });
        });
    }, $scope.cancelForm = function() {
        plan.removeTicketGroup({
            ticketId: $scope.ticketId
        }, function(err, results) {
            $("#tickets-offsite-modal").modal("hide"), $rootScope.$broadcast("tickets-changed", {
                tickets: results.tickets
            });
        });
    };
} ]).controller("VenueMapCtrl", [ "$rootScope", "$scope", "interactiveMapDefaults", "plan", "$filter", "customer", "wembliRpc", function($rootScope, $scope, interactiveMapDefaults, plan, $filter, customer, wembliRpc) {
    plan.get(function(p) {
        $scope.plan = p, $scope.priceRange = {}, $scope.eventOptionsLink = "/event-options/" + p.event.eventId + "/" + p.event.eventName, 
        $scope.priceRange.low = p.preferences.tickets.priceRange.low || !0, $scope.priceRange.med = p.preferences.tickets.priceRange.med || !0, 
        $scope.priceRange.high = p.preferences.tickets.priceRange.high || !0;
    }), $scope.determineRange = function(price) {
        var i = parseInt(price);
        return 100 >= i ? "$" : i > 100 && 300 >= i ? "$$" : i > 300 ? "$$$" : void 0;
    }, $scope.removeTicketGroup = function(ticketId) {
        wembliRpc.fetch("plan.removeTicketGroup", {
            ticketId: ticketId
        }, function(err, result) {
            plan.setTickets(result.tickets);
        });
    }, $scope.determineTixAvailable = function(tix) {
        "undefined" == typeof tix[0] && (tix = [ tix ]);
        var highest = tix[0];
        angular.forEach(tix, function(el) {
            el > highest && (highest = el);
        });
        var str = "up to " + highest + " tix available";
        return str;
    };
} ]), angular.module("wembliApp.directives.venueMap", []).directive("ticketsLoginModal", [ "$rootScope", "$window", "$location", "$http", "$timeout", "fetchModals", "plan", function($rootScope, $window, $location) {
    return {
        restrict: "EAC",
        compile: function() {
            return function(scope, element, attr) {
                attr.$observe("ticket", function(val) {
                    var ticket = JSON.parse(val), displayTicketsLoginModal = function() {
                        $rootScope.$broadcast("tickets-login-clicked", {
                            ticket: ticket
                        }), $("#tickets-login-modal").length > 0 ? $("#tickets-login-modal").modal("show") : $rootScope.$on("tickets-login-modal-fetched", function() {
                            $("#tickets-login-modal").modal("show");
                        });
                    };
                    if (/tickets-login-modal/.test($location.hash())) {
                        var h = $location.hash();
                        ticket.ID === h.split("-")[3] && displayTicketsLoginModal();
                    }
                    element.click(displayTicketsLoginModal);
                });
            };
        }
    };
} ]).directive("buyTicketsOffsite", [ "$rootScope", "$window", "$location", "$http", "$timeout", "fetchModals", "plan", function($rootScope, $window, $location, $http, $timeout, fetchModals, plan) {
    return {
        restrict: "EAC",
        compile: function() {
            return function(scope, element, attr) {
                attr.$observe("ticket", function(val) {
                    if ("undefined" != typeof val && "" !== val) {
                        var ticket = JSON.parse(val), p = plan.get();
                        element.click(function() {
                            var shipping = 15, serviceCharge = .15 * parseFloat(ticket.ActualPrice) * parseInt(ticket.selectedQty), actualPrice = parseFloat(ticket.ActualPrice) * parseInt(ticket.selectedQty), amountPaid = parseFloat(actualPrice) + parseFloat(serviceCharge) + parseFloat(shipping);
                            amountPaid = amountPaid.toFixed(2);
                            var backToPlan = "undefined" == typeof attr.backToPlan ? !1 : "true" === attr.backToPlan;
                            plan.addTicketGroup({
                                service: "tn",
                                eventId: p.event.eventId,
                                ticketGroup: ticket,
                                qty: ticket.selectedQty,
                                total: amountPaid,
                                payment: JSON.stringify({
                                    transactionToken: ticket.sessionId,
                                    amount: amountPaid,
                                    qty: ticket.selectedQty
                                })
                            }, function(err, results) {
                                $rootScope.$broadcast("tickets-offsite-clicked", {
                                    qty: ticket.selectedQty,
                                    amountPaid: amountPaid,
                                    ticketGroup: ticket,
                                    eventId: p.event.eventId,
                                    eventName: p.event.eventName,
                                    sessionId: ticket.sessionId,
                                    ticketId: results.ticketGroup._id,
                                    backToPlan: backToPlan
                                });
                                $timeout(function() {
                                    $("#tickets-login-modal").modal("hide"), $("#tickets-offsite-modal").modal("show");
                                }, 1500);
                            });
                        });
                    }
                });
            };
        }
    };
} ]).directive("addTicketsToPlan", [ "$rootScope", "$window", "$location", "$http", "$timeout", "fetchModals", "plan", "wembliRpc", function($rootScope, $window, $location, $http, $timeout, fetchModals, plan, wembliRpc) {
    return {
        restrict: "EAC",
        compile: function() {
            return function(scope, element, attr) {
                element.click(function() {
                    var ticket = JSON.parse(attr.ticket);
                    ticket.selectedQty = attr.quantity, wembliRpc.fetch("plan.addTicketGroup", {
                        ticketGroup: ticket
                    }, function() {});
                });
            };
        }
    };
} ]).directive("ticketsPopover", [ "plan", "wembliRpc", "$compile", function(plan, wembliRpc, $compile) {
    return {
        scope: !1,
        restrict: "EAC",
        compile: function() {
            var html = $("#static-popover-content").html();
            return function(scope) {
                console.log(scope.tickets);
                var originalLeave = $.fn.popover.Constructor.prototype.leave;
                $.fn.popover.Constructor.prototype.leave = function(obj) {
                    var self, container, timeout;
                    self = obj instanceof this.constructor ? obj : $(obj.currentTarget)[this.type](this._options).data(this.type), 
                    originalLeave.call(this, obj), obj.currentTarget && (container = $(obj.currentTarget).siblings(".popover"), 
                    timeout = self.timeout, container.one("mouseenter", function() {
                        clearTimeout(timeout), container.one("mouseleave", function() {
                            $.fn.popover.Constructor.prototype.leave.call(self, obj);
                        });
                    }));
                }, scope.$on("load-static-map", function() {
                    var content = $compile(html)(scope);
                    $("#static-map-image").popover({
                        placement: "left",
                        trigger: "hover",
                        container: "#venue-map-container",
                        delay: {
                            show: 100,
                            hide: 400
                        },
                        animation: !1,
                        content: function() {
                            return content;
                        },
                        html: !0
                    });
                });
            };
        }
    };
} ]).directive("interactiveVenueMap", [ "$timeout", "$rootScope", "$compile", "interactiveMapDefaults", "wembliRpc", "$window", "$templateCache", "plan", "$location", "loadingModal", function($timeout, $rootScope, $compile, interactiveMapDefaults, wembliRpc, $window, $templateCache, plan, $location, loadingModal) {
    return {
        restrict: "E",
        replace: !0,
        cache: !1,
        templateUrl: "/partials/interactive-venue-map",
        controller: [ "$scope", "$element", "$attrs", "$transclude", function() {} ],
        compile: function() {
            console.log("compile map");
            var generateTnSessionId = function() {
                for (var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", sid_length = 5, sid = "", i = 0; sid_length > i; i++) {
                    var rnum = Math.floor(Math.random() * chars.length);
                    sid += chars.substring(rnum, rnum + 1);
                }
                return sid;
            };
            return function(scope) {
                function initStaticMap() {
                    scope.event.MapURL || (scope.event.MapURL = "/images/no-seating-chart.jpg");
                    var img = new Image();
                    img.src = scope.event.MapURL, img.onload = function() {
                        var w = img.width, h = img.height;
                        $("#venue-map-container").css("width", $($window).width() - 680), $("#venue-map-container").css("position", "relative"), 
                        $("#venue-map-container").empty().css("overflow-y", "auto").css("float", "right").prepend('<div id="static-map-image" style="overflow-y:auto;background:transparent url(\'' + scope.event.MapURL + "') no-repeat center center;margin:auto;padding:20px;height:" + h + "px;width:" + w + 'px;" />');
                        var h2 = $("#venue-map-container").height() - 220;
                        $(".ticket-list-container").height(h2), $("#static-map-image").mouseenter(function() {
                            console.log("enter mouse"), scope.$apply(function() {
                                scope.showTicketsPopover = !0;
                            });
                        }), $("#static-map-image").mouseleave(function() {
                            console.log("enter mouse"), scope.$apply(function() {
                                scope.showTicketsPopover = !1;
                            });
                        });
                        $.fn.popover.Constructor.prototype.applyPlacement;
                        $.fn.popover.Constructor.prototype.applyPlacement = function(offset, placement) {
                            offset.top = 200;
                            var actualWidth, actualHeight, delta, replace, $tip = this.tip(), width = $tip[0].offsetWidth, height = $tip[0].offsetHeight;
                            $tip.offset(offset).addClass(placement).addClass("in"), actualWidth = $tip[0].offsetWidth, 
                            actualHeight = $tip[0].offsetHeight, "top" == placement && actualHeight != height && (offset.top = offset.top + height - actualHeight, 
                            replace = !0), "bottom" == placement || "top" == placement ? (delta = 0, offset.left < 0 && (delta = -2 * offset.left, 
                            offset.left = 0, $tip.offset(offset), actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight), 
                            this.replaceArrow(delta - width + actualWidth, actualWidth, "left")) : this.replaceArrow(actualHeight - height, actualHeight, "top"), 
                            replace && $tip.offset(offset), $(".ticket-list-container").height(h);
                        };
                    };
                }
                console.log("link map"), $templateCache.remove("/partials/interactive-venue-map"), 
                scope.predicate = "ActualPrice", scope.reverse = !1, scope.showTicketsPopover = !1, 
                scope.$watch("tickets", function(newVal, oldVal) {
                    newVal !== oldVal && (console.log("refresh reset map"), $("#venue-map-container").tuMap("Refresh", "ProcessTickets"));
                }), scope.handlePriceRange = function() {
                    wembliRpc.fetch("plan.setTicketsPriceRange", {
                        low: scope.priceRange.low,
                        med: scope.priceRange.med,
                        high: scope.priceRange.high
                    }, function() {}), angular.forEach(scope.tickets, function(t) {
                        return t.hide = !1, parseInt(t.ActualPrice) <= 100 ? t.hide = !scope.priceRange.low : parseInt(t.ActualPrice) > 100 && parseInt(t.ActualPrice) <= 300 ? t.hide = !scope.priceRange.med : parseInt(t.ActualPrice) > 300 ? t.hide = !scope.priceRange.high : void 0;
                    });
                }, scope.sortByPrice = function() {
                    "undefined" == typeof scope.ticketSort && (scope.ticketSort = 1), scope.tickets.sort(function(a, b) {
                        return scope.ticketSort ? a.ActualPrice - b.ActualPrice : b.ActualPrice - a.ActualPrice;
                    }), scope.ticketSort = scope.ticketSort ? 0 : 1;
                }, scope.sortBySection = function() {
                    "undefined" == typeof scope.sectionSort && (scope.sectionSort = 1), scope.tickets.sort(function(a, b) {
                        return scope.sectionSort ? a.Section.localeCompare(b.Section) : b.Section.localeCompare(a.Section);
                    }), scope.sectionSort = scope.sectionSort ? 0 : 1;
                }, scope.sortByQty = function() {
                    "undefined" == typeof scope.qtySort && (scope.qtySort = 1), scope.tickets.sort(function(a, b) {
                        var cmpA = "", cmpB = "";
                        return "string" == typeof a.ValidSplits.int ? cmpA = a.ValidSplits.int : (a.ValidSplits.int.sort(), 
                        cmpA = a.ValidSplits.int[a.ValidSplits.int.length - 1]), "string" == typeof b.ValidSplits.int ? cmpB = b.ValidSplits.int : (b.ValidSplits.int.sort(), 
                        cmpB = b.ValidSplits.int[b.ValidSplits.int.length - 1]), scope.qtySort ? parseInt(cmpA) - parseInt(cmpB) : parseInt(cmpB) - parseInt(cmpA);
                    }), scope.qtySort = scope.qtySort ? 0 : 1;
                }, scope.$watch("showTicketsPopover", function(newVal) {
                    "undefined" != typeof newVal && (newVal ? angular.element("#static-popover-content").show() : angular.element("#static-popover-content").hide());
                }), plan.get(function(p) {
                    console.log("get plan"), wembliRpc.fetch("event.getTickets", {
                        eventID: p.event.eventId
                    }, function(err, result) {
                        if (console.log("fetched tix"), err) return void alert("error happened - contact help@wembli.com");
                        "undefined" == typeof result.tickets[0] && (loadingModal.hide(), scope.noTickets = !0, 
                        scope.notFound = !0), scope.event = result.event, scope.tickets = result.tickets, 
                        scope.minTixPrice = 0, scope.maxTixPrice = 200;
                        var newT = [];
                        angular.forEach(scope.tickets, function(el) {
                            if (!/parking/gi.test(el.Section)) {
                                parseInt(el.ActualPrice) < scope.minTixPrice && (scope.minTixPrice = parseInt(el.ActualPrice)), 
                                parseInt(el.ActualPrice) > scope.maxTixPrice && (scope.maxTixPrice = parseInt(el.ActualPrice)), 
                                el.selectedQty = el.ValidSplits.int[0], scope.maxSplit = 1, el.maxSplit = 1, angular.forEach(el.ValidSplits.int, function(split) {
                                    split > scope.maxSplit && (scope.maxSplit = split), split > el.maxSplit && (el.maxSplit = split), 
                                    $location.search().qty && $location.search().qty == split && (el.selectedQty = $location.search().qty);
                                }), el.ticketsInPlan = !1, el.sessionId = generateTnSessionId();
                                for (var t = plan.getTickets(), i = 0; i < t.length; i++) t[i].ticketGroup.ID == el.ID && (el.ticketsInPlan = !0, 
                                el._id = t[i]._id);
                                newT.push(el);
                            }
                        }), scope.tickets = newT;
                        var filterTickets = function(args) {
                            var priceRange = $(".price-slider").slider("option", "values");
                            $("#venue-map-container").tuMap("SetOptions", {
                                TicketsFilter: {
                                    MinPrice: priceRange[0],
                                    MaxPrice: priceRange[1],
                                    Quantity: args.quantity,
                                    eTicket: $("#e-ticket-filter").is(":checked")
                                }
                            }).tuMap("Refresh");
                        }, options = interactiveMapDefaults;
                        if (options.MapId = scope.event.VenueConfigurationID, options.EventId = scope.event.ID, 
                        options.OnInit = function(e, MapType) {
                            console.log(MapType), $(".tuMapControl").parent("div").attr("style", "display:none;position:absolute;left:5px;top:120px;font-size:12px"), 
                            "Interactive" == MapType ? /ga_venue_tn/.test(scope.event.MapUrl) ? initStaticMap() : ($(".ZoomIn").html("+"), 
                            $(".ZoomOut").html("-")) : initStaticMap(), loadingModal.hide();
                        }, options.OnError = function(e, Error) {
                            console.log(Error), 1 === Error.Code && ("undefined" == typeof scope.event.MapURL && (scope.event.MapURL = "/images/no-seating-chart.jpg"), 
                            initStaticMap(), loadingModal.hide());
                        }, options.ToolTipFormatter = function() {}, options.OnMouseover = function(e, Section) {
                            Section.Active;
                        }, options.OnMouseout = function(e, Section) {
                            Section.Active;
                        }, options.OnClick = function(e, Section) {
                            Section.Active && Section.Selected;
                        }, options.OnControlClick = function() {
                            Section.Selected;
                        }, options.OnGroupClick = function(e, Group) {
                            Group.Selected;
                        }, options.OnTicketSelected = function() {}, options.OnReset = function() {}, $("#venue-map-container").css("height", $($window).height() - 172), 
                        $("#tickets").css("height", $($window).height() - 172), $("#venue-map-container").tuMap(options), 
                        $(".price-slider").length) {
                            $(".price-slider").slider({
                                range: !0,
                                min: scope.minTixPrice,
                                max: scope.maxTixPrice,
                                step: 5,
                                values: [ scope.minTixPrice, scope.maxTixPrice ],
                                slide: function(event, ui) {
                                    $(".amount").val("$" + ui.values[0] + " - $" + ui.values[1]);
                                },
                                stop: function() {
                                    var q = $(this).val();
                                    filterTickets({
                                        quantity: q
                                    });
                                }
                            });
                            var amtVal = "$" + $(".price-slider").slider("values", 0) + " - $" + $(".price-slider").slider("values", 1);
                            $(".amount").val(amtVal);
                        }
                        if ($(".quantity-filter").length) {
                            $(".quantity-filter").change(function() {
                                var q = $(this).val();
                                filterTickets({
                                    quantity: q
                                });
                            });
                            var s = $location.search();
                            s.qty && ($(".quantity-filter").val(s.qty), filterTickets({
                                quantity: s.qty
                            }));
                        }
                    });
                });
            };
        }
    };
} ]), angular.module("wembliApp.services.venueMap", []).factory("tuMap", [ function() {
    var self = this;
    return self.options = {
        MapSet: "tn",
        MapType: "Interactive",
        ZoomLevel: 8,
        ColorScheme: 1,
        FailOverMapUrl: "http://data.ticketutils.com/Charts/No-Seating-Chart.jpg",
        GroupsContainer: "#groups-container",
        RowSelector: ".ticket-row",
        RowNumberSelector: ".seat-row",
        SectionSelector: ".ticket-section",
        PriceSelector: ".actual-price",
        QuantitySelector: ".ticket-quantity",
        eTicketSelector: ".e-ticket",
        ResetButtonText: "Reset Map"
    }, {
        options: self.options,
        init: function(el, options) {
            var opts = angular.extend(self.options, options);
            return console.log(opts), console.log("tumap for " + el), $(el).tuMap(opts);
        }
    };
} ]);